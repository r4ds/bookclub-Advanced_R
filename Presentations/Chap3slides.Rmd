---
title: "Advanced R by Hadley Wickham"
subtitle: "Chapter 3: Vectors"
author: "Tony ElHabr"
institute: "@TonyElHabr"
date: " `r Sys.Date()` "
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(include = TRUE)
```
<style>
img {
  display: block;
  margin: 0 auto;
}
hide {
  display: none;
}

</style>

# What's in Chapter 3

--

- Section 3.2: atomic vectors

- Section 3.3: attributes

- Section 3.4: "special" vectors (S3 atomic vectors)

- Section 3.5: lists

- Section 3.6: data frames and tibbles

- Section 3.7: `NULL`

--

---

# Vectors

--

+ 2 types: atomic and list

<hide>
The difference is that elements of atomic vectors have the same "type", while those of list vectors can be of different types. In general, the word "atomic" describes things that are irreducible units or components of a system. Here, the irreducible units are the "data types"---yes, that term can be amiguous--and the system is the R programming language. So we can see why its appropriate to call vectors of a single type "atomic". Lists have their own special properties, which we'll get to later; but here, for our direct comparison with atomic vectors, we mainly see them as the "other" type of vector.
</hide>

.pull-left[

atomic

```{r echo=F, include=T, eval=T, out.width='100%'}
knitr::include_graphics('https://d33wubrfki0l68.cloudfront.net/8a3d360c80da1186b1373a0ff0ddf7803b96e20d/254c6/diagrams/vectors/atomic.png')
```

]

.pull-right[

list

```{r echo=F, include=T, eval=T, out.width='100%'}
knitr::include_graphics('https://d33wubrfki0l68.cloudfront.net/9628eed602df6fd55d9bced4fba0a5a85d93db8a/36c16/diagrams/vectors/list.png')
```

]

--

... and there is also `NULL`


<hide>
Bringing `NULL` into the picture, we have our complete set of vector types.
</hide>

```{r echo=F, include=T, eval=T, out.width='40%'}
knitr::include_graphics('https://d33wubrfki0l68.cloudfront.net/2ff3a6cebf1bb80abb2a814ae1cfc67b12817713/ae848/diagrams/vectors/summary-tree.png')
```

---

# Atomic Vectors

--

<hide>
There are 4.... There are aso 2 others: complex and raw. They aren't as commonly used.
</hide>

+ **4** primary types: logical, integer, double, character (i.e. strings)


```{r echo=F, include=T, eval=T, out.width='30%'}
knitr::include_graphics('https://d33wubrfki0l68.cloudfront.net/eb6730b841e32292d9ff36b33a590e24b6221f43/57192/diagrams/vectors/summary-tree-atomic.png')
```

```{r eval=F}
c(TRUE, FALSE, T, F)
c(1234L, 42L)
c(3.14, .314e1, 0xbada55)
c('single quote', "double quote")
```

<hide>
I think everyone is probably familiar with these types, so I won't spend too much time on them.

When we create individual instances of these "types", we have what we call "scalars". In other programming languages, such a form---a single value of a single type---may have different properties. But with R, everything is a vector, even "scalars".
</hide>

--

<hide>
Use `typeof()` to identify the type of a variable.
</hide>

```{r eval=T}
typeof(raw(42))
typeof(complex(real = 0, imaginary = -1))
```

---

#  Coercion

--

+ **Coercion** happens when you attempt to vectors with elements of different type.

```{r eval=T}
c(1, 1.01)
```

<hide>
Coercion often happens automatically. Most mathematical functions (+, log, abs, etc.) will coerce to numeric. 
</hide>

--

+ Coercion order: character → double → integer → logical

```{r eval=T}
c(1, 1.01) # to double
c(1, '1') # to character
c(1, TRUE) # to integer
```

--

+ Explicity coercion with `as.*()` functions

```{r eval=T}
as.integer(c(1, 1.01))
```

--

+ Failed coercion leads to warnings and `NA`

```{r eval=T}
as.integer(c('1', '1.01', 'a'))
```

---

# `NA` and `NULL`

.pull-left[

--

+ `NA` is a "sentinel" value for explicit missingness

--

+ `NA` can be of any type, e.g. `NA_integer_`, `NA_character_`, etc.

<hide>
Default is logical, which is achieved by just `NA`.
</hide>

+ Calculations involving `NA`s usually result in more `NA`s

```{r eval=T}
1 + NA
```
--

...although not always

```{r eval=T}
1 | NA
```

--

+ Test with `is.na()`

]


.pull-right[

+ `NULL` is its own vector type

```{r eval=T}
typeof(NULL)
```

--

+ Zero-length

```{r eval=T}
length(NULL)
```

--

+ Cannot have attributes

```{r eval=T}
x <- NULL
attr(x, 'y') <- 1
```

<hide>
A vector with `NA` can have attributes.
</hide>

--

+ Test with `is.null()`

]

<hide>
Speaking of attributes...
</hide>

---

# Attributes

--

+ Name-values pairs of metadata for R objects

--

+ Get and set single attributes with `attr()`

```{r eval=T}
x <- 'apple'
attr(x, 'emoji') <- emo::ji('apple')
attr(x, 'emoji')
```

--

+ Get and set multiple attributes with `attributes()` and `structures()`

--

```{r eval=T}
x <- structure('apple', emoji = emo::ji('apple'), `type of food` = 'fruit')
attributes(x)
```

--

+ With the exception of `names()` and `dim()`, most attributes are lost with calculations.

```{r eval=T}
attributes(x[1])
```

---

# `names()` and `dim()`

--

+ `names()` can be assigned in multiple ways.

```{r eval=T}
x <- c(apple = TRUE, banana = FALSE)
names(TRUE:FALSE) <- c('apple', 'banana')
setNames(TRUE:FALSE, c('apple', 'banana')
```
--

+ `dim()` has the capability of turning a 1-d vector into a 2-d a matrix of n-d array.

```{r eval=T}
a <- matrix(1:6, nrow = 2, ncol = 3)
a
b <- array(1:6, dim = c(1, 3, 2))
b
```

--

Well, that isn't completely true...

--

+ 1-d vector has `NULL` dimensions

+ matrices and arrays can be a single column or row vector

---

+

# S3 atomic vectors

--

+ Objects with a `class` attribute, making it an **S3 object**

<hide>
This means that the vector will behavbe different when to a generic function such as `print()` or even mathematical operators such as `+`
</hide>

+ **4** important S3 vector types in base R: factor (categorical), Date (Date), POSIXct (date-time), duration (difftime).

```{r echo=F, include=T, eval=T, out.width='30%'}
knitr::include_graphics('https://d33wubrfki0l68.cloudfront.net/baa19d0ebf9b97949a7ad259b29a1c4ae031c8e2/8e9b8/diagrams/vectors/summary-tree-s3-1.png')
```

---

# Factors

--

+ Vector that can only contain pre-defined values

<hide>
Thus, it is commonly used to store categorical data.
</hide>

+ Has two attributes: `class` and `levels`

+ Built on top of integers, not characters

```{r eval=T}
fruits <- factor(c('banana', 'apple', 'carrot'))
fruits
```
<hide>
Note that it is ordered alphabetically by default.
</hide>

--

+ Variation: **ordered** factors

```{r eval=T}
numbers <- ordered(c('two', 'three', 'one'), levels = c('one', 'two', 'three'))
numbers
```

<hide>
[Interesting story about `stringsAsFactors`](https://simplystatistics.org/2015/07/24/stringsasfactors-an-unauthorized-biography/)
</hide>

---

# Dates and date-times

---

# Lists


```{r echo=F, include=T, eval=T, out.width='30%'}
knitr::include_graphics('https://d33wubrfki0l68.cloudfront.net/c13ad724c9a86a01e96519066ce09f7ce361d29c/5cf75/diagrams/vectors/list-recursive.png')
```

<hide>
Lists are sometimes called "recursive" vectors because a list can contain other lists. Atomic vectors don't have the same capability
</hide>

---

# Data frames and tibbles

---

# `NULL`

---

# In Review

.pull-left[

atomic + atomic S3

```{r echo=F, include=T, eval=T, out.width='100%'}
knitr::include_graphics('https://d33wubrfki0l68.cloudfront.net/baa19d0ebf9b97949a7ad259b29a1c4ae031c8e2/8e9b8/diagrams/vectors/summary-tree-s3-1.png')
```

]

--
  
.pull-right[

list

```{r echo=F, include=T, eval=T, out.width='100%'}
knitr::include_graphics('https://d33wubrfki0l68.cloudfront.net/9ec5e1f8982238a413847eb5c9bbc5dcf44c9893/bc590/diagrams/vectors/summary-tree-s3-2.png')
```

]


