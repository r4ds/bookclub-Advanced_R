<!DOCTYPE html>
<html>
  <head>
    <title>Advanced R by Hadley Wickham</title>
    <meta charset="utf-8">
    <meta name="author" content="Tony ElHabr" />
    <meta name="date" content="2020-04-12" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Advanced R by Hadley Wickham
## Chapter 3: Vectors
### Tony ElHabr
### 2020-04-12

---




&lt;style&gt;
img {
  display: block;
  margin: 0 auto;
}
hide {
  display: none;
}

&lt;/style&gt;

# What's in Chapter 3

--

- Section 3.2: atomic vectors

- Section 3.3: attributes

- Section 3.4: "special" vectors (S3 atomic vectors)

- Section 3.5: lists

- Section 3.6: data frames and tibbles

- Section 3.7: `NULL`

--

---

# Vectors

+ 2 types: atomic and list


&lt;hide&gt;
The difference is that elements of atomic vectors have the same "type", while those of list vectors can be of different types. In general, the word "atomic" describes things that are irreducible units or components of a system. Here, the irreducible units are the "data types"---yes, that term can be amiguous--and the system is the R programming language. So we can see why its appropriate to call vectors of a single type "atomic". Lists have their own special properties, which we'll get to later; but here, for our direct comparison with atomic vectors, we mainly see them as the "other" type of vector.
&lt;/hide&gt;

&lt;hide&gt;
~~And here's a side-by-side comparison of how the two can be visually represented.~~
&lt;/hide&gt;

.pull-left[

atomic

&lt;img src="https://d33wubrfki0l68.cloudfront.net/8a3d360c80da1186b1373a0ff0ddf7803b96e20d/254c6/diagrams/vectors/atomic.png" width="100%" /&gt;

]

.pull-right[

list

&lt;img src="https://d33wubrfki0l68.cloudfront.net/9628eed602df6fd55d9bced4fba0a5a85d93db8a/36c16/diagrams/vectors/list.png" width="100%" /&gt;

]

--

... and there is also `NULL`


&lt;hide&gt;
Oh, and there is also `NULL`. (There's always someone crying for attention.) Bringing `NULL` into the picture, we have our complete set of vector types.
&lt;/hide&gt;

&lt;img src="https://d33wubrfki0l68.cloudfront.net/2ff3a6cebf1bb80abb2a814ae1cfc67b12817713/ae848/diagrams/vectors/summary-tree.png" width="40%" /&gt;

---

# Atomic Vectors

&lt;hide&gt;
There are 4.... There are aso 2 others: complex and raw. They aren't as commonly used.
&lt;/hide&gt;

+ **4** primary types: logical, integer, double, character (i.e. strings)


&lt;img src="https://d33wubrfki0l68.cloudfront.net/eb6730b841e32292d9ff36b33a590e24b6221f43/57192/diagrams/vectors/summary-tree-atomic.png" width="30%" /&gt;


```r
c(TRUE, FALSE) # c(T, F)
c(42L)
c(3.14, .314e1)
c('single quote', "double quote")
```

&lt;hide&gt;
I think everyone is probably familiar with these types, so I won't spend too much time on them.

When we create individual instances of these "types", we have what we call "scalars". In other programming languages, such a form---a single value of a single type---may have different properties. But with R, everything is a vector, even "scalars".
&lt;/hide&gt;


---

# Attributes

---

# S3 atomic vectors

&lt;img src="https://d33wubrfki0l68.cloudfront.net/baa19d0ebf9b97949a7ad259b29a1c4ae031c8e2/8e9b8/diagrams/vectors/summary-tree-s3-1.png" width="30%" /&gt;

---

# Lists


&lt;img src="https://d33wubrfki0l68.cloudfront.net/c13ad724c9a86a01e96519066ce09f7ce361d29c/5cf75/diagrams/vectors/list-recursive.png" width="30%" /&gt;

&lt;hide&gt;
Lists are sometimes called "recursive" vectors because a list can contain other lists. Atomic vectors don't have the same capability
&lt;/hide&gt;

---

# Data frames and tibbles

---

# `NULL`

---

# In Review

.pull-left[

atomic + atomic S3

&lt;img src="https://d33wubrfki0l68.cloudfront.net/baa19d0ebf9b97949a7ad259b29a1c4ae031c8e2/8e9b8/diagrams/vectors/summary-tree-s3-1.png" width="100%" /&gt;

]

--
  
.pull-right[

list

&lt;img src="https://d33wubrfki0l68.cloudfront.net/9ec5e1f8982238a413847eb5c9bbc5dcf44c9893/bc590/diagrams/vectors/summary-tree-s3-2.png" width="100%" /&gt;

]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
