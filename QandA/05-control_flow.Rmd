# Control Flow

```{r, include=FALSE}
library(tidyverse)
library(kableExtra)
library(lobstr)
```

## 5.2.2 Vectorised if

:::question
Why does `if` `else` print `"Out of range"` once but `ifelse` prints it twice?

```{r, eval=FALSE}
if (sample(1:10, 1) == 1) print("In range") else print("Out of range")
```

```
[1] "Out of range"
```

```{r, eval=FALSE}
ifelse((sample(1:10, 1) == 1), print("In range"), print("Out of range"))
```

```
[1] "Out of range"
[1] "Out of range"
```
:::

```{r, eval=FALSE}
var <- if (sample(1:10, 1) == 1) print("In range")
var
```

```
NULL
```

```{r}
var <- ifelse((sample(1:10, 1) == 1), print("In range"), print("Out of range"))
var
```

`ifelse` explicitly returns its result, whereas `if` invisibly returns it!


## 5.3 Loops 

:::question
Can the body of the loop change the set?
:::

```{r}
my_set <- c(1, 20, 99)

for (i in my_set){
  if (i==1){
    my_set[9]= 20
    }
  print("hello")
  print(my_set)
  }
```
Looks like you can't!

## 5.2.3 switch statement

:::question
"Closely related to if is the `switch()` statement. Itâ€™s a compact, special purpose equivalent"

What is meant here by "special purpose"? Can we come up with a case where you can't substitute `if` for `switch` or the other way around? Use `switch`. Is it safe to say to `switch` when you have character inputs (as the book suggests) and use `case_when` or `if` for numerics?
:::

:::TODO
XXX
:::

## 5.3.1 common pitfalls

:::question
What does the book mean by leveraging `vector` for preallocating the loop output? How is this different from creating an empty list to instantiate the loop? 

```{r}
means <- c(1, 50, 20)

out_vector <- vector("list", length(means))
for (i in 1:length(means)) {
  out_vector[[i]] <- rnorm(10, means[[i]])
}

out_list <- list()
for (i in 1:length(means)) {
  out_list[[i]] <- rnorm(10, means[[i]])
}
```
:::

:::TODO
XXX
:::

:::question
The book warns against using `length(x)` and suggests using `seq_along` instead. Is there any downside to using `seq_along` or a case when you'd prefer `length(x)` over `seq_along(x)`? I can't think of any downsides to using it!
:::

:::TODO
XXX
:::

## 5.3.3.1 Exercises

:::question
```{r}
x <- numeric()
out <- vector("list", length(x))
for (i in 1:length(x)) {
  out[i] <- x[i] ^ 2
}
out
```

I understand that this works because we can count down in a loop - so the first iteration `x[1] == NA`, and the second `x[2] == numeric(0)` but where does this value go? Is it just evaluated but not stored since R counts from 1?
:::

:::TODO
XXX
:::


## Conclusion

:::question
Can we put these concepts together in diagram form? Let's work on improving these schematics!
:::

```{r, echo=FALSE}
knitr::include_graphics("images/controlflow.png")
```
