[
["welcome.html", "Advanced R Companion Chapter 1 Welcome", " Advanced R Companion R4DS Reading Group 2020-08-07 Chapter 1 Welcome A companion to Advanced R and supplement to Advanced R Solutions Recordings for the accompanied presentation for each chapter can be seen here. This box means the supplied answer to the question is fuzzy and could use some work! We love PRs if you’d like to help with documentation! "],
["names-and-values.html", "Chapter 2 Names and Values 2.2 Binding basics 2.3 Copy-on-modify 2.2.2 Exercises 2.3.2 Function calls 2.3.3 Lists 2.3.5 Character vectors 2.3.6.2 Exercise 2.4.1 Object size 2.5.1 Modify-in-place", " Chapter 2 Names and Values 2.2 Binding basics Should we care about R internals? Guided by this blogpost, we can use the .Internal function to inspect metadata associated with our objects: x &lt;- list(1:5) .Internal(inspect(x)) # &gt; @0x000001b6a4af9fc8 19 VECSXP g0c1 [NAM(7)] (len=1, tl=0) # &gt; @0x000001b6a3321d90 13 INTSXP g0c0 [NAM(7)] 1 : 5 (compact) @0x000001b6a4af9fc8 – address (memory location) 19 VECSXP – type (full list here) g0 – garbage collector info token c1 – size of object (small vector) NAM(7) – named value of the object (if greater than one copy on modify) len=1 – length of object tl – true length of object small snippet of the data { x &lt;- list(1:5) .Internal(inspect(x)) } # &lt; @0x000001b6a4b4a3a0 19 VECSXP g0c1 [NAM(1)] (len=1, tl=0) # &lt; @0x000001b6a3a814d0 13 INTSXP g0c0 [NAM(7)] 1 : 5 (compact) It is of note here that without curly brackets we have to use copy-on-modify, but within curly brackes we can use copy-in-place because NAM(1) 2.3 Copy-on-modify copy-on-modify vs copy-in-place: is one more preferable in certain situations? modify in place only happens when objects with a single binding get a special performance optimization and to environments. 2.2.2 Exercises Question 3 digs into the syntactically valid names created when using read.csv(), but what is the difference between quotation and backticks? If we create an example csv example2223 &lt;- tibble( `if` = c(1,2,3), `_1234` = c(4,5,6), `column 1` = c(7,8,9) ) write.csv(example2223, &quot;example2223.csv&quot;, row.names = FALSE) Import using adjusted column names to be syntactically valid: read.csv(file = &quot;example2223.csv&quot;,check.names = TRUE) ## if. X_1234 column.1 ## 1 1 4 7 ## 2 2 5 8 ## 3 3 6 9 Import using non-adjusted column names read.csv(file = &quot;example2223.csv&quot;, check.names = FALSE) ## if _1234 column 1 ## 1 1 4 7 ## 2 2 5 8 ## 3 3 6 9 Import using the tidyverse where names are not adjusted df_non_syntactic_name &lt;- read_csv(file = &quot;example2223.csv&quot;) ## Parsed with column specification: ## cols( ## `if` = col_double(), ## `_1234` = col_double(), ## `column 1` = col_double() ## ) However I really don´t understand the difference between backticks and quotation marks. For example when I select a column in the case of non-syntactic in the tidyverse I can use quotation marks or backticks df_non_syntactic_name %&gt;% select(&quot;if&quot;) ## # A tibble: 3 x 1 ## `if` ## &lt;dbl&gt; ## 1 1 ## 2 2 ## 3 3 df_non_syntactic_name %&gt;% select(`if`) But in base R, I can do this with quotation marks, but not backticks: df__non_syntactic_name[&quot;if&quot;] Error in `[.default`(df__non_syntactic_name, `if`) : invalid subscript type &#39;special&#39; According to ?Quotes backticks are used for “non-standard variable names” but why in base R they don´t work to select columns but in the tidyverse they work to select variables? The easiest way to think about this is that backticks refer to objects while quotation marks refer to strings. dplyr::select() accepts object references as well as string references, while base R subsetting is done with a string or integer position. 2.3.2 Function calls Can we go over and break down figure in 2.3.2 When you create this function: crazyfunction &lt;- function(eh) {eh} eh doesn’t exist in memory at this point. x &lt;- c(1,2,3) x exists in memory. z &lt;- crazyfunction(x) z now points at x, and eh still doesn’t exist (except metaphorically in Canada). eh was created and exists WHILE crazyfunction() was being run, but doesn’t get saved to the global environment, so after the function is run you can’t see its memory reference. The round brackets (eh) list the arguments, the curly brackets {eh} define the operation that it’s doing - and you’re assigning it to crazyfunction. R functions automatically return the result of the last expression so when you call that object (the argument eh) it returns the value of that argument. This is called implicit returns 2.3.3 Lists Checking the address for a list and its copy we see they share the same references: l1 &lt;- list(1,2,3) l2 &lt;- l1 identical(lobstr::ref(l1),lobstr::ref(l2)) ## [1] TRUE lobstr::obj_addr(l1[[1]]) ## [1] &quot;0x7fb00e0459d8&quot; lobstr::obj_addr(l2[[1]]) ## [1] &quot;0x7fb00e0459d8&quot; But why isn’t this the case for their subsets? Using obj_addr they have different addresses, but when we look at their references they are the same lobstr::obj_addr(l1[1]) ## [1] &quot;0x7fb00cca94f0&quot; lobstr::ref(l1[1]) ## █ [1:0x7fb00ccc1488] &lt;list&gt; ## └─[2:0x7fb00e0459d8] &lt;dbl&gt; lobstr::obj_addr(l2[1]) ## [1] &quot;0x7fb00dbfc978&quot; identical(lobstr::obj_addr(l1[1]), lobstr::obj_addr(l2[1])) ## [1] FALSE This is because using singular brackets wraps the value 1 in a new list that is created on the fly which will have a unique address. We can use double brackets to confirm our mental model that the sublists are also identical: identical(lobstr::obj_addr(l1[[1]]), lobstr::obj_addr(l2[[1]])) ## [1] TRUE What’s the difference between these 2 addresses &lt;0x55d53fa975b8&gt; and 0x55d53fa975b8? Nothing - it has to do with the printing method: x &lt;- c(1, 2, 3) print(tracemem(x)) ## [1] &quot;&lt;0x7fb00e218cc8&gt;&quot; cat(tracemem(x)) ## &lt;0x7fb00e218cc8&gt; lobstr::obj_addr(x) ## [1] &quot;0x7fb00e218cc8&quot; When would you prefer a deep copy of a list to a shallow copy? Is this something to consider when writing functions or package development or is this more something that’s optimized behind the scenes? Automagical! 2.3.5 Character vectors Is there a way to clear the “global string pool”? According to this post it doesn’t look like you can directly, but clearing all references to a string that’s in the global string pool clears that string from the pool, eventually 2.3.6.2 Exercise When we look at tracemem when we modify x from an integer to numeric, x is assigned to three objects. The first is the integer, and the third numeric - so what’s the intermediate type? x &lt;- c(1L, 2L, 3L) obj_addr(x) tracemem(x) x[[3]] &lt;- 4 [1] &quot;0x7f84b7fe2c88&quot; [1] &quot;&lt;0x7f84b7fe2c88&gt;&quot; tracemem[0x7f84b7fe2c88 -&gt; 0x7f84b7fe5288]: tracemem[0x7f84b7fe5288 -&gt; 0x7f84bc0817c8]: What is 0x7f84b7fe5288 when the intermediate x &lt;- c(1L, 2L, 4) is impossible? When we assign the new value as an integer there is no intermediate step. This probably means c(1,2, NA) is the intermediate step; creating an intermediate vector that’s the same length of the final product with NA values at all locations that are new or to be changed x &lt;- c(1L, 2L, 3L) obj_addr(x) ## [1] &quot;0x7fb00de04d48&quot; tracemem(x) ## [1] &quot;&lt;0x7fb00de04d48&gt;&quot; x[[3]] &lt;- 4L ## tracemem[0x7fb00de04d48 -&gt; 0x7fb00cccbf88]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; do.call eval eval eval eval eval.parent local You can dig into the C code running this: pryr::show_c_source(.Internal(&quot;[&lt;-&quot;)) 2.4.1 Object size If I have two vectors, one 1:10 and another c(1:10, 10), intuitively, I would expect the size of the second vector to be greater than the size of the first. However, it seems to be the other way round, why? x1 &lt;- 1:10 x2 &lt;- rep(1:10, 10) lobstr::obj_size(x1) ## 680 B lobstr::obj_size(x2) ## 448 B If we start with the following three vectors: x1 &lt;- c(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L) x2 &lt;- 1:10 x3 &lt;- rep(1:10, 10) lobstr::obj_sizes(x1, x2, x3) ## * 96 B ## * 680 B ## * 448 B Intuitively, we would have expected x1 &lt; x2 &lt; x3 but this is not the case. It appears that the rep() function coerces a double into integer and hence optimizes on space. Using :, R internally uses ALTREP. ALTREP would actually be more efficient if the numbers represented were significantly large, say 1e7. x4 &lt;- 1:1e7 x5 &lt;- x4 x5[1] &lt;- 1L lobstr::obj_sizes(x4, x5) ## * 680 B ## * 40,000,048 B Now, the size of x4 is significantly lower than that of x5 . This seems to indicate that ALTREP becomes super efficient as the vector size is increased. 2.5.1 Modify-in-place “When it comes to bindings, R can currently only count 0, 1, or many. That means that if an object has two bindings, and one goes away, the reference count does not go back to 1: one less than many is still many. In turn, this means that R will make copies when it sometimes doesn’t need to.” Can we come up with an example of this? It seems really theoretical right now. First you need to switch your Environment tab to something other than global in RStudio! Now we can create a vector: v &lt;- c(1, 2, 3) (old_address &lt;- lobstr::obj_addr(v)) ## [1] &quot;0x7fb00e1c5c18&quot; Changing a value within it changes its address: v[[3]] &lt;- 4 (new_address &lt;- lobstr::obj_addr(v)) ## [1] &quot;0x7fb00e08cd78&quot; old_address == new_address ## [1] FALSE We can assign the modified vector to a new name, where y and v point to the same thing. y &lt;- v (y_address &lt;- lobstr::obj_addr(y)) ## [1] &quot;0x7fb00e08cd78&quot; (v_address &lt;- lobstr::obj_addr(v)) ## [1] &quot;0x7fb00e08cd78&quot; y_address == v_address ## [1] TRUE Now if we modify v it won’t point to the same thing as y: v[[3]] &lt;- 3 (y_address &lt;- lobstr::obj_addr(y)) ## [1] &quot;0x7fb00e08cd78&quot; (v_address &lt;- lobstr::obj_addr(v)) ## [1] &quot;0x7fb00e0fee88&quot; y_address == v_address ## [1] FALSE But if we now change y to look like v, the original address, in theory editing y should occur in place, but it doesn’t - the “count does not go back to one”! y[[3]] &lt;- 3 (new_y_address &lt;- lobstr::obj_addr(y)) ## [1] &quot;0x7fb00e16e758&quot; new_y_address == y_address ## [1] FALSE Can we break down this code a bit more? I’d like to really understand when and how it’s copying three times. As of R 4.0 it’s now copied twice, the 3rd copy that’s external to the function is now eliminated!! # dataframe of 5 columns of numbers x &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5)) # median number for each column medians &lt;- vapply(x, median, numeric(1)) # subtract the median of each column from each value in the column for (i in seq_along(medians)) { x[[i]] &lt;- x[[i]] - medians[[i]] } cat(tracemem(x), &quot;\\n&quot;) &lt;0x7fdc99a6f9a8&gt; for (i in 1:5) { x[[i]] &lt;- x[[i]] - medians[[i]] } tracemem[0x7fdc99a6f9a8 -&gt; 0x7fdc9de83e38]: tracemem[0x7fdc9de83e38 -&gt; 0x7fdc9de83ea8]: [[&lt;-.data.frame [[&lt;- tracemem[0x7fdc9de83ea8 -&gt; 0x7fdc9de83f18]: [[&lt;-.data.frame [[&lt;- tracemem[0x7fdc9de83f18 -&gt; 0x7fdc9de83f88]: tracemem[0x7fdc9de83f88 -&gt; 0x7fdc9de83ff8]: [[&lt;-.data.frame [[&lt;- tracemem[0x7fdc9de83ff8 -&gt; 0x7fdc9de84068]: [[&lt;-.data.frame [[&lt;- tracemem[0x7fdc9de84068 -&gt; 0x7fdc9de840d8]: tracemem[0x7fdc9de840d8 -&gt; 0x7fdc9de84148]: [[&lt;-.data.frame [[&lt;- tracemem[0x7fdc9de84148 -&gt; 0x7fdc9de841b8]: [[&lt;-.data.frame [[&lt;- tracemem[0x7fdc9de841b8 -&gt; 0x7fdc9de84228]: tracemem[0x7fdc9de84228 -&gt; 0x7fdc9de84298]: [[&lt;-.data.frame [[&lt;- tracemem[0x7fdc9de84298 -&gt; 0x7fdc9de84308]: [[&lt;-.data.frame [[&lt;- tracemem[0x7fdc9de84308 -&gt; 0x7fdc9de84378]: tracemem[0x7fdc9de84378 -&gt; 0x7fdc9de843e8]: [[&lt;-.data.frame [[&lt;- tracemem[0x7fdc9de843e8 -&gt; 0x7fdc9de84458]: [[&lt;-.data.frame [[&lt;- When we run tracemem on the for loop above we see each column is copied twice followed by the [[&lt;-.data.frame [[&lt;-, the stack trace showing exactly where the duplication occurred. So what is [[&lt;-.data.frame? It’s a function! By looking at `?[[&lt;-.data.frame we see this is used to “extract or replace subsets of data frames.” When we write x[[i]] &lt;- value, it’s really shorthand for calling the function [[&lt;-.data.frame with inputs x, i, and value. Now let’s step into the call of this base function by running debug(``[[&lt;-.data.frame``): debug(`[[&lt;-.data.frame`) and once inside, use tracemem() to find where the new values are assigned to the column: function (x, i, j, value) { if (!all(names(sys.call()) %in% c(&quot;&quot;, &quot;value&quot;))) warning(&quot;named arguments are discouraged&quot;) cl &lt;- oldClass(x) # this is where another copy of x is made! class(x) &lt;- NULL # tracemem[0x7fdc9d852a18 -&gt; 0x7fdc9c99cc08]: nrows &lt;- .row_names_info(x, 2L) if (is.atomic(value) &amp;&amp; !is.null(names(value))) names(value) &lt;- NULL if (nargs() &lt; 4L) { nc &lt;- length(x) if (!is.null(value)) { N &lt;- NROW(value) if (N &gt; nrows) stop(sprintf(ngettext(N, &quot;replacement has %d row, data has %d&quot;, &quot;replacement has %d rows, data has %d&quot;), N, nrows), domain = NA) if (N &lt; nrows) if (N &gt; 0L &amp;&amp; (nrows%%N == 0L) &amp;&amp; length(dim(value)) &lt;= 1L) value &lt;- rep(value, length.out = nrows) else stop(sprintf(ngettext(N, &quot;replacement has %d row, data has %d&quot;, &quot;replacement has %d rows, data has %d&quot;), N, nrows), domain = NA) } x[[i]] &lt;- value if (length(x) &gt; nc) { nc &lt;- length(x) if (names(x)[nc] == &quot;&quot;) names(x)[nc] &lt;- paste0(&quot;V&quot;, nc) names(x) &lt;- make.unique(names(x)) } class(x) &lt;- cl return(x) } if (missing(i) || missing(j)) stop(&quot;only valid calls are x[[j]] &lt;- value or x[[i,j]] &lt;- value&quot;) rows &lt;- attr(x, &quot;row.names&quot;) nvars &lt;- length(x) if (n &lt;- is.character(i)) { ii &lt;- match(i, rows) n &lt;- sum(new.rows &lt;- is.na(ii)) if (n &gt; 0L) { ii[new.rows] &lt;- seq.int(from = nrows + 1L, length.out = n) new.rows &lt;- i[new.rows] } i &lt;- ii } if (all(i &gt;= 0L) &amp;&amp; (nn &lt;- max(i)) &gt; nrows) { if (n == 0L) { nrr &lt;- (nrows + 1L):nn if (inherits(value, &quot;data.frame&quot;) &amp;&amp; (dim(value)[1L]) &gt;= length(nrr)) { new.rows &lt;- attr(value, &quot;row.names&quot;)[seq_len(nrr)] repl &lt;- duplicated(new.rows) | match(new.rows, rows, 0L) if (any(repl)) new.rows[repl] &lt;- nrr[repl] } else new.rows &lt;- nrr } x &lt;- xpdrows.data.frame(x, rows, new.rows) rows &lt;- attr(x, &quot;row.names&quot;) nrows &lt;- length(rows) } iseq &lt;- seq_len(nrows)[i] if (anyNA(iseq)) stop(&quot;non-existent rows not allowed&quot;) if (is.character(j)) { if (&quot;&quot; %in% j) stop(&quot;column name \\&quot;\\&quot; cannot match any column&quot;) jseq &lt;- match(j, names(x)) if (anyNA(jseq)) stop(gettextf(&quot;replacing element in non-existent column: %s&quot;, j[is.na(jseq)]), domain = NA) } else if (is.logical(j) || min(j) &lt; 0L) jseq &lt;- seq_along(x)[j] else { jseq &lt;- j if (max(jseq) &gt; nvars) stop(gettextf(&quot;replacing element in non-existent column: %s&quot;, jseq[jseq &gt; nvars]), domain = NA) } if (length(iseq) &gt; 1L || length(jseq) &gt; 1L) stop(&quot;only a single element should be replaced&quot;) x[[jseq]][[iseq]] &lt;- value # here is where x is copied again! class(x) &lt;- cl # tracemem[0x7fdc992ae9d8 -&gt; 0x7fdc9be55258]: x } Thus seeing exactly where the three as of R 4.0: two! copies are happening. "],
["vectors.html", "Chapter 3 Vectors 3.2.1 Scalars 3.2.3 Missing values 3.2.4 Testing and coercion 3.3.1 Setting Attributes 3.3.2 setNames 3.3.3 Dimensions 3.4 S3 atomic vectors 3.4.2 Dates 3.5.1 Lists 3.6.8 Data frames and tibbles Conclusion", " Chapter 3 Vectors 3.2.1 Scalars Can you have NA in vector Hell yeah! 3.2.3 Missing values NA is a ‘sentinel’ value for explicit missingness - what does ‘sentinel’ mean? A sentinel value (also referred to as a flag value, trip value, rogue value, signal value, or dummy data) is a special value in the context of an algorithm which uses its presence as a condition of termination. Also worth noting two NAs are not equal to each other! For instance, in C++ there’s a special character to identify the end of a string I think another example of a sentinel value might be in surveys where you sometimes see missing data or N/A coded as 999, or 9999 (or maybe just 9) Another example of a sentinel value might be in surveys where you sometimes see missing data or N/A coded as 999, or 9999 (or maybe just 9). The possible values in a column of data might be: factor(c(1,1,1,1,2,3,3,4,4,9), levels = c(1,2,3,4,9)) Sentinels are typically employed in situations where it’s easier/preferable to have a collection of values of the same type - represented internally using the same conventions and requiring the same amount of memory - but you also need a way to indicate a special circumstance. So like in the case of survey data you may, for example, see a variable indicating that an individual is 999 years old but the correct way to interpret that is that the data was not collected. 3.2.4 Testing and coercion Why does the book warn us against using is.vector(), is.atomic() and is.numeric()? [read docs] is.atomic will also return true if NULL is.numeric tests if integer or double NOT factor, Date, POSIXt, difftime is.vector will return false if it has attributes other than names 3.3.1 Setting Attributes Working in the medical field I have to import SAS files a lot where the column names have to adhere to specific abbreviations so they’re given a label attribute for their full name. What are some other common uses for attributes? Hypothesis test attributes! 3.3.2 setNames We can use setNames to apply different values to each element in a vector. How do we do this for our own custom attribute? The code below does NOT work! my_vector &lt;- c( structure(1, x = &quot;firstatt_1&quot;), structure(2, x = &quot;firstatt_2&quot;), structure(3, x = &quot;firstatt_3&quot;) ) my_vector &lt;- setNames(my_vector, c(&quot;name_1&quot;, &quot;name_2&quot;, &quot;name_3&quot;)) # mental model: shouldn&#39;t this should return $names and $x? attributes(my_vector) ## $names ## [1] &quot;name_1&quot; &quot;name_2&quot; &quot;name_3&quot; As soon as you instantiate a vector the attributes are lost. BUT we can store it as a list within the vector to keep them! We can create a custom attribute function and use that with map to add a list inside our dataframe: custom_attr &lt;- function(x, my_attr) { attr(x, &quot;x&quot;) &lt;- my_attr return(x) } as_tb &lt;- tibble( one = c(1,2,3), x = c(&quot;att_1&quot;, &quot;att_2&quot;, &quot;att_3&quot;), with_arr = map2(one, x, ~custom_attr(.x, .y)) ) as_tb$with_arr ## [[1]] ## [1] 1 ## attr(,&quot;x&quot;) ## [1] &quot;att_1&quot; ## ## [[2]] ## [1] 2 ## attr(,&quot;x&quot;) ## [1] &quot;att_2&quot; ## ## [[3]] ## [1] 3 ## attr(,&quot;x&quot;) ## [1] &quot;att_3&quot; 3.3.3 Dimensions Because NROW and NCOL don’t return NULL on a one dimensional vector they just seem to me as a more flexible option. When do you have to use ncol and nrow? It may be better practice to always use NROW and NCOL! As long as the number of rows matches the data frame, it’s also possible to have a matrix or array as a column of a data frame. (This requires a slight extension to our definition of a data frame: it’s not the length() of each column that must be equal, but the NROW().) df &lt;- data.frame(x = c(1,2,3,4,5), y = c(letters[1:5])) length(df$y) == NROW(df$y) ## [1] TRUE What’s an example of where length() != NROW() The case of a matrix! my_matrix &lt;- 1:6 dim(my_matrix) &lt;- c(3,2) my_matrix ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 length(my_matrix) == NROW(my_matrix) # 6 != 3 ## [1] FALSE length(my_matrix) == NCOL(my_matrix) # 6 != 2 ## [1] FALSE The length of the matrix is 6, and if we manipulate the dimensions of the matrix we see that the NROW is 3 and and NCOL is 2. 3.4 S3 atomic vectors How is data type typeof() different from class()? Classes are built on top of base types - they’re like special, more specific kinds of types. In fact, if a class isn’t specified then class() will default to either the implicit class or typeof. So Date, POSIXct, and difftime are specific kinds of doubles, falling under its umbrella. lubridate::is.Date(Sys.Date()) ## [1] TRUE is.double(Sys.Date()) ## [1] TRUE lubridate::is.POSIXct(Sys.time()) ## [1] TRUE is.double(Sys.time()) ## [1] TRUE lubridate::is.difftime(as.difftime(c(&quot;0:3:20&quot;, &quot;11:23:15&quot;))) ## [1] TRUE is.double(as.difftime(c(&quot;0:3:20&quot;, &quot;11:23:15&quot;))) ## [1] TRUE But then why does my_factor fail to be recognized under its more general integer umbrella? my_factor &lt;- factor(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) is.factor(my_factor) ## [1] TRUE is.integer(my_factor) ## [1] FALSE XXX 3.4.2 Dates Why are dates calculated from January 1st, 1970? Unix counts time in seconds since its official “birthday,” – called “epoch” in computing terms – which is Jan. 1, 1970. This article explains that the early Unix engineers picked that date arbitrarily, because they needed to set a uniform date for the start of time, and New Year’s Day, 1970, seemed most convenient. 3.5.1 Lists When should you be using list() instead of c() It’s really contingent on the use case. In the case of adding custom classes it’s worth noting that those are lost once you c() those objects together! 3.6.8 Data frames and tibbles What does ‘lazy’ mean in terms of as_tibble? Technically lazy evaluation means that expressions are not evaluated when they are bound to variables, but their evaluation is deferred until their results are needed by other computations. In this context though we think Hadley just meant that it’s treated as a character if it “looks and smells like a character”. The solution manual gives the answer and notes: df_coltypes &lt;- data.frame( a = c(&quot;a&quot;, &quot;b&quot;), b = c(TRUE, FALSE), c = c(1L, 0L), d = c(1.5, 2), e = c(&quot;one&quot; = 1, &quot;two&quot; = 2), g = factor(c(&quot;f1&quot;, &quot;f2&quot;)), stringsAsFactors = FALSE ) as.matrix(df_coltypes) ## a b c d e g ## one &quot;a&quot; &quot;TRUE&quot; &quot;1&quot; &quot;1.5&quot; &quot;1&quot; &quot;f1&quot; ## two &quot;b&quot; &quot;FALSE&quot; &quot;0&quot; &quot;2.0&quot; &quot;2&quot; &quot;f2&quot; “Note that format() is applied to the characters, which gives surprising results: TRUE is transformed to &quot; TRUE&quot; (starting with a space!).” …But where is the format() call happening? I don’t see a space! After running debug(as.matrix(df_coltypes)) and going down a rabbit hole we found this is a bug that has been addressed! See issue here Conclusion How does vectorization make your code faster Taking the example from Efficient R Programming: VECTORIZED: sum(log(x)) NON-VECTORIZED: s &lt;- 0 for(x0 in x) { s &lt;- s + log(x0) } The vectorized code is faster because it obeys the golden rule of R programming: “access the underlying C/Fortran routines as quickly as possible; the fewer functions calls required to achieve this, the better”. Vectorized Version: sum [called once] log [called once] Non-vectorized: + [called length(x) times] log [called length(x) times] In the vectorised version, there are two primitive function calls: one to log (which performs length(x) steps in the C level) and one to sum (which performs x updates in the C level). So you end up doing a similar number of operations at C level regardless of the route. In the non-vectorised form you are passing the logic back and forth between R and C many many times and this is why the non-vectorised form is much slower. A vectorized function calls primitives directly, but a loop calls each function length(x) times, and there are 1 + length(x) assignments to s. Theres on the order of 3x primitive function calls in the non-vectorised form!! Resources: Check out Jenny Brian’s slides Great article by Noam Ross Putting it all together in a single diagram: "],
["subsetting.html", "Chapter 4 Subsetting 4.1 Introduction 4.2.1 Selecting multiple elements 4.2.2 lists 4.3.1 [[ 4.3.5 Exercise 4.3.3 Missing and OOB 4.5.8 Logical subsetting 4.5.8 Boolean algebra", " Chapter 4 Subsetting 4.1 Introduction &quot;There are three subsetting operators [. [[, $. What is the distinction between an operator and a function? When you look up the help page it brings up the same page for all three extraction methods. What are their distinctions and do their definitions change based on what you’re subsetting? Can we make a table? [ [[ $ ATOMIC RETURNS VECTOR WITH ONE ELEMENT SAME AS [ NOPE! LIST RETURNS A LIST RETURNS SINGLE ELEMENT FROM WITHIN LIST RETURN SINGLE ELEMENT FROM LIST [CAN ONLY USE WHEN LIST VECTOR HAS A NAME] MATRIX RETURNS A VECTOR RETURNS A VECTOR OR SINGLE VALUE NOPE! DATA FRAME RETURNS A VECTOR OR DATA FRAME RETURNS VECTOR/LIST/MATRIX OR SINGLE VALUE RETURNS VECTOR/LIST/MATRIX USING COLUMN NAME TIBBLE RETURNS A TIBBLE RETURNS A VECTOR OR SINGLE VALUE RETURNS THE STR OF THE COLUMN - TIBBLE/LIST/MATRIX If we think of everything as sets (which have the properties of 0,1, or many elements), if the set has 1 element it only contains itself and NULL subsets. Before you subset using [ or [[ count the elements in the set. If it has zero elements you are done, if it has one element [ will return itself - to go further you need to use [[ to return its contents. If there is more than one element in the set then [ will return those elements. You can read more about subsetting here 4.2.1 Selecting multiple elements Why is numeric(0) “helpful for test data?” This is more of a general comment that one should make sure one’s code doesn’t crash with vectors of zero length (or data frames with zero rows) Why is subsetting with factors “not a good idea” Hadley’s notes seem to say subsetting with factors uses the “integer vector of levels” - and if they all have the same level, it’ll just return the first argument. Subsetting a factor vector leaves the factor levels behind unless you explicitly drop the unused levels 4.2.2 lists We’ve been talking about $ as a shorthand for [[. Using the example list x &lt;- list(1:3, &quot;a&quot;, 4:6) can we use x$1 as shorthand for x[[1]]? The “shorthand” refers to using the name of the vector to extract the vector. If we give 1:3 a name such as test = 1:3 x &lt;- list(named_vector = 1:3, &quot;a&quot;, 4:6) x[[1]] == x$named_vector ## [1] TRUE TRUE TRUE As such, $ is a shorthand for x[[&quot;name_of_vector&quot;]] and not shorthand for x[[index]] 4.3.1 [[ The book states: While you must use [[ when working with lists, I’d also recommend using it with atomic vectors whenever you want to extract a single value. For example, instead of writing: for (i in 2:length(x)) { out[i] &lt;- fun(x[i], out[i - 1]) } It’s better to write for (i in 2:length(x)) { out[[i]] &lt;- fun(x[[i]], out[[i - 1]]) } Why? Can we see this in action by giving x, out, and fun real life values? If we have a vector df_x &lt;- c(&quot;Advanced&quot;,&quot;R&quot;,&quot;Book&quot;,&quot;Club&quot;) We can use [ or [[ to extract the third element of df_x df_x[3] ## [1] &quot;Book&quot; df_x[[3]] ## [1] &quot;Book&quot; But in the case where we want to extract an element from a list [ and [[ no longer give us the same results df_x &lt;- list(A = &quot;Advanced&quot;, B = &quot;R&quot;, C = &quot;Book&quot;, D = &quot;Club&quot;) df_x[3] ## $C ## [1] &quot;Book&quot; df_x[[3]] ## [1] &quot;Book&quot; Because using [[ returns “one element of this vector” in both cases, it makes sense to default to [[ instead of [ since it will reliably return a single element. 4.3.5 Exercise The question asks to describe the upper.tri function - let’s dig into it! x &lt;- outer(1:5, 1:5, FUN = &quot;*&quot;) upper.tri(x) ## [,1] [,2] [,3] [,4] [,5] ## [1,] FALSE TRUE TRUE TRUE TRUE ## [2,] FALSE FALSE TRUE TRUE TRUE ## [3,] FALSE FALSE FALSE TRUE TRUE ## [4,] FALSE FALSE FALSE FALSE TRUE ## [5,] FALSE FALSE FALSE FALSE FALSE We see that it returns the upper triangle of the matrix. But I wanted to walk through how this function actually works and what is meant in the solution manual by leveraging .row(dim(x)) &lt;= .col(dim(x)). # ?upper.tri function (x, diag = FALSE) { d &lt;- dim(x) # if you have an array thats more than 2 dimension # we need to flatten it to a matrix if (length(d) != 2L) d &lt;- dim(as.matrix(x)) if (diag) # this is our subsetting logical! .row(d) &lt;= .col(d) else .row(d) &lt; .col(d) } The function .row() and .col() return a matrix of integers indicating their row number .row(dim(x)) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 1 1 1 1 ## [2,] 2 2 2 2 2 ## [3,] 3 3 3 3 3 ## [4,] 4 4 4 4 4 ## [5,] 5 5 5 5 5 .col(dim(x)) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 1 2 3 4 5 ## [3,] 1 2 3 4 5 ## [4,] 1 2 3 4 5 ## [5,] 1 2 3 4 5 .row(dim(x)) &lt;= .col(dim(x)) ## [,1] [,2] [,3] [,4] [,5] ## [1,] TRUE TRUE TRUE TRUE TRUE ## [2,] FALSE TRUE TRUE TRUE TRUE ## [3,] FALSE FALSE TRUE TRUE TRUE ## [4,] FALSE FALSE FALSE TRUE TRUE ## [5,] FALSE FALSE FALSE FALSE TRUE Is there a high level meaning to a . before function? Does this refer to internal functions? [see: ?row vs ?.row] Objects in the global environment prefixed with . are hidden in the R (and RStudio) environment panes - so functions prefixed as such are not visible unless you do ls(all=TRUE). Read more here and (here)[https://stackoverflow.com/questions/7526467/what-does-the-dot-mean-in-r-personal-preference-naming-convention-or-more] 4.3.3 Missing and OOB Let’s walk through examples of each LOGICAL ATOMIC c(TRUE, FALSE)[[0]] # zero length # attempt to select less than one element in get1index &lt;real&gt; c(TRUE, FALSE)[[4]] # out of bounds # subscript out of bounds c(TRUE, FALSE)[[NA]] # missing # subscript out of bounds LIST list(1:3, NULL)[[0]] # zero length # attempt to select less than one element in get1index &lt;real&gt; list(1:3, NULL)[[3]] # out of bounds # subscript out of bounds list(1:3, NULL)[[NA]] # missing # NULL NULL NULL[[0]] # zero length # NULL NULL[[1]] # out of bounds # NULL NULL[[NA]] # missing # NULL 4.5.8 Logical subsetting “Remember to use the vector Boolean operators &amp; and |, not the short-circuiting scalar operators &amp;&amp; and ||, which are more useful inside if statements.” Can we go over the difference between &amp; and &amp;&amp; (and | vs ||) I use brute force to figure out which ones I need… &amp;&amp; and || only ever return a single (scalar, length-1 vector) TRUE or FALSE value, whereas | and &amp; return a vector after doing element-by-element comparisons. The only place in R you routinely use a scalar TRUE/FALSE value is in the conditional of an if statement, so you’ll often see &amp;&amp; or || used in idioms like: if (length(x) &gt; 0 &amp;&amp; any(is.na(x))) { do.something() } In most other instances you’ll be working with vectors and use &amp; and | instead. Using &amp;&amp; or || results in some unexpected behavior - which could be a big performance gain in some cases: || will not evaluate the second argument when the first is TRUE &amp;&amp; will not evaluate the second argument when the first is FALSE true_one &lt;- function() { print(&quot;true_one evaluated.&quot;); TRUE} true_two &lt;- function() { print(&quot;true_two evaluated.&quot;); TRUE} # arguments are evaluated lazily. Unexpected behavior can result: c(T, true_one()) &amp;&amp; c(T, true_two()) ## [1] &quot;true_one evaluated.&quot; ## [1] &quot;true_two evaluated.&quot; ## [1] TRUE c(T, true_one()) &amp;&amp; c(F, true_two()) ## [1] &quot;true_one evaluated.&quot; ## [1] &quot;true_two evaluated.&quot; ## [1] FALSE c(F, true_one()) &amp;&amp; c(T, true_two()) ## [1] &quot;true_one evaluated.&quot; ## [1] FALSE c(F, true_one()) &amp;&amp; c(F, true_two()) ## [1] &quot;true_one evaluated.&quot; ## [1] FALSE c(T, true_one()) || c(T, true_two()) ## [1] &quot;true_one evaluated.&quot; ## [1] TRUE c(T, true_one()) || c(F, true_two()) ## [1] &quot;true_one evaluated.&quot; ## [1] TRUE c(F, true_one()) || c(T, true_two()) ## [1] &quot;true_one evaluated.&quot; ## [1] &quot;true_two evaluated.&quot; ## [1] TRUE c(F, true_one()) || c(F, true_two()) ## [1] &quot;true_one evaluated.&quot; ## [1] &quot;true_two evaluated.&quot; ## [1] FALSE Read more about Special Primatives here 4.5.8 Boolean algebra The unwhich() function takes a boolean and turns it into a numeric - would this ever be useful? How? XXX “x[-which(y)] is not equivalent to x[!y]: if y is all FALSE, which(y) will be integer(0) and -integer(0) is still integer(0), so you’ll get no values, instead of all values.” Can we come up with an example for this plugging in values for x and y c(TRUE, FALSE)[-which(FALSE)] ## logical(0) c(TRUE, FALSE)[!FALSE] ## [1] TRUE FALSE "],
["control-flow.html", "Chapter 5 Control Flow 5.2.2 Vectorised if 5.3 Loops 5.2.3 switch statement 5.3.1 common pitfalls 5.3.3.1 Exercises Conclusion Complexity", " Chapter 5 Control Flow 5.2.2 Vectorised if Why does if else print &quot;Out of range&quot; once but ifelse prints it twice? if (sample(1:10, 1) == 1) print(&quot;In range&quot;) else print(&quot;Out of range&quot;) [1] &quot;Out of range&quot; ifelse((sample(1:10, 1) == 1), print(&quot;In range&quot;), print(&quot;Out of range&quot;)) [1] &quot;Out of range&quot; [1] &quot;Out of range&quot; var &lt;- if (sample(1:10, 1) == 1) print(&quot;In range&quot;) var NULL var &lt;- ifelse((sample(1:10, 1) == 1), print(&quot;In range&quot;), print(&quot;Out of range&quot;)) ## [1] &quot;Out of range&quot; var ## [1] &quot;Out of range&quot; ifelse explicitly returns its result, whereas if invisibly returns it! ifelse(c(TRUE, FALSE, TRUE), 1:2, 3) ## [1] 1 3 1 Honestly, ifelse() is weird. Try this too: ifelse(c(TRUE, FALSE, TRUE), 1:10, 3) ## [1] 1 3 3 5.3 Loops Can the body of the loop change the set? my_set &lt;- c(1, 20, 99) for (i in my_set){ if (i==1){ my_set[9]= 20 } print(&quot;hello&quot;) print(my_set) } ## [1] &quot;hello&quot; ## [1] 1 20 99 NA NA NA NA NA 20 ## [1] &quot;hello&quot; ## [1] 1 20 99 NA NA NA NA NA 20 ## [1] &quot;hello&quot; ## [1] 1 20 99 NA NA NA NA NA 20 Looks like you can’t! 5.2.3 switch statement “Closely related to if is the switch() statement. It’s a compact, special purpose equivalent” What is meant here by “special purpose”? Can we come up with a case where you can’t substitute if for switch or the other way around? Use switch. Is it safe to say to switch when you have character inputs (as the book suggests) and use case_when or if for numerics? Switch is special in that only ONE value can be true, as in the case from our presentation the shiny input can only ever be ONE of the strings on the left it cannot be multiple. datasetInput &lt;- reactive({ switch(input$dataset, &quot;materials&quot; = brewing_materials, &quot;size&quot; = brewer_size, &quot;states&quot; = beer_states, &quot;taxed&quot; = beer_taxed) }) 5.3.1 common pitfalls What does the book mean by leveraging vector for preallocating the loop output? How is this different from creating an empty list to instantiate the loop? means &lt;- c(1, 50, 20) out_vector &lt;- vector(&quot;list&quot;, length(means)) for (i in 1:length(means)) { out_vector[[i]] &lt;- rnorm(10, means[[i]]) } out_list &lt;- list() for (i in 1:length(means)) { out_list[[i]] &lt;- rnorm(10, means[[i]]) } By preallocating the length of the out_vector we’re leveraging modify-in-place rather than copy-on-modify. The book warns against using length(x) and suggests using seq_along instead. Is there any downside to using seq_along or a case when you’d prefer length(x) over seq_along(x)? I can’t think of any downsides to using it! We have yet to find a downside but should look into this further! 5.3.3.1 Exercises x &lt;- numeric() out &lt;- vector(&quot;list&quot;, length(x)) for (i in 1:length(x)) { out[i] &lt;- x[i] ^ 2 } out ## [[1]] ## [1] NA I understand that this works because we can count down in a loop - so the first iteration x[1] == NA, and the second x[2] == numeric(0) but where does this value go? Is it just evaluated but not stored since R counts from 1? This question is actually the bigger question, “Can you assign something to index 0 in R?” and it doesn’t seem that you can. Assignment to a valid index mylist = list() mylist[1] &lt;- c(&quot;something&quot;) mylist[1] ## [[1]] ## [1] &quot;something&quot; Assignment to [0] mylist = list() mylist[0] &lt;- c(&quot;something&quot;) mylist[0] ## list() It’s interesting that it’s syntactically correct to assign to mylist[0] but it does nothing! Empty index mylist = list() mylist[1] ## [[1]] ## NULL R defaultly accesses the first layer using [ and says there are no elements in the first layer of mylist and returns NULL. But when you do mylist[[1]] R says Out of Bounds because the first layer of mylist has been called and there is no layer at all. That’s why R throws error in [[ case. Impossible Index [[ mylist = list() mylist[[0]] Error in mylist[[0]] : attempt to select less than one element in get1index &lt;real&gt; [[ isolates one element whereas [ can be used to get subsets of varying sizes. [[ gets precisely one element, no more no less, or it fails. So [[0]]&lt;- cannot work because index zero cannot hold a value. Impossible Index [[&lt;- mylist = list() mylist[[0]] &lt;- &quot;something&quot; Error in mylist[[0]] &lt;- &quot;something&quot; : attempt to select less than one element in integerOneIndex Undefined name Selection using an undefined - but possible name - gives NULL mylist = list() mylist[[&quot;undefined_name&quot;]] Out of Bounds Selection using a possible - but not currently allocated - index gives an out of bounds error mylist = list() mylist[[10]] Error in mylist[[10]] : subscript out of bounds Conclusion Can we put these concepts together in diagram form? Let’s work on improving these schematics! Let’s first put functions into words: If condition then run code, else quit A vectorized version of: if condition then run code, else run other code For every element in list of elements do what is in between the curly braces While this condition is true do this Repeat this until something tells you to break out We can visualize how the ifelse logic on a single element above will operate on each element within a vector: For instance if we can run: ifelse(c(TRUE, FALSE, TRUE), 1:2, 3) ## [1] 1 3 1 Lets break down what’s happening: Create a test answer: test &lt;- c(TRUE, FALSE, TRUE) yes &lt;- 1:2 no &lt;- 3 which indices in the test are TRUE and which are FALSE yes_idx &lt;- which(test) # 1,3 no_idx &lt;- which(!test) # 2 set up our answer answer &lt;- test # T, F, T grow the yes and no answers to the length of the test (input) yes_final &lt;- rep(yes, length.out = length(test)) no_final &lt;- rep(no, length.out = length(test)) fill the answer with yes or no from the enlarged yes/no answers answer[yes_idx] &lt;- yes_final[yes_idx] # 1,1 answer[no_idx] &lt;- no_final[no_idx] # 3 return our final answer: answer ## [1] 1 3 1 Another example: we can run ifelse(c(TRUE, FALSE, TRUE, FALSE, TRUE, TRUE), 1:10, &quot;FALSE&quot;) ## [1] &quot;1&quot; &quot;FALSE&quot; &quot;3&quot; &quot;FALSE&quot; &quot;5&quot; &quot;6&quot; we can see that ifelse places the numbers in 1:10 based on their index where our condition is to TRUE and inserts the string &quot;FALSE&quot; whenever the condition is FALSE Complexity Cyclomatic complexity is a software metric used to indicate the complexity of a program. It is computed using the control flow graph of the program: the nodes of the graph correspond to indivisible groups of commands of a program, and a directed edge connects two nodes if the second command might be executed immediately after the first command. We can use the package cyclocomp to look at the cyclomatic complexity of functions. Looking at each function from the Chapter 5 presentation: controlflow_functions &lt;- list( if_func = if_func, if_else_func = if_else_func, ifelse_func = ifelse_func, casewhen_func = casewhen_func, switch_func = switch_func, for_func = for_func, while_func = while_func, repeat_func = repeat_func) purrr::map_df(controlflow_functions, cyclocomp) ## # A tibble: 1 x 8 ## if_func if_else_func ifelse_func casewhen_func switch_func for_func while_func ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2 2 1 1 1 23 3 ## # … with 1 more variable: repeat_func &lt;int&gt; We see that the for loop was our most complex function and while had a complexity of 3. The rest of our functions had a complexity of 1. As Colin Fay states: “Splitting a complex function into smaller functions is not a magic solution because (A) the global complexity of the app is not lowered by splitting things into pieces (just local complexity), and (B) the deeper the call stack, the harder it can be to debug.” "],
["functions.html", "Chapter 6 Functions 6.2.2 Primitives 6.2.5.1 Exercises 6.3 Function composition 6.4 Lexical scoping 6.4.3 A fresh start 6.5 Lazy evaluation 6.5.1 Promises 6.5.2 Default arguments 6.5.4.3 Exercise 6.5.4.4 Exercise 6.6 dot dot dot 6.6.1.2 Exercise 6.7.4 Exit handlers 6.7.5.4 Exercise 6.7.5.5 Exercise 6.8.4 Replacement functions 6.8.6.3 Exercise", " Chapter 6 Functions 6.2.2 Primitives So if you are familiar with C can you just write a function in C in R? What does that process look like? I think this is a bigger question of digging into the relationship between C and R. Primitives are part of R core, and can only be written by the R-core team. At its heart, R is the set of primitive C functions underneath it. You can use Rcpp to include C++ code in your R code, but these aren’t Primitives. There are also other techniques which we’ll likely see covered in later chapters. Here’s an example using Rcpp. Rcpp::cppFunction(&#39;#include&lt;string&gt; std::string IPA() { std::string val = &quot;IPAs suck&quot;; return val; }&#39;) val &lt;- IPA() val [1] &quot;IPAs suck&quot; Are there any non-base primitives? If so how is that possible! XXX 6.2.5.1 Exercises This question is flagged as “started” let’s try to complete it! Q: Given a name, like &quot;mean&quot;, match.fun() lets you find a function. Given a function, can you find its name? Why doesn’t that make sense in R? A: A name can only point to a single object, but an object can be pointed to by 0, 1, or many names. What are names of the functions in the following block? function(x) sd(x) / mean(x) ## function(x) sd(x) / mean(x) f1 &lt;- function(x) (x - min(x)) / (max(x) - min(x)) f2 &lt;- f1 f3 &lt;- f1 There isn’t a 1 to 1 mapping between functions and names in R. Multiple names may point to the same function as we see for f1, f2, and f3. Also, each function has its own environment so it’s possible that two functions might have the same “code” but are not the same because they have different environments (or closures). Lastly, anonymous functions don’t have names so we’d have no way to look these up. We could find the names of our functions if they are all in the global environment using body(x) == body(y) names(which(sapply(mget(lsf.str()), function(x) body(x) == body(function(x) (x - min(x)) / (max(x) - min(x)))))) [1] f1 f2 f3 But that’s just deparsing the body into a string and comparing the values. So if you want to think of two functions as being equal if their deparsed body strings as the same, then that’s technically possible but that is just like searching for every variable that has the value of 5 [possible but not efficient]. The main point is that name -&gt; object is a one way (non-unique) look up in R. There’s no efficient way to go backwards. This is true for all values, not just functions. 6.3 Function composition When comparing nested, intermediate, and piping functions, it looks like Hadley flips the order of f() and g() between bullet points It does look like he does that! f &lt;- function(z) { cat(&quot;g is:&quot;, z) } g &lt;- function(x) { x * 2 } 6.0.1 Nested f(g(2)) ## g is: 4 6.0.2 Intermediate This is written in the book as y &lt;- f(x); g(y) but should be flipped to y &lt;- g(x); f(y) if we are to follow the nested example y &lt;- g(2) f(y) ## g is: 4 6.0.3 Piping This also needs to be flipped from x %&gt;% f() %&gt;% g() to x %&gt;% g() %&gt;% f() 2 %&gt;% g() %&gt;% f() ## g is: 4 6.4 Lexical scoping “The scoping rules use a parse-time, rather than a run-time structure”? What is “parse-time” and “run-time”? How do they differ? parse-time is when the function gets defined: when the formals and body get set. run-time is when it actually gets called. This function doesn’t get past parse-time because of the syntax error get_state &lt;- function(in_df, state_name){ out_df % in_df[in_df$state == state_name, ] return(out_df) } get_state &lt;- function(in_df, state_name){ out_df % in_df[in_df$state == state_name, ] Error: unexpected input in: &quot;get_state &lt;- function(in_df, state_name){ out_df % in_df[in_df$state == state_name, ]&quot; return(out_df) Error: object &#39;out_df&#39; not found } Error: unexpected &#39;}&#39; in &quot;}&quot; This function will get parsed successfully but could fail at run at run-time if the input data frame doesn’t have a column named state: get_state &lt;- function(in_df, state_name){ out_df &lt;- in_df[in_df$state == state_name, ] return(out_df) } get_state(iris, &#39;setosa&#39;) ## [1] Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;0 rows&gt; (or 0-length row.names) At R’s build-time, if you want to run a function from a package that isn’t loaded it will not throw an error but at run-time it will if the required package is not loaded: func_1 &lt;- function(df, x) { select({{ df }}, {{ x }}) } test_tbl &lt;- tibble::tibble(x1 = runif(5), x2 = rnorm(5), x3 = rpois(5, lambda = 1)) Without dplyr this will fail func_1(test_tbl, x1) Error in select({: could not find function &quot;select&quot; This will work: library(dplyr) #&gt; #&gt; Attaching package: &#39;dplyr&#39; #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; filter, lag #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; intersect, setdiff, setequal, union func_1(test_tbl, x1) ## # A tibble: 5 x 1 ## x1 ## &lt;dbl&gt; ## 1 0.0291 ## 2 0.713 ## 3 0.831 ## 4 0.340 ## 5 0.484 6.4.3 A fresh start How would we change this code so that the second call of g11() is 2? g11 &lt;- function() { if (!exists(&quot;a&quot;)) { a &lt;- 1 } else { a &lt;- a + 1 } a } g11() ## [1] 1 g11 &lt;- function() { if (!exists(&quot;a&quot;)) { a &lt;- 1 } else { a &lt;- a + 1 } a &lt;&lt;- a a } g11() ## [1] 1 6.5 Lazy evaluation “This allows you to do things like include potentially expensive computations in function arguments that will only be evaluated if needed” Does anyone have an example of this? We discussed a function that will only perform expensive tasks given the context of the function perhaps? Maybe a situation where we can give a function default arguments where sampleis a stand in for longer expensive functions like different fancy modeling techniques? We can workshop this… mega_model &lt;- function(values, x = sample(1:100, 10), y = sample(200:300, 10), z = sample(300:400, 10) ) { dplyr::case_when( is.numeric(values) ~ x, is.character(values) ~ y, TRUE ~ z ) } mega_model(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## [1] 299 217 253 269 247 222 250 242 274 260 6.5.1 Promises Can we discuss the order that this happening in? Is it that Calculating... is printed, then x*2 then x*2 again? I am still reading this as: h03(double(20), double(20)) which is an incorrect mental model because the message is only printed once… double &lt;- function(x) { message(&quot;Calculating...&quot;) x * 2 } h03 &lt;- function(x) { c(x, x) } Explain what’s happeining here below in words, and restructure the promise image to make more sense double &lt;- function(y) { message(&quot;Calculating...&quot;) cat(&quot;double before\\n&quot;) print(pryr::promise_info(y)) force(y) cat(&quot;double after\\n&quot;) print(pryr::promise_info(y)) y * 2 } h03 &lt;- function(x) { cat(paste0(&quot;h03 before\\n&quot;)) print(pryr::promise_info(x)) force(x) cat(&quot;h03 after\\n&quot;) print(pryr::promise_info(x)) c(x, x) } double(h03(20)) ## Calculating... ## double before ## Registered S3 method overwritten by &#39;pryr&#39;: ## method from ## print.bytes Rcpp ## $code ## h03(20) ## ## $env ## &lt;environment: R_GlobalEnv&gt; ## ## $evaled ## [1] FALSE ## ## $value ## NULL ## ## h03 before ## $code ## [1] 20 ## ## $env ## &lt;environment: R_GlobalEnv&gt; ## ## $evaled ## [1] FALSE ## ## $value ## NULL ## ## h03 after ## $code ## [1] 20 ## ## $env ## NULL ## ## $evaled ## [1] TRUE ## ## $value ## [1] 20 ## ## double after ## $code ## h03(20) ## ## $env ## NULL ## ## $evaled ## [1] TRUE ## ## $value ## [1] 20 20 ## [1] 40 40 plop &lt;- function(a, b) a * 10 plop(2, var_doesnt_exist) ## [1] 20 var_doesnt_exist is a promise within g, we use the promises within g when we call f but f never uses its second argument so this runs without a problem. When would we want to leverage this behavior? The unevaluated var_doesnt_exist doesn’t exist , but we can use substitute to to get the expression out of a promise! If we modify our function we can play with the expression contained in b: plop &lt;- function(a, b) { cat(&quot;You entered&quot;, deparse(substitute(b)), &quot;as `b` \\n&quot;) a * 10 } plop(a = 2, b = var_doesnt_exist) ## You entered var_doesnt_exist as `b` ## [1] 20 We can even evaluate b and use it to create a dplyr like pull function: plop &lt;- function(a, b) { eval(substitute(b), envir = a) } plop(iris, Species)[1:10] ## [1] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa ## Levels: setosa versicolor virginica 6.5.2 Default arguments I don’t quite understand why x = ls() is different from ls() here; aren’t we still assigning x = ls() but without specifying x? h05 &lt;- function(x = ls()) { a &lt;- 1 x } # this makes sense to me h05() ## [1] &quot;a&quot; &quot;x&quot; # how is this different from above? h05(ls()) ## [1] &quot;a&quot; &quot;double&quot; &quot;f&quot; &quot;f1&quot; &quot;f2&quot; ## [6] &quot;f3&quot; &quot;func_1&quot; &quot;g&quot; &quot;g11&quot; &quot;get_state&quot; ## [11] &quot;h03&quot; &quot;h05&quot; &quot;mega_model&quot; &quot;plop&quot; &quot;test_tbl&quot; ## [16] &quot;y&quot; The difference is where the promise is created. ls() is always evaluated inside h05 when x is evaluated. The difference is the environment. When ls() is provided as an explicit parameter, x is a promise whose environment is the global environment. When ls() is a default parameter, it is evaluated in the local environment where it is used. Hypothesis: does nesting ls() in h05 first evaluate ls() then evaluate h05() ? library(magrittr) h05 &lt;- function(x = {y &lt;- 4;ls()}) { a &lt;- 1 x } h05() [1] &quot;a&quot; &quot;x&quot; &quot;y&quot; ls() [1] &quot;h05&quot; {y &lt;- 4;ls()} %&gt;% h05() [1] &quot;h05&quot; &quot;y&quot; ls() [1] &quot;h05&quot; &quot;y&quot; h05({x &lt;- 5;ls()}) [1] &quot;h05&quot; &quot;x&quot; &quot;y&quot; ls() [1] &quot;h05&quot; &quot;x&quot; &quot;y&quot; Notice in all of the latter calls, a is not returned - so it’s not evaluating ls() inside of the function. 6.5.4.3 Exercise I understand this problem is showing us an example of name masking (the function doesn’t need to use the y = 0 argument because it gets y from within the definition of x, but I’m fuzzy on what exactly the ; does. What does the syntax {y &lt;- 1; 2} mean? Could it be read as &quot;Set y &lt;- 1 and x &lt;- 2? y &lt;- 10 f1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) { c(x, y) } f1() ## [1] 2 1 The curly brackets are an expression, which can be read as { y &lt;- 1 2 } ## [1] 2 This is returning 2 and setting 1 to y. The colon can be read as a new line in the expression. x is called inside the function and overwrites the argument value of y f1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) { # At this point, neither x nor y have been needed or evaluated. This is &quot;lazy&quot;. cat(y) # &quot;Summon the current state of y&quot;. # R looks first in the function env - is there a y there? No # R then looks at the arguments - is there a y there? Yes, it&#39;s 0 -&gt; print out zero # If R had not found y in the arguments, then it would look in the parent environment of the function - the global env. # That&#39;s where it would find y = NULL - but since it already found a default arg, it already stopped evaluating. cat(x) # &quot;Summon the current state of x&quot; # x is an expression that first sets y to equal 1 and then returns the number 2 -&gt; print out 2 c(x, # &quot;Summon the current state of x&quot; - x is still the expression that sets y to 1 and then x to 2 y) # &quot;Summon the current state of y&quot; - y was set to 1, so y is 1 here. } f1() ## 02 ## [1] 2 1 Compare to: f1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) { c(y, # &quot;Summon the current state of y&quot; - y has not yet been set to anything else, so it returns zero x) # &quot;Summon the current state of x&quot; - x is still the expression that sets y to 1 and then x to 2 # However, y has already been returned - so even though y is now set to 1, it&#39;s called after the previous y and does not affect the previous y. } x = NULL y = NULL f1() ## [1] 0 2 What is happening here: - The default value of x is “assign 1 to y then return 2 implicitly.” - The default value of y is 0. - x and y aren’t their defaults until they’re referenced and there isn’t a value, so when you invoke the question x is the default, but y is never the default. - When you get to c(x, x is evaluated. Now the value of y is 1 instead of its default value! - When you get to c(x, y), y is now 1, so the return is 2 1 Using the original f1 function, if we write f1(x &lt;- 5) we get 5 0, When you make that call, the function’s x argument gets set to x &lt;- 5 (instead of the default). When you get to c(x, the x &lt;- 5 call gets evaluated in the calling environment (global, most likely, unless you’re calling it from inside a function or something). To see where x gets assigned, try this: f2 &lt;- function(x = {y &lt;- 1; 2}, y = 0) { # c(x, y) &quot;Nothing to see here.&quot; } f2(x &lt;- 5) ## [1] &quot;Nothing to see here.&quot; x ## Error: object &#39;x&#39; not found Since x is never used in this version, the x = {x &lt;- 5} promise never gets evaluated, so x never gets set in the calling environment. But if you do the same thing with f1, x is now 5 in the calling environment. Also note that calling the &lt;- function returns the value (the second argument) invisibly, so y &lt;- {x &lt;- 5} assigns 5 to both y and x. I wouldn’t recommend ever doing this on purpose, but it’s useful to know for debugging weird cases. A piece that ALMOST confused me was that the function’s default value only ever “exists” in the function’s environment, not in the calling environment, so the original case doesn’t change y to 1 globally. But f1({y &lt;- 1; 2}) WILL change y globally… but does not change the value of y inside the function. 6.5.4.4 Exercise I know this isn’t exactly needed to answer the question, but how do we access a function that has methods? For instance - here I want to dig into the hist function using hist hist ## function (x, ...) ## UseMethod(&quot;hist&quot;) ## &lt;bytecode: 0x7faed327d6d0&gt; ## &lt;environment: namespace:graphics&gt; does not give me the actual contents of the actual function…. We need to access is using hist.&lt;method&gt; hist.default 6.6 dot dot dot “(See also rlang::list2() to support splicing and to silently ignore trailing commas…” Can we come up with a simple use case for list2 here? The docs use list2(a = 1, a = 2, b = 3, b = 4, 5, 6) but how is this different from list? identical( rlang::list2(a = 1, a = 2, b = 3, b = 4, 5, 6) , list(a = 1, a = 2, b = 3, b = 4, 5, 6) ) ## [1] TRUE list2 is most helpful when we need to force environment variables with data variables. We can see this by creating a function that takes a variable number of arguments: library(rlang) numeric_list &lt;- function(...) { dots &lt;- list(...) num &lt;- as.numeric(dots) set_names(num, names(dots)) } numeric_list2 &lt;- function(...) { dots &lt;- list2(...) num &lt;- as.numeric(dots) set_names(num, names(dots)) } numeric_list(1, 2, 3) ## [1] 1 2 3 numeric_list2(1, 2, 3) ## [1] 1 2 3 The main difference with list(…) is that list2(…) enables the !!! syntax to splice lists: x &lt;- list(2, 3) numeric_list2(1, !!! x, 4) ## [1] 1 2 3 4 numeric_list(1, !!! x, 4) Error in !x : invalid argument type “lapply() uses ... to pass na.rm on to mean()” Um, how? x &lt;- list(c(1, 3, NA), c(4, NA, 6)) str(lapply(x, mean, na.rm = TRUE)) ## List of 2 ## $ : num 2 ## $ : num 5 An lapply takes on two main arguments: what you want to loop over and the function to apply to each element. By including ... lapply allows you to supply additional arguments which will be passed to the function inside the lapply. In this case, na.rm = TRUE is being applied to mean every time it’s being called in the loop. 6.6.1.2 Exercise I tried running browser(plot(1:10, col = &quot;red&quot;)) to peek under the hood but only got Called from: top level in the console. What am I missing? We can use debugonce! debugonce(plot()) 6.7.4 Exit handlers “Always set add = TRUE when using on.exit() If you don’t, each call to on.exit() will overwrite the previous exit handler.” What does this mean? add = TRUE is important when you have more than one on.exit function! j08 &lt;- function() { on.exit(message(&quot;a&quot;)) on.exit(message(&quot;b&quot;), add=TRUE) } j08() ## a ## b Can we go over this code? How does it not change your working directory after you run the function cleanup &lt;- function(dir, code) { old_dir &lt;- setwd(dir) on.exit(setwd(old_dir), add = TRUE) old_opt &lt;- options(stringsAsFactors = FALSE) on.exit(options(old_opt), add = TRUE) } cleanup(&quot;~&quot;) getwd() ## [1] &quot;/Users/mayagans/Documents/bookclub-Advanced_R/QandA&quot; The behavior of setwd “changing the working directory” is actually a side effect of the function - it invisibly returns the previous working directory as the value of the function (potentially for the exact purpose demonstrated). We can use this within our on.exit function to change back to the prior working directory! If on.exit fails will it continue onto the next on.exit so long as add == TRUE ?``on.exit fails it’ll continue onto the next one f &lt;- function() { on.exit(stop(&quot;Error&quot;)) on.exit(message(&quot;yay, still called.&quot;), add = TRUE) } f() Error in f() : Error yay, still called. 6.7.5.4 Exercise This question is flagged as “started” let’s try to complete it! Hadley comments in the repo: “I think I’m more interested in supplying a path vs. a logical value here”. Q: How does the chdir parameter of source() compare to with_dir()? Why might you prefer one approach to the other? The with_dir() approach was given in the book as in_dir &lt;- function(dir, code) { old &lt;- setwd(dir) on.exit(setwd(old)) force(code) } A: with_dir() takes a path to a working directory as an argument. First the working directory is changed accordingly. on.exit() ensures that the modification to the working directory are reset to the initial value when the function exits. with_dir gives you the flexibility to change the path to wherever you want (maybe a parent-level folder) whereas source(chdir=TRUE) changes the path to “where that file lives specifically”. Given the following file structure: Imagine I want to run import_data.R, but it needs to reference images/controlflow.png. we can do this by setting the wd to advRbookclub: with_dir(&quot;/advRbookclub/data/import_data.R&quot;,&quot;/advRbookclub&quot;) Or we can use: source(&quot;/advRbookclub/data/import_data.R&quot;, chdir=TRUE) but then, we’d need to include something like setwd(here::here()) in import_data.R so that it goes back to AdvancedR.Rproj and sets the working directory there. In conclusion: source is a base R function so reduces dependencies. Once set, you could use setwd(&quot;..&quot;)assuming you can have some confidence that it’s part of a repository or something? with_dir is exported from the withr package but is a more fine-tuned control by passing the specific folder name as opposed to a boolean TRUE | FALSE. 6.7.5.5 Exercise Can we go over the source code of capture.output and capture.output2? There were several new terms here to me when going over this function: stderr error output stdout normal output #!/usr/bin/env Rscript # redirect.r -- experiments with warning and error messages # Get any arguments (and ignore them) arguments &lt;- commandArgs(trailingOnly=TRUE) # Default write(&quot;1) write() to stderr&quot;, stderr()) write(&quot;1) write() to stdout&quot;, stdout()) warning(&quot;1) warning()&quot;) # Ignore all warnings options(warn = -1) write(&quot;2) write() to stderr&quot;, stderr()) write(&quot;2) write() to stdout&quot;, stdout()) warning(&quot;2) warning()&quot;) # Send all STDERR to STDOUT using sink() options(warn = 0) # default setting sink(stdout(), type=&quot;message&quot;) write(&quot;3) write() to stderr&quot;, stderr()) write(&quot;3) write() to stdout&quot;, stdout()) warning(&quot;3) warning()&quot;) # Send all STDOUT to STDERR using sink() sink(NULL, type=&quot;message&quot;) # default setting sink(stderr(), type=&quot;output&quot;) write(&quot;4) write() to stderr&quot;, stderr()) write(&quot;4) write() to stdout&quot;, stdout()) warning(&quot;4) warning()&quot;) # Send messages and output to separate files msg &lt;- file(&quot;message.Rout&quot;, open=&quot;wt&quot;) out &lt;- file(&quot;output.Rout&quot;, open=&quot;wt&quot;) sink(msg, type=&quot;message&quot;) sink(out, type=&quot;output&quot;) write(&quot;5) write() to stderr&quot;, stderr()) write(&quot;5) write() to stdout&quot;, stdout()) warning(&quot;5) warning()&quot;) sink diverts R output to a connection. zz &lt;- file(&quot;all.Rout&quot;, open = &quot;wt&quot;) sink(zz) sink(zz, type = &quot;message&quot;) try(log(&quot;a&quot;)) ## revert output back to the console -- only then access the file! sink(type = &quot;message&quot;) sink() file.show(&quot;all.Rout&quot;) textConnection allows R character vectors to be read as if they were being read from a text file. They can capture R output to a character vector They can be used to create a new character object or append to an existing one in the user’s workspace. At all times the complete lines output to the connection are available in the R object. Closing the connection writes any remaining output to a final element of the character vector. function (..., file = NULL, append = FALSE, type = c(&quot;output&quot;, &quot;message&quot;), split = FALSE) { # Capture dots # [-1L] removes the list() args &lt;- substitute(list(cat(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;\\n&quot;)))[-1L] # match type &lt;- match.arg(type) # set default return value rval &lt;- NULL # set default closer closeit &lt;- TRUE # if file is null, then if (is.null(file)) # If file is null, then create a write-only text connection object which will # save to the variable rval in the execution environment (local = TRUE). # see https://biostatmatt.com/R/R-conn-ints.pdf for gritty info on connections (and sinks) file &lt;- textConnection(&quot;rval&quot;, &quot;w&quot;, local = TRUE) else if (is.character(file)) # if &quot;file&quot; is a character vector, then interpret it as a filename. Open a # file connection in either append or write mode, depending on the value of # &quot;append&quot; file &lt;- file(file, if (append) &quot;a&quot; else &quot;w&quot;) else if (inherits(file, &quot;connection&quot;)) { # if &quot;file&quot; is already a connection object, check if it is open. If not, open it # in append mode, if specified, otherwise in write mode. # inherits refers to the S3 class system. # # Browse[2]&gt; class(file) # [1] &quot;textConnection&quot; &quot;connection&quot; if (!isOpen(file)) open(file, if (append) &quot;a&quot; else &quot;w&quot;) # if the connection is already open, don&#39;t close it in this function. else closeit &lt;- FALSE } # if you get here, then you misspecified &quot;file&quot; else stop(&quot;&#39;file&#39; must be NULL, a character string or a connection&quot;) # sink all output of type &quot;type&quot; into the connection &quot;file&quot;. If you would like # the output to continue to its original source, then &quot;split&quot; it. # # by default, messages (messages, warnings, errors) go to stderr and # everything else to stdout. sink(file, type = type, split = split) on.exit({ # on exit, call sink with the same arguments and without &quot;file&quot; being specified. # this will cause the sink from the line before to terminate. sink(type = type, split = split) # Close the connection (always, unless &quot;file&quot; was provided as # an already open connection) if (closeit) close(file) }) # store the calling environment in pf. i.e. pf refers to the environment in # which capture.output was called. pf &lt;- parent.frame() # define a local function which will evaluate its sole argument (expr) in the # parent frame. evalVis &lt;- function(expr) withVisible(eval(expr, pf)) # for each argument collected in the dot dot dot. # # use split = TRUE to help you debug at this point. When you try to poke around # with the sink applied, you are rightfully stymied because all output is going # to the sink connection! for (i in seq_along(args)) { # store the argument in expr expr &lt;- args[[i]] # based on the mode of the expr, evaluate it. tmp &lt;- switch(mode(expr), expression = lapply(expr, evalVis), call = , name = list(evalVis(expr)), stop(&quot;bad argument&quot;)) # print any visible values output during evaluation. # This print will be collected by the sink we set up earlier and saved to # the file connection. for (item in tmp) if (item$visible) print(item$value) } # calling on.exit with no arguments will clear the exit handler. # we are doing this because the on.exit was designed to safeguard the sink # and files being closed in the case of an exception when evaluating the # passed in arguments. on.exit() # undo the sink sink(type = type, split = split) # close the file if necessary if (closeit) close(file) # return the captured output or null invisibly otherwise. if (is.null(rval)) invisible(NULL) else rval } capture.output2 &lt;- function(code) { temp &lt;- tempfile() on.exit(file.remove(temp), add = TRUE) sink(temp) on.exit(sink(), add = TRUE) force(code) readLines(temp) } The second function will always sink output to a temporary file, and then return the results by reading the file back in (and returning a character vector). It uses two exit handlers, one to clean up the temporary file, and one to remove the sink. 6.8.4 Replacement functions Can we put into words the translation for x &lt;- c(a = 1, b = 2, c = 3) names(x) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; names(x)[2] &lt;- &quot;two&quot; names(x) ## [1] &quot;a&quot; &quot;two&quot; &quot;c&quot; Being equal to `*tmp*` &lt;- x x &lt;- `names&lt;-`(`*tmp*`, `[&lt;-`(names(`*tmp*`), 2, &quot;two&quot;)) rm(`*tmp*`) We can dig into the source code, but the jist is that in order to implement these complex assignments: Copy x into a temporary variable *temp* [&lt;-(names(*tmp*), 2, &quot;two&quot;) modifies the second element of the names of *temp*, names&lt;-(*tmp* assigns step 2 to *temp* names Clean up by removing the temp variable 6.8.6.3 Exercise This question is flagged as “started” let’s try to complete it! Q: Explain why the following code fails: ```r modify(get(&quot;x&quot;), 1) &lt;- 10 #&gt; Error: target of assignment expands to non-language object ``` A: First, let’s define x and recall the definition of modify() from the textbook: x &lt;- 1:3 `modify&lt;-` &lt;- function(x, position, value) { x[position] &lt;- value x } R internally transforms the code and the transformed code reproduces the error above. get(&quot;x&quot;) &lt;- `modify&lt;-`(get(&quot;x&quot;), 1, 10) #&gt; Error in get(&quot;x&quot;) &lt;- `modify&lt;-`(get(&quot;x&quot;), 1, 10) : #&gt; target of assignment expands to non-language object The error occurs during the assignment, because no corresponding replacement function, i.e. get&lt;- exists for get(). To confirm this we can reproduce the error via the following simple example. get(&quot;x&quot;) &lt;- 2 #&gt; Error in get(&quot;x&quot;) &lt;- 2 : target of assignment expands to non-language object I don’t really see why this needs to be expanded upon…. "],
["environments.html", "Chapter 7 Environments 7.2.3 Parents 7.2.4 Super assignment 7.2.5 Getting and setting 7.2.6 Advanced bindings 7.3 Recursing over environments 7.3.1.2 Exercises 7.4.2 Function enviornment 7.4.3 Namespaces 7.5 Call stacks 7.6 Data Structures", " Chapter 7 Environments 7.2.3 Parents What’s the relationship between base, empty enviornment, and global enviornment? The working environment is the environment whose names would currently mask names in any other environment. Note that in the book, the term current environment is used not working environment. At any given time there is an environment that is most immediately-visible i.e. its names will mask the same names in any other environment. This is the current environment. The identity of the current environment can change e.g. when entering a function. It is often the case that the current environment is the global environment i.e. typically when working interactively. Are functions the only mechanism for changing the current environment? (I believe the answer is yes.) Consider the following from the book: The current environment, or current_env() is the environment in which code is currently executing. When you’re experimenting interactively, that’s usually the global environment, or global_env(). The use of the word “usually” in this sentence raises the possibility that there’s an exception. That exception could possibly mean There’s a way to change the environment in interactive mode without going into a function You can experiment interactively within a function or Something I’m ignorant of. I know that you can step-through a function in the debug browser so maybe that’s what he means? But then the very next line in the text says: The global environment is sometimes called your “workspace”, as it’s where all interactive (i.e. outside of a function) computation takes place. It both i) defines interactive specifically to exclude the inside of a function and ii) makes a stronger claim, “all interactive computation” vs “usually”. If you put a breakpoint or browser() call inside a function, then you would be working interactively in a function environment. Does hierarchy of environments have a computer science name (linked list?)? The hierarchy of environments is not a linked list, it is a directed graph. Clarification: the global environment’s parent is all the packages loaded within the environment, not the empty environment, right? How do we check this? parent.env(global)? Each package becomes a parent to the global environment. We can inspect local enviornments using search_envs() search_envs() ## [[1]] $ &lt;env: global&gt; ## [[2]] $ &lt;env: package:openintro&gt; ## [[3]] $ &lt;env: package:usdata&gt; ## [[4]] $ &lt;env: package:cherryblossom&gt; ## [[5]] $ &lt;env: package:airports&gt; ## [[6]] $ &lt;env: package:rlang&gt; ## [[7]] $ &lt;env: package:lobstr&gt; ## [[8]] $ &lt;env: package:kableExtra&gt; ## [[9]] $ &lt;env: package:forcats&gt; ## [[10]] $ &lt;env: package:stringr&gt; ## [[11]] $ &lt;env: package:dplyr&gt; ## [[12]] $ &lt;env: package:purrr&gt; ## [[13]] $ &lt;env: package:readr&gt; ## [[14]] $ &lt;env: package:tidyr&gt; ## [[15]] $ &lt;env: package:tibble&gt; ## [[16]] $ &lt;env: package:ggplot2&gt; ## [[17]] $ &lt;env: package:tidyverse&gt; ## [[18]] $ &lt;env: package:stats&gt; ## [[19]] $ &lt;env: package:graphics&gt; ## [[20]] $ &lt;env: package:grDevices&gt; ## ... and 5 more environments 7.2.4 Super assignment Let’s expand on the concept of super assignment x &lt;- 0 f &lt;- function() { x &lt;- 2 x &lt;&lt;- 1 x } f() ## [1] 2 x ## [1] 1 Note that the assignment inside f is local, but super assignment “never creates a variable in the current environment” so it modifies the global x and not the local x. If you want to break your brain a bit, check out: x &lt;- 0 f &lt;- function() { x &lt;- x x &lt;&lt;- x + 1 x } f() ## [1] 0 x ## [1] 1 f() ## [1] 1 x ## [1] 2 f() ## [1] 2 x ## [1] 3 7.2.5 Getting and setting “But you can’t use [[ with numeric indices, and you can’t use [:” It makes sense to me that you can’t use numeric indexes because objects in an environment aren’t ordered, but why can’t you use [? The solutions manual states: &quot;The second option would return two objects at the same time. What data structure would they be contained inside? [ returns an object of the same type, if we were to apply this to environments we’d have an environment returning an environment. 7.2.6 Advanced bindings Hadley mentions delayed bindings are used when autoloading datasets with packages - can we find an example of this? How is this different from including LazyData: true in your description file? The LazyData: true entry in DESCRIPTION just informs that delayed binding should be used. autoload does use delayed bindings [from source code: do.call(&quot;delayedAssign&quot;, list(name, newcall, .GlobalEnv, .AutoloadEnv))] but lazydata that gets used by packages is ultimately implemented as an internal function. If you scan through View(loadNamespace): if (file.exists(paste0(dbbase, &quot;.rdb&quot;))) lazyLoad(dbbase, env) dbbase &lt;- file.path(pkgpath, &quot;data&quot;, &quot;Rdata&quot;) if (file.exists(paste0(dbbase, &quot;.rdb&quot;))) lazyLoad(dbbase, .getNamespaceInfo(env, &quot;lazydata&quot;)) and lazyLoad eventually calls .Internal(makeLazy(vars, vals, expr, db, envir)) which leads you to https://github.com/wch/r-source/blob/726bce63825844715860d35fdf76539445529f52/src/main/builtin.c#L103 and ultimately the delayed binding is realized as a promise with defineVar(name, mkPROMISE(expr0, eenv), aenv);. 7.3 Recursing over environments How can we re-write where so that it returns all functions with the same name? where2 &lt;- function(in_name, env = caller_env()) { all_functions &lt;- &quot;&quot; index &lt;- 1 while (!identical(env, empty_env())) { # if success if (env_has(env, in_name)) { all_functions[index] &lt;- env_name(env) index &lt;- index + 1 #return() } # inspect parent env &lt;- env_parent(env) } # base case - I&#39;m missing this I think return(all_functions) } # load dplyr so you have two filters library(dplyr) where2(&quot;filter&quot;) ## [1] &quot;package:dplyr&quot; &quot;package:stats&quot; We can also create a function that emulates pryr’s where: where3 &lt;- function(name, env = parent.frame(), found = character()) { if (identical(env, emptyenv())) return(found) else if (exists(name, env, inherits = FALSE)) { Recall(name, parent.env(env), c(found, environmentName(env))) } else { Recall(name, parent.env(env), found) } } where3(&quot;filter&quot;) ## [1] &quot;package:dplyr&quot; &quot;package:stats&quot; 7.3.1.2 Exercises I understood the recursion in the prior example, but what is inherits doing here? Can we go through this line for line and discuss what is happening in this function? fget &lt;- function(name, env = caller_env(), inherits = TRUE) { # Base case if (env_has(env, name)) { obj &lt;- env_get(env, name) if (is.function(obj)) { return(obj) } } if (identical(env, emptyenv()) || !inherits) { stop(&quot;Could not find function called \\&quot;&quot;, name, &quot;\\&quot;&quot;, call. = FALSE) } # Recursive Case fget(name, env_parent(env)) } # Test mean &lt;- 10 fget(&quot;mean&quot;, inherits = TRUE) ## function (x, ...) ## UseMethod(&quot;mean&quot;) ## &lt;bytecode: 0x7fa7e583f778&gt; ## &lt;environment: namespace:base&gt; Inherits is an argument that stops the function from performing the recursive action of looking into the parent environment for the name. Inherits is acting like a valve. If false, and the name wasnt found in the current environment, then stop because the next expression searches the parent of env. In the case environment is the empty environment then stop because the empty environment doesnt have a parent. 7.4.2 Function enviornment I found this section a little confusing. Can we go over the second figure in the section? Where does x live? g points to x but x is in the global enviornment? Can we come up with our own example for a function being bound to the global environment but accessing variables from its own enviornment? (I think this is what the second figure in the section is trying to display) y &lt;- 1 e &lt;- env() e$g &lt;- function() 1 e$g ## function() 1 This can be seen in our where2 example in the recursion section! 7.4.3 Namespaces “Every binding in the package environment is also found in the namespace environment; this ensures every function can use every other function in the package. But some bindings only occur in the namespace environment. These are known as internal or non-exported objects, which make it possible to hide internal implementation details from the user.” When you’re developing a package does the namespace environment just come with your package for free when you build it or you need to create both your package and its namespace env? How do you create functions that exist only in the namespace environment? When you are building the package, everything in the NAMESPACE file gets generated by roxygen2. Attaching a package puts the package in the search path of namespaces. So when you run library(package) or require(package) it creates the namespace environment. Package developers control what names are available by exporting to namespace (and otherwise you can call non-exported with :::). For example let’s say you want to extend forcats to use ordered factors to lump the tails. In order to get it to work, we need to use some forcats helper functions. We could just copy the code for the functions and added them to our scripts, but for prototyping it’s easy enough to just use ::: fct_lump_ordered &lt;- function(f, n, prop, q, w = NULL, other_level_low = &quot;Other Low&quot;, other_level_high = &quot;Other High&quot;, ties.method = c(&quot;min&quot;, &quot;average&quot;, &quot;first&quot;, &quot;last&quot;, &quot;random&quot;, &quot;max&quot;)) { f &lt;- check_ordered(f) w &lt;- forcats:::check_weights(w, length(f)) ties.method &lt;- match.arg(ties.method) levels &lt;- levels(f) if (is.null(w)) { count &lt;- as.vector(table(f)) total &lt;- length(f) } else { count &lt;- as.vector(tapply(w, f, FUN = sum)) total &lt;- sum(w) } if (all(missing(n), missing(prop), missing(q))) { lump &lt;- forcats:::in_smallest(count) lump &lt;- lump_range(!lump) new_levels &lt;- ifelse(lump == -1L,other_level_low, ifelse(lump == 1L, other_level_high, levels)) } else if (!missing(n) ) { if (n &lt; 0) { rank &lt;- rank(count, ties = ties.method) n &lt;- -n } else { rank &lt;- rank(-count, ties = ties.method) } if (sum(rank &gt; n) &lt;= 1) { return(f) } lump &lt;- lump_range(rank &lt;= n) new_levels &lt;- ifelse(lump == -1L, other_level_low, ifelse(lump == 1L, other_level_high, levels)) } else if (!missing(prop)) { prop_n &lt;- count/total if(prop &lt; 0) { lump &lt;- lump_range(prop_n &lt;= -prop) new_levels &lt;- ifelse(lump == -1L, other_level_low, ifelse(lump == 1L, other_level_high, levels)) } else { if (sum(prop_n &lt;= prop) &lt;= 1) { return(f) } lump &lt;- lump_range(prop_n &gt;= prop) new_levels &lt;- ifelse(lump == -1L, other_level_low, ifelse(lump == 1L, other_level_high, levels)) } } else if (!missing(q)) { cdf &lt;- cumsum(count)/sum(count) lump &lt;- lump_range(cdf &gt;= q[1] &amp; cdf &lt;= q[2]) new_levels &lt;- ifelse(lump == -1L, other_level_low, ifelse(lump == 1L, other_level_high, levels)) } if (other_level_low %in% new_levels &amp;&amp; other_level_high %in% new_levels) { f &lt;- forcats::lvls_revalue(f, new_levels) forcats::fct_relevel(f, other_level_low) forcats::fct_relevel(f, other_level_high, after = Inf) } else if (other_level_low %in% new_levels) { f &lt;- forcats::lvls_revalue(f, new_levels) forcats::fct_relevel(f, other_level_low) } else if (other_level_high %in% new_levels) { f &lt;- forcats::lvls_revalue(f, new_levels) forcats::fct_relevel(f, other_level_high, after = Inf) } else { f } How do conflicted packages identify duplicate function names and print them out We can use conflict_scout! conflicted::conflict_scout ## function (pkgs = NULL) ## { ## pkgs &lt;- pkgs %||% pkgs_attached() ## objs &lt;- lapply(pkgs, pkg_ls) ## names(objs) &lt;- pkgs ## index &lt;- invert(objs) ## potential &lt;- Filter(function(x) length(x) &gt; 1, index) ## unique &lt;- Map(unique_obj, names(potential), potential) ## conflicts &lt;- Filter(function(x) length(x) &gt; 1, unique) ## conflicts &lt;- map2(names(conflicts), conflicts, superset_principle) ## conflicts &lt;- map2(names(conflicts), conflicts, drop_moved) ## for (fun in ls(prefs)) { ## if (!has_name(conflicts, fun)) ## next ## conflicts[[fun]] &lt;- prefs_resolve(fun, conflicts[[fun]]) ## } ## conflicts &lt;- compact(conflicts) ## new_conflict_report(conflicts) ## } ## &lt;bytecode: 0x7fa7e8e27a18&gt; ## &lt;environment: namespace:conflicted&gt; 7.5 Call stacks What exactly is a frame? A frame is a singular step within the CST - in thr following example, f, g, and h are each frames f &lt;- function(x) { g(x = 2) } g &lt;- function(x) { h(x = 3) } h &lt;- function(x) { stop() } 7.6 Data Structures Can we discuss what’s happening in this function? Since it’s similar to the setwd function from last week could we build on this function to include on.exit()? my_env &lt;- new.env(parent = emptyenv()) my_env$a &lt;- 1 get_a &lt;- function() { my_env$a } set_a &lt;- function(value) { old &lt;- my_env$a my_env$a &lt;- value invisible(old) } We can use those two functions like we did getting and setting the work directory inside another function - using the old value within on.exit to reset my_env$a outside of the function: Hadley suggests returning invisible old so that you don’t need to explicitly call get_a, you can just assign the output of set_a set_a &lt;- function(value) { old &lt;- my_env$a my_env$a &lt;- value invisible(old) } do_thing_where_env_a_is_value(value, code) { myoldenv &lt;- set_a(value) # sets a to the NEW value and returns the OLD value for storage on.exit(set_a(myoldenv), add=TRUE) force(code) } The bullet point mentions hashmaps but I’m still really unclear on what that is. What are hash tables and are they related? They are sort of like fast look-up tables! It may be impossible to show with a small example. To demonstrate that the lookup is fast you’d need to store a lot of stuff in it first. You’d also probably need an alternative implementation of a lookup table to compare it to. We could probably implement a hash table relatively easily* using environments. Demonstrating that using environments is a good way to do it seems difficult. looking at a data structures textbook (Cormen, Lieserson &amp; Rivest), a hash table is expected to provide users with fast functions for insert, search, and delete. "],
["conditions.html", "Chapter 8 Conditions 8.3 Ignoring conditions 8.4.2 Exiting handlers 8.4.3 Calling handlers 8.4.5.2 Exercises 8.4.5.3 Exercises 8.6.3 Resignal 8.6.4 Record 8.6.6.2 Exercises 8.6.6.4 Exercises Slides", " Chapter 8 Conditions 8.3 Ignoring conditions I can’t quite think of a time where try is more appropriate than tryCatch - does anyone have an example? It seems that try is just a wrapper for tryCatch and you can use it whenever you’d use try When would you actually use suppressWarning? Maybe when loading libraries? I created an example for suppressMessages, but does someone have a better, practical use case? As a function user, it’s common to suppress warnings when loading in data and using readr and dplyr - but not so much as a function creator 8.4.2 Exiting handlers tryCatch( message = function(cnd) &quot;There&quot;, { message(&quot;Here&quot;) stop(&quot;This code is never run!&quot;) } ) #&gt; [1] &quot;There&quot; The protected code is evaluated in the environment of tryCatch(), but the handler code is not, because the handlers are functions. Clarification question what is the “handler code” and “protected code”? The protected code is inside the {} and the handler code is message = function(cnd) &quot;There&quot; In the tryCatch example where we have finally print “Thank God for Beer” I find it interesting that this is printed before the code inside the tryCatch. Can anyone explain why? From the help it’s, “expression to be evaluated before returning or exiting.” That means it’s the final thing that happens inside the tryCatch, but it happens before the return (of NA or the string), so it happens first. 8.4.3 Calling handlers How would you define bubbling up? Bubbling up: By default, a condition will continue to propagate to parent handlers, all the way up to the default handler (or an exiting handler, if provided) I would consider what is being described there “bubbling up”. Why is this message executed once per message in the function? withCallingHandlers( message = function(cnd) cat(&quot;Caught a message!\\n&quot;), { message(&quot;Someone there?&quot;) message(&quot;Why, yes!&quot;) } ) #&gt; Caught a message! #&gt; Someone there? #&gt; Caught a message! #&gt; Why, yes! withCallingHandlers could be understood as: “for each {message}, do x” The following prints the message once: withCallingHandlers( message = function(cnd) cat(&quot;Caught a message!\\n&quot;), { warning(&quot;Someone there?&quot;) message(&quot;Why, yes!&quot;) } ) ## Warning in withCallingHandlers(message = function(cnd) cat(&quot;Caught a message! ## \\n&quot;), : Someone there? ## Caught a message! ## Why, yes! and it comes in the warning message, so it’s not really a “direct” print Oh wait, the handler code is named message, so is it possible that the two message calls in the protected block are actually calling both base::message and the message - named handler? The return value of a calling handler is ignored because the code continues to execute after the handler completes; where would the return value go? That means that calling handlers are only useful for their side-effects. Can we come up with an example for this masking? I think seeing it will help me understand… This just means that you cannot capture the return value of your handler (but you sort of can) f &lt;- function() { my_lovin &lt;- NULL withCallingHandlers( message = function(cnd) {my_lovin &lt;&lt;- &quot;not this time&quot;}, { never_ever_gunna_get_it = message(&quot;No, you&#39;re never gonna get it&quot;) } ) my_lovin } f() ## No, you&#39;re never gonna get it ## [1] &quot;not this time&quot; How does muffling differ from suppressWarnings? muffling allows for an over-ride/replacement of messages, while suppress just quiets everything: fn &lt;- function() { inform(&quot;Beware!&quot;, &quot;my_particular_msg&quot;) inform(&quot;On your guard!&quot;) &quot;foobar&quot; } Now we can use a new definition of my_particular_msg to replace “Beware” with_handlers(fn(), my_particular_msg = calling(function(cnd) { inform(&quot;Dealt with this particular message&quot;) cnd_muffle(cnd) }) ) ## Dealt with this particular message ## On your guard! ## [1] &quot;foobar&quot; whereas suppressMessages just returns foobar: suppressMessages(fn()) ## [1] &quot;foobar&quot; 8.4.5.2 Exercises In the example show_condition &lt;- function(code) { tryCatch( error = function(cnd) &quot;error&quot;, warning = function(cnd) &quot;warning&quot;, message = function(cnd) &quot;message&quot;, { code NULL } ) } The first three calls to show_condition make sense to me, and I even understand that the first time the code is evaluated inside a tryCatch it exists (that’s why it returns message) but how are you supplying 3 arguments to a function that just takes on one argument, code? Is that what the {} are for? show_condition({ 10 message(&quot;?&quot;) warning(&quot;?!&quot;) }) {} let us execute multiple lines of code! 8.4.5.3 Exercises I couldn’t follow the manual’s answer for what’s happening here, can we come up with our own answer for what’s happening here in words? withCallingHandlers( message = function(cnd) message(&quot;b&quot;), withCallingHandlers( message = function(cnd) message(&quot;a&quot;), message(&quot;c&quot;) ) ) ## b ## a ## b ## c The first call to withcallinghandlers adds a condition handler for conditions with class “message” to the handler stack (not sure if its actually a stack?) and then executes the second withcallinghandlers which adds another condition handler for conditions with class “message” to the handler stack (see above), and then executes the code message(&quot;c&quot;). What happens next is a chain reaction of handlers. The call message(&quot;c&quot;) is handled by the inner handler, which then calls message(&quot;a&quot;), but message(&quot;a&quot;) is caught by the outer handler, and so it outputs b first. Then the inner handler resolves itself and outputs a and then that condition (having not been muffled) “bubbles up” to the outer handler, which calls message(&quot;b&quot;) again producing the second b and again since the message wasn’t muffled, the original condition message(&quot;c&quot;) “bubbles up” to the top where it is evaluated producing the output c Another exercise: Guess the output of these two functions: i &lt;- 1 withCallingHandlers( message = function(cnd) {message(paste0(i, &quot;. b&quot;)); i &lt;&lt;- i+1}, withCallingHandlers( message = function(cnd) {message(paste0(i, &quot;. a&quot;)); i &lt;&lt;- i+1}, {message(paste0(i, &quot;. c&quot;))} ) ) ## 1. b ## 1. a ## 3. b ## 1. c i &lt;- 1 withCallingHandlers( message = function(cnd) {i &lt;&lt;- i+1; message(paste0(i, &quot;. b&quot;))}, withCallingHandlers( message = function(cnd) {i &lt;&lt;- i+1; message(paste0(i, &quot;. a&quot;))}, {message(paste0(i, &quot;. c&quot;))} ) ) ## 3. b ## 2. a ## 4. b ## 1. c 8.6.3 Resignal Can we go over what is happening here? warning2error &lt;- function(expr) { withCallingHandlers( warning = function(cnd) abort(conditionMessage(cnd)), expr ) } warning2error({ x &lt;- 2 ^ 4 warn(&quot;Hello&quot;) }) Error: Hello The function warning2error captures an expression which is evaluated by withCallingHandlers where you have defined a handler for warning conditions. The handler captures the condition cnd raised by warn which is structure(list(message = &quot;Hello&quot;), class = c(&quot;warning&quot;, &quot;condition&quot;) The function conditionMessage is an s3 generic which evaluates to conditionMessage.condition which simply accesses cnd$message this is then the input to abort which raises an error with the message &quot;Hello&quot; 8.6.4 Record Why are we using cnd_muffle here? catch_cnds &lt;- function(expr) { conds &lt;- list() add_cond &lt;- function(cnd) { conds &lt;&lt;- append(conds, list(cnd)) cnd_muffle(cnd) } withCallingHandlers( message = add_cond, warning = add_cond, expr ) conds } catch_cnds({ inform(&quot;a&quot;) warn(&quot;b&quot;) inform(&quot;c&quot;) }) If we remove cnd_muffle we see that a, b, and c are printed to the console prior to getting the conds output. Would it be possible in the second Record example to create a function that doesn’t require us to put the abort statement at the end, just ignoring it? Or because abort is an exiting handler it needs to be last? catch_cnds &lt;- function(expr) { conds &lt;- list() add_cond &lt;- function(cnd) { conds &lt;&lt;- append(conds, list(cnd)) cnd_muffle(cnd) } tryCatch( error = function(cnd) { conds &lt;&lt;- append(conds, list(cnd)) }, withCallingHandlers( message = add_cond, warning = add_cond, expr ) ) conds } catch_cnds({ abort(&quot;a&quot;) inform(&quot;b&quot;) warn(&quot;c&quot;) }) I’m not positive, but I don’t think so without mucking around in the C code. You “can” using try instead of tryCatch, but I can’t think of a way to have it let you try each line in your passed in expression for example What is signal and what is it doing here? log &lt;- function(message, level = c(&quot;info&quot;, &quot;error&quot;, &quot;fatal&quot;)) { # if we remove match.arg and just use level # the signal returns infoerrorfatal as a single string # we need match.arg to find the selected level # and it defaults to the first if none are selected level &lt;- match.arg(level) signal(message, &quot;log&quot;, level = level) } Signal is a general function that calls abort, inform or warn. It has the same signature as those functions except for the class argument that is necessary for signal but NULL by default for each of the others signal &lt;- function(message, class, ..., .subclass) { if (!missing(.subclass)) { deprecate_subclass(.subclass) } message &lt;- collapse_cnd_message(message) cnd &lt;- cnd(class, ..., message = message) cnd_signal(cnd) } If you create a condition object by hand, and signal it with signalCondition(), cnd_muffle() will not work. Instead you need to call it with a muffle restart defined, like this: withRestarts(signalCondition(cond), muffle = function() NULL) Where does this code go given the prior example? We would replace the code cnd_muffle(cnd): ignore_log_levels &lt;- function(expr, levels) { withCallingHandlers( log = function(cnd) { if (cnd$level %in% levels) { # cnd_muffle(cnd) withRestarts(signalCondition(cnd), muffle = function() NULL) } }, expr ) } record_log(ignore_log_levels(log(&quot;Hello&quot;), &quot;warning&quot;)) [info] &quot;Hello&quot; 8.6.6.2 Exercises Calling handlers are called in the context of the call that signaled the condition. Exiting handlers are called in the context of the call to tryCatch(). What exactly does this mean? tryCatch evaluates what we were calling the protected code first and calling handlers execute the handling code first? Can we make a simple example? tryCatch is a project manager who oversees everything and then personally hands over the end product withCallingHandlers writes some procedures/guidelines and assumes everyone has enough information to get their jobs done Comparing: f &lt;- function() g() g &lt;- function() h() h &lt;- function() message(&quot;!&quot;) withCallingHandlers(f(), message = function(cnd) { lobstr::cst() cnd_muffle(cnd) }) ## █ ## 1. ├─base::withCallingHandlers(...) ## 2. ├─global::f() ## 3. │ └─global::g() ## 4. │ └─global::h() ## 5. │ └─base::message(&quot;!&quot;) ## 6. │ ├─base::withRestarts(...) ## 7. │ │ └─base:::withOneRestart(expr, restarts[[1L]]) ## 8. │ │ └─base:::doWithOneRestart(return(expr), restart) ## 9. │ └─base::signalCondition(cond) ## 10. └─(function (cnd) ... ## 11. └─lobstr::cst() withCallingHandlers is run to completion before f is called/put onto the stack. While f is in progress, g needs to be called so g is put on top of the stack, then h etc. Eventually they’re all completed and taken off the stack (in reverse order). Then the handler (function (cnd) ... is called While tryCatch(f(), message = function(cnd) lobstr::cst()) ## █ ## 1. └─base::tryCatch(f(), message = function(cnd) lobstr::cst()) ## 2. └─base:::tryCatchList(expr, classes, parentenv, handlers) ## 3. └─base:::tryCatchOne(expr, names, parentenv, handlers[[1L]]) ## 4. └─value[[3L]](cond) ## 5. └─lobstr::cst() tryCatch is still on the stack when the handler is called i.e. value, tryCatchOne, tryCatchList and tryCatch are all still in line to be completed Calling handlers are called in the context of the call that signaled the condition, in this case,f(). So the message handler returns a value to the environment where f() is a meaningful call. Exiting handlers are called in the context of the call to tryCatch(). The exiting handler returns to an ongoing tryCatch() so it can do whatever it needs to do. 8.6.6.4 Exercises There’s no way to break out of the function because we’re capturing the interrupt that you’d usually use! What does this mean? You can’t stop the function if you set an interrupt argument inside a tryCatch? That’s exactly it - this was a warning not to use inturrupt in your functions!ß Slides What environment(s) these restarts are called within, or if that even applies or matters Note: for this example I set my Environment panel in Rstudio to “Manual Refresh Only” (the curly arrow menu) while running this to make sure it wasn’t doing anything to confuse me. expensive_function &lt;- function(x, # warning print the warning and send us to browser warning = function(w) { print(paste(&#39;warning:&#39;, w )); browser() }, # error print the error and send us to browser error=function(e) { print(paste(&#39;e:&#39;,e )); browser()} ) { print(paste(&quot;big expensive step we don&#39;t want to repeat for x:&quot;,x)) z &lt;- x # the &quot;expensive operation&quot; print(&quot;Main function caller_env:&quot;) print(rlang::caller_env()) print(&quot;Main function current_env:&quot;) print(rlang::current_env()) print(&quot;Main function parent:&quot;) print(rlang::env_parent(rlang::current_env(), 1)) repeat # second function on z that isn&#39;t expensive but could potentially error withRestarts( withRestarts( withCallingHandlers( { print(&quot;withCallingHandlers caller_env:&quot;) print(rlang::caller_env()) print(&quot;withCallingHandlers current_env:&quot;) print(rlang::current_env()) print(&quot;withCallingHandlers parent:&quot;) print(rlang::env_parent(rlang::current_env(), 1)) print(paste(&quot;attempt cheap operation for z:&quot;,z)) return(log(z)) }, warning = warning, error = error ), force_positive = function() { z &lt;&lt;- -z print(&quot;force_positive caller_env:&quot;) print(rlang::caller_env()) print(&quot;force_positive current_env:&quot;) print(rlang::current_env()) print(&quot;force_positive parent:&quot;) print(rlang::env_parent(rlang::current_env(), 1)) } ), set_to_one = function() {z &lt;&lt;- 1} ) } expensive_function(-1) You can run it yourself (and then invokeRestart(&quot;force_positive&quot;)) to see the results, but to summarize: The withCallingHandlers part is executing in exactly the same environment as the function. The force_positive restart is executing in its own new environment. The parent of that environment is the execution environment of the main function. The caller_env for force_positive, though, is still a bit of a mystery. Some further poking found that its grandparent is the base package’s namespace, but I don’t grok why. Maybe because it’s the browser() environment? Is that a thing? Are there any default restarts include in base R so that you could invokeRestart(&quot;XXX&quot;) or is the restart always user defined? From the warning documentation: While a warning is being processed, a muffleWarning restart is available. If this restart is invoked with invokeRestart, then warning returns immediately. We can also use the computeRestarts function which lists all available “default” restart functions: computeRestarts() [[1]] &lt;restart: abort &gt; It seems computeRestarts() is able to find abort even without {rlang} attached! Which means it surely would be able to find some function from the base packages if one existed. But it does not, so that leads me to believe that they aren’t any beyond muffleWarning. it seems, in general, you need to specify a function name for invokeRestart() What environment(s) these restarts are called within, or if that even applies or matters Given this little example: # low level function # if text isn&#39;t correct then abort with class malformed_text is_correct &lt;- function(text) { print(&#39;parent in low: &#39;); print(env_parent()) print(&#39;current in low: &#39;); print(env_parent()) if (text != &quot;CORRECT&quot;) { msg &lt;- paste0(text, &quot; needs to be &#39;CORRECT&#39;&quot;) abort( &quot;malformed_text&quot;, message = msg, text = text ) } return(text) } # medium level function # apply low level function to all text in a list # if it doesn&#39;t pass give it the restart skip_text # which will change that entry to NA replace_not_correct &lt;- function(all_text) { # f &lt;- function(x) { print(current_env()); is_correct(x) } lapply(all_text, function(text) { withRestarts( # f(text), { print(&#39;parent in mid: &#39;) ; print(env_parent()); print(&#39;current in mid: &#39;); print(current_env()); is_correct(text) }, skip_text = function(e){ NA; print(&#39;parent in mid skip: &#39;); print(env_parent()); print(&#39;current in mid skip: &#39;); print(current_env())} ) }) } # res &lt;- replace_not_correct(list(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;)) # res &lt;- replace_not_correct(list(&#39;CORRECT&#39;, &#39;A&#39;)) # res # high level function # if you have an error of type malformed_text, # use the restart from the midlevel function analyze_text &lt;- function(all_text) { withCallingHandlers( malformed_text = function(e) invokeRestart(&quot;skip_text&quot;), lapply(all_text, replace_not_correct) ) } analyze_text(list(&quot;CORRECT&quot;, &quot;NOT&quot;, &quot;CORRECT&quot;)) ## [1] &quot;parent in mid: &quot; ## &lt;environment: 0x7f9f84a14438&gt; ## [1] &quot;current in mid: &quot; ## &lt;environment: 0x7f9f84a102d0&gt; ## [1] &quot;parent in low: &quot; ## &lt;environment: R_GlobalEnv&gt; ## [1] &quot;current in low: &quot; ## &lt;environment: R_GlobalEnv&gt; ## [1] &quot;parent in mid: &quot; ## &lt;environment: 0x7f9f854c4d90&gt; ## [1] &quot;current in mid: &quot; ## &lt;environment: 0x7f9f8a2431f8&gt; ## [1] &quot;parent in low: &quot; ## &lt;environment: R_GlobalEnv&gt; ## [1] &quot;current in low: &quot; ## &lt;environment: R_GlobalEnv&gt; ## [1] &quot;parent in mid skip: &quot; ## &lt;environment: 0x7f9f8a2431f8&gt; ## [1] &quot;current in mid skip: &quot; ## &lt;environment: 0x7f9f8b1faf20&gt; ## [1] &quot;parent in mid: &quot; ## &lt;environment: 0x7f9f8b202240&gt; ## [1] &quot;current in mid: &quot; ## &lt;environment: 0x7f9f8b205938&gt; ## [1] &quot;parent in low: &quot; ## &lt;environment: R_GlobalEnv&gt; ## [1] &quot;current in low: &quot; ## &lt;environment: R_GlobalEnv&gt; ## [[1]] ## [[1]][[1]] ## [1] &quot;CORRECT&quot; ## ## ## [[2]] ## [[2]][[1]] ## &lt;environment: 0x7f9f8b1faf20&gt; ## ## ## [[3]] ## [[3]][[1]] ## [1] &quot;CORRECT&quot; So, the parent environment of the handler (is that the right term?) called skip_text in the mid-level function is the environment of the expr part of withRestarts (i.e. the first parameter), also in the mid-level function. Are there any default restarts include in base R so that you could invokeRestart(&quot;XXX&quot;) or is the restart always user defined? From the warning documentation: While a warning is being processed, a muffleWarning restart is available. If this restart is invoked with invokeRestart, then warning returns immediately. We can also use the computeRestarts function which lists all available “default” restart functions: computeRestarts() [[1]] &lt;restart: abort &gt; It seems computeRestarts() is able to find abort even without {rlang} attached! Which means it surely would be able to find some function from the base packages if one existed. But it does not, so that leads me to believe that they aren’t any beyond muffleWarning. it seems, in general, you need to specify a function name for invokeRestart() Let’s revisit my example from the talk: can we build on this to use tidyeval so that the user can write beer_states %&gt;% beer_mean(state) [I think we need to use .data and note how state is given as an object so we need to use tidyeval to suppress it’s evaluation…] beer_states &lt;- readr::read_csv( &#39;https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-03-31/beer_states.csv&#39;) beer_mean &lt;- function(.data, x) { column_name &lt;- deparse(substitute(x)) msg &lt;- glue::glue(&quot;Can&#39;t calculate mean, {column_name} is not numeric&quot;) if (!is.numeric(.data[[column_name]])) { abort( message = msg, arg = column_name, data = .data ) } else { mean(which(!is.na(.data[[column_name]])[.data[[column_name]]])) } } beer_states %&gt;% beer_mean(barrels) [1] 806.4551 "],
["functionals.html", "Chapter 9 Functionals 9.2.2 Anonymous functions and shortcuts 9.2.6.4 Exercise 9.2.6.5 Exercise 9.4.1 Same type of output as input: modify() 9.4.5 Any number of inputs: pmap() and friends 9.4.6.2 Exercise 9.5.4 Multiple inputs 9.6.3.2 Exercise 9.7.1 Matrices and arrays 9.7.3.2 Exercise", " Chapter 9 Functionals 9.2.2 Anonymous functions and shortcuts We saw you’ll get an error if you try to map over elements that don’t exist, and can use .default to override that. Is this related to tryCatch in some way? Can we look at the map source code for .default? And how would we overcome this error if we were to use base R’s lapply(x, 'two') x &lt;- list( list(one = &quot;a&quot;), list(two = &quot;b&quot;), list(three = &quot;c&quot;) ) map_chr(x, &#39;two&#39;, .default = NA) ## [1] NA &quot;b&quot; NA lapply(x, &#39;two&#39;) Error in get(as.character(FUN), mode = &quot;function&quot;, envir = envir) : object &#39;two&#39; of mode &#39;function&#39; was not found Within purrr there’s the function find_extract_default &lt;- function(.null, .default) { if (!missing(.null)) { .null } else { .default } } So it doesn’t seem to be a conditional, but rather a way to deal with missing errors as.character(lapply(x,`[[`,&quot;two&quot;)) [1] &quot;NULL&quot; &quot;b&quot; &quot;NULL&quot; 9.2.6.4 Exercise In order to extract p-values the solution manual suggests using map_dbl but could we use pluck to get these values? If so how? trials &lt;- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7))) # tibble(p_value = map_dbl(trials, &quot;p.value&quot;)) map_dbl(trials, pluck, &quot;p.value&quot;) ## [1] 6.341521e-04 1.938685e-02 2.048655e-01 9.383923e-01 9.827524e-02 ## [6] 5.450035e-03 2.244009e-03 4.302240e-02 1.602473e-01 3.869987e-01 ## [11] 1.479612e-02 3.492703e-03 8.928272e-01 4.205978e-02 4.088865e-01 ## [16] 4.011641e-01 2.236957e-01 1.719979e-02 1.317141e-02 7.185248e-03 ## [21] 8.982844e-01 8.967827e-02 8.745556e-02 1.760800e-02 2.048964e-03 ## [26] 6.107312e-05 8.466586e-02 1.408371e-02 1.975209e-01 5.211792e-03 ## [31] 1.891602e-03 1.138545e-02 3.015156e-01 2.256255e-02 1.739154e-02 ## [36] 4.913083e-01 2.806451e-03 1.750227e-03 5.301797e-04 8.103536e-02 ## [41] 6.851038e-02 1.065873e-01 2.880473e-02 2.497834e-01 1.792610e-02 ## [46] 1.396916e-01 1.934182e-01 1.204770e-02 1.537823e-01 1.362341e-03 ## [51] 7.276746e-04 1.652994e-02 9.730504e-02 8.291034e-02 1.837382e-02 ## [56] 2.291634e-01 1.953460e-01 4.309721e-03 1.155157e-01 4.745274e-06 ## [61] 5.998460e-03 5.083250e-01 1.244504e-02 2.055462e-01 8.119566e-03 ## [66] 7.182574e-02 3.615991e-02 1.114529e-02 5.767649e-03 1.289269e-02 ## [71] 1.046036e-03 1.584688e-02 4.360582e-02 3.682189e-02 2.098624e-03 ## [76] 4.475879e-02 1.203184e-02 3.395598e-03 5.346499e-01 6.666653e-02 ## [81] 5.493540e-01 2.267225e-02 1.843189e-02 1.223600e-03 3.823594e-01 ## [86] 1.442952e-01 3.191973e-04 9.094346e-05 1.489844e-01 5.811100e-02 ## [91] 1.805454e-02 2.531888e-02 1.723667e-01 3.713810e-01 4.387295e-02 ## [96] 6.107293e-03 1.408935e-01 6.700350e-03 2.073529e-01 3.158986e-03 9.2.6.5 Exercise Can we make this work? x &lt;- list( list(1, c(3, 9)), list(c(3, 6), 7, c(4, 7, 6)) ) triple &lt;- function(x) x * 3 # map(x, map, .f = triple) Specifying .f there replaces the second argument of the top level map function, so you’d be doing map(.x = x, .f = triple, map) which is not what you mean. What you want here is: map_depth(x, 2, triple) ## [[1]] ## [[1]][[1]] ## [1] 3 ## ## [[1]][[2]] ## [1] 9 27 ## ## ## [[2]] ## [[2]][[1]] ## [1] 9 18 ## ## [[2]][[2]] ## [1] 21 ## ## [[2]][[3]] ## [1] 12 21 18 9.4.1 Same type of output as input: modify() When using modify we now get the warning:Warning message:modify()is deprecated as of rlang 0.4.0. Vector tools are now out of scope for rlang to make it a more focused package. How should we rewrite this example? data.frame( x = 1:3, y = 6:4 ) %&gt;% modify( ~ .x * 2) ::: rlang::modify != purrr::modify() 9.4.5 Any number of inputs: pmap() and friends I want to use pmap to map over a vector, but the metadata for the functions other arguments is elsewhere - how would I combine these using pmap? The book says to name the metadata columns the same name as your function which I did but this still doesn’t work? my_data &lt;- 1:3 metadata &lt;- tribble( ~id, ~mult, ~adder, &quot;one&quot;, 2, 5, &quot;two&quot;, 3, 6, &quot;three&quot;, 4, 7 ) the_function &lt;- function(vec, id, mult, adder) { glue::glue(&quot;{id} is now {vec * mult + adder}&quot;) } # my_data doesn&#39;t change but we want to map over the metadata # x = string # y = multiplier # z = adder # pmap(list(metadata), ~the_function(vec = my_data)) pmap(c(list(my_data), metadata), the_function) ## [[1]] ## one is now 7 ## ## [[2]] ## two is now 12 ## ## [[3]] ## three is now 19 9.4.6.2 Exercise I see how we can use iwalk and walk2 for writing to multiple files, but the question asks about disadvantages to this - what would they be? cyls &lt;- split(mtcars, mtcars$cyl) paths &lt;- file.path(temp, paste0(&quot;cyl-&quot;, names(cyls), &quot;.csv&quot;)) walk2(cyls, paths, write.csv) mtcars %&gt;% split(mtcars$cyl) %&gt;% set_names(~ file.path(temp, paste0(&quot;cyl-&quot;, .x, &quot;.csv&quot;))) %&gt;% iwalk(~ write.csv(.x, .y)) A readability problem mostly, as well as implicitly using names(cyls) as opposed to explicitly like it’s used in paths 9.5.4 Multiple inputs Can we think of a simple example for reduce()? A Fibonacci function! n &lt;- 10 purrr::accumulate( .init = c(0L,1L), # Starting with (0,1) rep(0,n), # Accumulate n times ~c(.x,sum(.x))[2:3] # (x,y) -&gt; (x, y, x+y)[2:3] ) %&gt;% purrr::map_int( `[`, 1 ) ## [1] 0 1 1 2 3 5 8 13 21 34 55 9.6.3.2 Exercise I understand that if (length(x) == 1L) return(x[[1L]]) covers the case like simple_reduce(1, +) but what’s the deal with if (length(x) == 0L) return(default) and what exactly is default? simple_reduce &lt;- function(x, f, default) { # when would you use reduce on something length 0? if (length(x) == 0L) return(default) if (length(x) == 1L) return(x[[1L]]) out &lt;- x[[1]] for (i in seq(2, length(x))) { out &lt;- f(out, x[[i]]) } out } Default is the user supplied second number to add by, and we can use integer(0) to work with a length(0) vector. simple_reduce(integer(0), `+`, default = 0L) ## [1] 0 You would want to make sure your reduce is covered in the case of length zero so that your program doesn’t crash when a user passes in an empty vector. 9.7.1 Matrices and arrays How would you tidyverse the rowSums function? x &lt;- tribble( ~x, ~y, 1, 1, 2, 2, 3, 3 ) apply(x, 1, function(x) sum(x&gt;2)) ## [1] 0 0 2 pmap_dbl(x, ~sum(c(...) &gt; 2)) ## [1] 0 0 2 I’m not quite sure what idempotent means but Hadley warns that a2d and a1 aren’t the same, but isn’t that just because we’re using 1 which is row wise, and not 2? What is the warning he is heeding us against here? a2d &lt;- matrix(1:20, nrow = 5) a1 &lt;- apply(a2d, 1, identity) identical(a2d, a1) ## [1] FALSE I think he is just trying to drive home the idea that you might expect no change by apply-ing an operator like identity which leaves its input unchanged, however what it instead returns is the transpose. So perhaps it would have been better to more specifically say that apply(..., MARGIN = 1) isn’t idempotent. 9.7.3.2 Exercise What’s an example of using eapply (iterates over the (named) elements of an environment)? baseenv() %&gt;% eapply(is.primitive) %&gt;% unlist %&gt;% which %&gt;% names Can we come up with an example for rapply allowing us to apply a function to only a specified class? Does something like this exist within purrr? Answer from this community post: 9.0.0.1 rapply x &lt;- list(list(a = as.character(1), b = as.double(2)), c = as.character(3), d = as.double(4)) as_integer_rapply &lt;- function(x) { rapply( x, as.integer, &quot;character&quot;, how = &quot;replace&quot; ) } x %&gt;% as_integer_rapply() %&gt;% str() ## List of 3 ## $ :List of 2 ## ..$ a: int 1 ## ..$ b: num 2 ## $ c: int 3 ## $ d: num 4 9.0.0.2 map as_integer_recursive_map &lt;- function(x) { x %&gt;% map_if(is.character, as.integer) %&gt;% map_if(is.list, as_integer_recursive_map) } x %&gt;% as_integer_recursive_map() %&gt;% str() ## List of 3 ## $ :List of 2 ## ..$ a: int 1 ## ..$ b: num 2 ## $ c: int 3 ## $ d: num 4 9.0.0.3 Comparing the two: microbenchmark::microbenchmark( as_integer_rapply(x), as_integer_recursive_map(x), times = 100 ) ## Unit: microseconds ## expr min lq mean median uq ## as_integer_rapply(x) 9.370 12.418 33.1963 19.0325 20.432 ## as_integer_recursive_map(x) 976.582 1023.532 1121.7016 1056.2270 1148.213 ## max neval ## 1586.717 100 ## 1792.301 100 as_integer_safe &lt;- function(y) { if (is.character(y) &amp;&amp; all(grepl(&quot;^\\\\d+$&quot;, y))) { as.integer(y) } else { y } } x[[1]][[3]] &lt;- &quot;dog&quot; rapply(x, f = as_integer_safe, how = &quot;replace&quot;) ## [[1]] ## [[1]]$a ## [1] 1 ## ## [[1]]$b ## [1] 2 ## ## [[1]][[3]] ## [1] &quot;dog&quot; ## ## ## $c ## [1] 3 ## ## $d ## [1] 4 "],
["function-factories.html", "Chapter 10 Function factories 10.2 Factory fundamentals 10.2.3 Forcing evaluation 10.1 WITHOUT FORCE 10.2.5 garbage collection 10.2.6.2 Exercise 10.2.6.3 Exercise 10.3.1 Labelling 10.3.4 Exercises 10.2 10.5 factories and functionals", " Chapter 10 Function factories 10.2 Factory fundamentals Let’s really solidify this statement in our own words using the power1 and square/cube example: The enclosing environment of the manufactured function is an execution environment of the function factory. enclosing environment (this is the function environment - like square and cube) [in red] execution environment (this is the same environment as above but from the “perspective” of power1) [in green] square and cube have their own enclosing environments where x is different for each function - but their parent, the environment of power1, is the same. Because power1 is a function, it has its own execution environment which is usually ephemeral but in this case it is the environment of both square and cube – and that is how the manufactured functions have access to exp. 10.2.3 Forcing evaluation I think this force section is trying to convey how we should use force on every argument in the factory’s execution environment (here just exp) because you want to avoid lazy eval in the manufactured function’s enclosing environment (like how we want to force(exp = 2) for square) but how does it not just become force(exp = 3) when we set x &lt;- 3? 10.1 WITHOUT FORCE Without force, exp doesn’t get evaluated when power is called. square is a promise to create a function to raise its input to the exp’th power. Once square is called, the promise evaluates, and square becomes a function to raise its input to whatever exp was that first time square was called. That’s what makes it dangerous; what square does depends on the order in which things are called. Dangers and confusions like this are part of why function factories don’t get used that much, despite the fact that they’re really quite cool. suppressMessages(requireNamespace(&quot;pryr&quot;)) # make sure this isn&#39;t already defined rm(x) power2 &lt;- function(exp) { cat(paste0(&quot;outer execution environment: &quot;, capture.output(environment()), &quot;\\n&quot;)) cat(paste0(&quot;outer enclosure: &quot;, capture.output(parent.env(environment())), &quot;\\n&quot;)) cat(paste0(&quot;exp promise info: \\n&quot;, paste0(&quot;\\t&quot;, capture.output(pryr::promise_info(exp)), collapse = &quot;\\n&quot;))) out &lt;- function(x_) { cat(paste0(&quot;inner execution environment: &quot;, capture.output(environment()), &quot;\\n&quot;)) cat(paste0(&quot;inner enclosure: &quot;, capture.output(parent.env(environment())), &quot;\\n&quot;)) cat(paste0(&quot;exp promise info: \\n&quot;, paste0(&quot;\\t&quot;, capture.output(pryr::promise_info(exp)), collapse = &quot;\\n&quot;))) x_ ^ exp } } square &lt;- power2(x) #&gt; outer execution environment: &lt;environment: 0x0000000015812568&gt; #&gt; outer enclosure: &lt;environment: R_GlobalEnv&gt; #&gt; exp promise info: #&gt; $code #&gt; x #&gt; #&gt; $env #&gt; &lt;environment: R_GlobalEnv&gt; #&gt; #&gt; $evaled #&gt; [1] FALSE #&gt; #&gt; $value #&gt; NULL #&gt; square(4) #&gt; inner execution environment: &lt;environment: 0x0000000012aee2a8&gt; #&gt; inner enclosure: &lt;environment: 0x0000000015812568&gt; #&gt; exp promise info: #&gt; $code #&gt; x #&gt; #&gt; $env #&gt; &lt;environment: R_GlobalEnv&gt; #&gt; #&gt; $evaled #&gt; [1] FALSE #&gt; #&gt; $value #&gt; NULL #&gt; #&gt; Error in square(4): object &#39;x&#39; not found The exp promise is looking for x in the enclosure of power2 (global) and can’t find it. x &lt;- 2 square(4) #&gt; inner execution environment: &lt;environment: 0x0000000017c915d0&gt; #&gt; inner enclosure: &lt;environment: 0x0000000015812568&gt; #&gt; exp promise info: #&gt; $code #&gt; x #&gt; #&gt; $env #&gt; &lt;environment: R_GlobalEnv&gt; #&gt; #&gt; $evaled #&gt; [1] FALSE #&gt; #&gt; $value #&gt; NULL #&gt; #&gt; Warning in square(4): restarting interrupted promise evaluation #&gt; [1] 16 Notice, that the exp promise still wasn’t evaled until the last line, x_ ^ exp. The warning is caused by our previous failed attempt to evaluate the promise. x &lt;- 3 square(5) #&gt; inner execution environment: &lt;environment: 0x0000000017d9b270&gt; #&gt; inner enclosure: &lt;environment: 0x0000000015812568&gt; #&gt; exp promise info: #&gt; $code #&gt; x #&gt; #&gt; $env #&gt; NULL #&gt; #&gt; $evaled #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] 2 #&gt; #&gt; [1] 25 # exp was evaled already, so no further warning is produced, and our change to x has no effect. rm(x) square &lt;- power2(x) #&gt; outer execution environment: &lt;environment: 0x0000000017e96e78&gt; #&gt; outer enclosure: &lt;environment: R_GlobalEnv&gt; #&gt; exp promise info: #&gt; $code #&gt; x #&gt; #&gt; $env #&gt; &lt;environment: R_GlobalEnv&gt; #&gt; #&gt; $evaled #&gt; [1] FALSE #&gt; #&gt; $value #&gt; NULL #&gt; environment(square)$x &lt;- 2 square(6) #&gt; inner execution environment: &lt;environment: 0x0000000017f8a530&gt; #&gt; inner enclosure: &lt;environment: 0x0000000017e96e78&gt; #&gt; exp promise info: #&gt; $code #&gt; x #&gt; #&gt; $env #&gt; &lt;environment: R_GlobalEnv&gt; #&gt; #&gt; $evaled #&gt; [1] FALSE #&gt; #&gt; $value #&gt; NULL #&gt; #&gt; Error in square(6): object &#39;x&#39; not found Defining x in the function environment doesn’t work, because the promise isn’t looking for x there power2 &lt;- function(exp) function(x_) x_ ^ exp # wasn&#39;t sure this would work without braces...neat square &lt;- power2(x) environment(square)$exp &lt;- 2 square(6) [1] 36 square &lt;- power2(x) exp &lt;- 2 square(6) Error in square(6): object &#39;x&#39; not found This doesn’t work because we need to define x within environment(power2)$exp &lt;- 2 10.1.1 USING FORCE rm(exp) rm(x, power2, square) power2 &lt;- function(exp) { cat(paste0(&quot;outer execution environment: &quot;, capture.output(environment()), &quot;\\n&quot;)) cat(paste0(&quot;outer enclosure: &quot;, capture.output(parent.env(environment())), &quot;\\n&quot;)) cat(paste0(&quot;exp promise info before: \\n&quot;, paste0(&quot;\\t&quot;, capture.output(pryr::promise_info(exp)), collapse = &quot;\\n&quot;))) force(exp) cat(paste0(&quot;exp promise info after: \\n&quot;, paste0(&quot;\\t&quot;, capture.output(pryr::promise_info(exp)), collapse = &quot;\\n&quot;))) out &lt;- function(x_) { cat(paste0(&quot;inner execution environment: &quot;, capture.output(environment()), &quot;\\n&quot;)) cat(paste0(&quot;inner enclosure: &quot;, capture.output(parent.env(environment())), &quot;\\n&quot;)) cat(paste0(&quot;exp promise info: \\n&quot;, paste0(&quot;\\t&quot;, capture.output(pryr::promise_info(exp)), collapse = &quot;\\n&quot;))) x_ ^ exp } } square &lt;- power2(x) #&gt; outer execution environment: &lt;environment: 0x00000000184e4e90&gt; #&gt; outer enclosure: &lt;environment: R_GlobalEnv&gt; #&gt; exp promise info before: #&gt; $code #&gt; x #&gt; #&gt; $env #&gt; &lt;environment: R_GlobalEnv&gt; #&gt; #&gt; $evaled #&gt; [1] FALSE #&gt; #&gt; $value #&gt; NULL #&gt; #&gt; Error in force(exp): object &#39;x&#39; not found # error because x isn&#39;t defined x &lt;- 2 square &lt;- power2(x) #&gt; outer execution environment: &lt;environment: 0x0000000018cafaf8&gt; #&gt; outer enclosure: &lt;environment: R_GlobalEnv&gt; #&gt; exp promise info before: #&gt; $code #&gt; x #&gt; #&gt; $env #&gt; &lt;environment: R_GlobalEnv&gt; #&gt; #&gt; $evaled #&gt; [1] FALSE #&gt; #&gt; $value #&gt; NULL #&gt; exp promise info after: #&gt; $code #&gt; x #&gt; #&gt; $env #&gt; NULL #&gt; #&gt; $evaled #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] 2 #&gt; square(4) #&gt; inner execution environment: &lt;environment: 0x0000000018d55b48&gt; #&gt; inner enclosure: &lt;environment: 0x0000000018cafaf8&gt; #&gt; exp promise info: #&gt; $code #&gt; x #&gt; #&gt; $env #&gt; NULL #&gt; #&gt; $evaled #&gt; [1] TRUE #&gt; #&gt; $value #&gt; [1] 2 #&gt; #&gt; [1] 16 x &lt;- 3 square(4) 10.2.5 garbage collection Does {factory} handle the issue of temporary objects in the manufactured function not getting garbage collected? We don’t need to use rm because the execution environment of the factory remains ephemeral (like any other function call).Rather than returning a function wrapped in the execution environment, it returns a function in the caller environment, allowing normal garbage collection to clean up the temporary objects created during creation of the manufactured functions. 10.2.6.2 Exercise Base R contains two function factories, approxfun() and ecdf(). Read their documentation and experiment to figure out what the functions do and what they return. approxfun approxfun creates a function (i.e. mathematical formula) that can be used to find the linear interpolation for any given point, based on the data that was passed into the factory-function at the time it was passed into the function dat &lt;- data.frame(x=1:10, y=(1:10)^2) dat ## x y ## 1 1 1 ## 2 2 4 ## 3 3 9 ## 4 4 16 ## 5 5 25 ## 6 6 36 ## 7 7 49 ## 8 8 64 ## 9 9 81 ## 10 10 100 fn &lt;- approxfun(dat$x,dat$y) fn(4.5) ## [1] 20.5 x &lt;- 1:10 y &lt;- rnorm(10) plot(x, y, main = &quot;approx(.) and approxfun(.)&quot;) points(approx(x, y), col = 2, pch = &quot;*&quot;) points(approx(x, y, method = &quot;constant&quot;), col = 4, pch = &quot;*&quot;) ECDF x &lt;- rnorm(3) # 3 random numbers Fn &lt;- ecdf(x) # create distribution function for each x Fn(x) # apply the distribution function to each number ## [1] 0.3333333 1.0000000 0.6666667 10.2.6.3 Exercise How would we make this function using {factory} pick &lt;- function(i) { force(i) function(x) x[[i]] } library(factory) pick &lt;- build_factory( .factory_fun = function(x) x[[i]], i ) 10.3.1 Labelling What is the “factory” happening here? That we’re supplying a function as the label argument? Is summarize also a factory then? It isn’t that the ggplot2 functions are factories, it’s that they’re a great place to use factories. They’re actually functionals when you pass in a function, since they’re using a function as an argument! 10.3.4 Exercises Can we use code to answer the question: compare and contrast ggplot2::label_bquote() with scales::number_format() Data: sd &lt;- c(1, 5, 15) n &lt;- 100 df &lt;- data.frame(x = rnorm(3 * n, sd = sd), sd = rep(sd, n)) Using label_bquote using plotMath explanation…… ggplot(df, aes(x)) + geom_histogram(binwidth = 2) + facet_wrap(~ sd, scales = &quot;free_x&quot;, labeller = label_bquote(alpha ^ .(sd))) + labs(x = NULL) Using number_format will force the computation of the parameters, formatting numbers explanation…… ggplot(df, aes(x)) + geom_histogram(binwidth = 2) + facet_wrap(~ sd, scales = &quot;free_x&quot;) + labs(x = NULL) + scale_y_continuous( labels = scales::number_format(scale = 1, suffix = &quot; K&quot;) ) 10.2 10.5 factories and functionals Can we {factory} this? names &lt;- list( square = 2, cube = 3, root = 1/2, cuberoot = 1/3, reciprocal = -1 ) funs &lt;- purrr::map(names, power1) power4 &lt;- build_factory( fun = function(x) { x ^ exponent }, exponent ) power_names &lt;- list( square = 2, cube = 3, root = 1/2, cuberoot = 1/3, reciprocal = -1 ) powers &lt;- purrr::map(power_names, power4) "],
["function-operators.html", "Chapter 11 Function operators 11.1 Introduction 11.2.1 purrr::safely 11.2.2 memoise 11.2.3.1 Exercises", " Chapter 11 Function operators 11.1 Introduction A function operator is a function that takes one (or more) functions as input and returns a function as output …How exactly does this definition differ from a function factory? html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #wmfzeacuvh .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #wmfzeacuvh .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #wmfzeacuvh .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #wmfzeacuvh .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #wmfzeacuvh .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #wmfzeacuvh .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #wmfzeacuvh .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #wmfzeacuvh .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #wmfzeacuvh .gt_column_spanner_outer:first-child { padding-left: 0; } #wmfzeacuvh .gt_column_spanner_outer:last-child { padding-right: 0; } #wmfzeacuvh .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #wmfzeacuvh .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #wmfzeacuvh .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #wmfzeacuvh .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #wmfzeacuvh .gt_from_md > :first-child { margin-top: 0; } #wmfzeacuvh .gt_from_md > :last-child { margin-bottom: 0; } #wmfzeacuvh .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #wmfzeacuvh .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #wmfzeacuvh .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #wmfzeacuvh .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #wmfzeacuvh .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #wmfzeacuvh .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #wmfzeacuvh .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #wmfzeacuvh .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #wmfzeacuvh .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #wmfzeacuvh .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #wmfzeacuvh .gt_sourcenote { font-size: 90%; padding: 4px; } #wmfzeacuvh .gt_left { text-align: left; } #wmfzeacuvh .gt_center { text-align: center; } #wmfzeacuvh .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #wmfzeacuvh .gt_font_normal { font-weight: normal; } #wmfzeacuvh .gt_font_bold { font-weight: bold; } #wmfzeacuvh .gt_font_italic { font-style: italic; } #wmfzeacuvh .gt_super { font-size: 65%; } #wmfzeacuvh .gt_footnote_marks { font-style: italic; font-size: 65%; } Term Required Input Optional Output Output Functionals Function Vector Vector Function Factory NA Vector,Function Function Function Operator Function Function Function Function operators are closely related to function factories; indeed they’re just a function factory that takes a function as input Can anyone confirm that, by definition, function operators can only take functions as inputs (and not any kind of vector)? Book quote: “A function operator is a function that takes one (or more) functions as input and returns a function as output.” If this is true, then something like the following would only be a function factory, not both a function factory and a function operator: sleepy &lt;- function(f, n){ force(f) function(...){ cat( glue::glue(&#39;Sleeping for {n} second{ifelse(n != 1, &quot;s&quot;, &quot;&quot;)}.&#39;), sep = &#39;\\n&#39; ) Sys.sleep(n) f(...) } } sleepy_print &lt;- sleepy(print, 1.5) sleepy_print(&#39;hello world&#39;) ## Sleeping for 1.5 seconds. ## [1] &quot;hello world&quot; Function factories are “any function that returns a function” and Hadley uses “simple” examples where you pass in a numeric or character to get back a customized function (pass a number to a power function to get a function dedicated to cubes) Function operators are factories where you pass in a function and modify its behaviour a little, without actually building up the logic for a function from scratch. The operator does not supply the actual meat of the logic. examples: safely, silently, rate-limity etc 11.2.1 purrr::safely It seems like safely is a condition wrapper - are all conditions a kind of function operator? safely/possibly/quietly are function operators that are condition-wrappers, but tryCatch/withCallingHandlers are not function operators (they catch the outputs and do X thing but don’t actually return a function) How would we apply safely to find which dataframe in a list of dataframes is causing an error? library(tidyverse) random_starwars &lt;- function() { starwars %&gt;% sample_n(50) %&gt;% select(name, height,mass) } broken_starwars &lt;- function(){ starwars %&gt;% sample_n(50) %&gt;% select(name, height,mass) %&gt;% mutate(height = as.character(height)) } list_data &lt;- list(a = random_starwars(), b = random_starwars(), c = broken_starwars(), d = random_starwars()) map_dfr_safely &lt;- function(.x, .f, ... ) { results &lt;- map(.x, safely(.f), ...) list(result = bind_rows(!!!map(results, &quot;result&quot;)), error = map(results, &quot;error&quot;)) } map_dfr_safely(list_data, semi_join, filter_starwars, by = c(&quot;name&quot;, &quot;height&quot;)) ## Warning in is.data.frame(y): restarting interrupted promise evaluation ## Warning in is.data.frame(y): restarting interrupted promise evaluation ## Warning in is.data.frame(y): restarting interrupted promise evaluation ## $result ## data frame with 0 columns and 0 rows ## ## $error ## $error$a ## &lt;simpleError in is.data.frame(y): object &#39;filter_starwars&#39; not found&gt; ## ## $error$b ## &lt;simpleError in is.data.frame(y): object &#39;filter_starwars&#39; not found&gt; ## ## $error$c ## &lt;simpleError in is.data.frame(y): object &#39;filter_starwars&#39; not found&gt; ## ## $error$d ## &lt;simpleError in is.data.frame(y): object &#39;filter_starwars&#39; not found&gt; 11.2.2 memoise How do you check how much memory is allocated to memoise’s caching? random_starwars &lt;- function(...){ starwars %&gt;% sample_n(3) %&gt;% select(name)} memoised_starwars &lt;- memoise(random_starwars) a &lt;- random_starwars() b &lt;- memoised_starwars(1) c &lt;- memoised_starwars(2) d &lt;- memoised_starwars(3) lobstr::obj_size(get(&quot;_cache&quot;,environment(memoised_starwars))) ## 16,256 B Could we create a memoise wrapper that clears the cache when that’s a certain number? random_starwars &lt;- function(...){ dplyr::starwars %&gt;% dplyr::sample_n(3) %&gt;% dplyr::select(name) } cache_memory_size &lt;- function(f) { cache &lt;- get(&quot;_cache&quot;, environment(f)) lobstr::obj_size(cache) } capped_memoise &lt;- function(..., .cache_size) { force(.cache_size) .self_ref &lt;- memoise::memoise(...) f &lt;- function(...) { env &lt;- parent.env(environment()) cache_size &lt;- cache_memory_size(env[[&quot;_self_ref&quot;]]) if (cache_size &gt; env[[&quot;_cache_size&quot;]]) { message(paste0(&quot;Clearing cache [@&quot;,cache_size,&quot;]\\n&quot;)) memoise::forget(env[[&quot;_self_ref&quot;]]) } env[[&quot;_self_ref&quot;]](...) } assign(&quot;_cache_size&quot;, .cache_size, environment(.self_ref)) assign(&quot;_self_ref&quot;, .self_ref, environment(.self_ref)) environment(f) &lt;- environment(.self_ref) f } capped_memoised_starwars &lt;- capped_memoise(random_starwars, .cache_size = 30000) for (i in 1:100) { capped_memoised_starwars(i) print(cache_memory_size(capped_memoised_starwars)) } ## 14,432 B ## 15,320 B ## 16,152 B ## 17,048 B ## 17,944 B ## 18,856 B ## 19,712 B ## 20,568 B ## 21,400 B ## 22,312 B ## 23,168 B ## 24,088 B ## 24,976 B ## 25,808 B ## 26,712 B ## 27,544 B ## 28,256 B ## 29,032 B ## 29,808 B ## 30,640 B ## Clearing cache [@30640] ## 14,456 B ## 15,344 B ## 16,184 B ## 17,072 B ## 17,976 B ## 18,808 B ## 19,640 B ## 20,416 B ## 21,248 B ## 22,080 B ## 22,920 B ## 23,776 B ## 24,688 B ## 25,456 B ## 26,224 B ## 26,992 B ## 27,888 B ## 28,792 B ## 29,568 B ## 30,408 B ## Clearing cache [@30408] ## 14,432 B ## 15,328 B ## 16,224 B ## 17,136 B ## 18,032 B ## 18,808 B ## 19,688 B ## 20,456 B ## 21,360 B ## 22,200 B ## 23,120 B ## 24,040 B ## 24,816 B ## 25,656 B ## 26,568 B ## 27,344 B ## 28,120 B ## 28,896 B ## 29,672 B ## 30,440 B ## Clearing cache [@30440] ## 14,432 B ## 15,328 B ## 16,232 B ## 17,128 B ## 17,960 B ## 18,800 B ## 19,696 B ## 20,592 B ## 21,464 B ## 22,320 B ## 23,096 B ## 23,952 B ## 24,808 B ## 25,584 B ## 26,456 B ## 27,232 B ## 28,064 B ## 28,896 B ## 29,664 B ## 30,496 B ## Clearing cache [@30496] ## 14,448 B ## 15,344 B ## 16,248 B ## 17,088 B ## 17,864 B ## 18,768 B ## 19,600 B ## 20,456 B ## 21,288 B ## 22,184 B ## 23,024 B ## 23,856 B ## 24,696 B ## 25,528 B ## 26,320 B ## 27,224 B ## 28,080 B ## 28,856 B ## 29,752 B ## 30,584 B Can we come up with simple example for these function operators? x &lt;- list( c(0.512, 0.165, 0.717), c(0.064, 0.781, 0.427), c(0.890, 0.785, 0.495), &quot;oops&quot; ) f &lt;- function(...) {sum(...)} possibly map_dbl(x, possibly(f, NA)) ## [1] 1.394 1.272 2.170 NA quietly Quetly doesn’t work on errors, only warnings: map(x, quietly(function(x) tryCatch(f(x), error = function(e) warning(e))) auto_browser map_dbl(x, auto_browse(f)) 11.2.3.1 Exercises Vectorize() provides a convenient and concise notation to iterate over multiple arguments, but has some major drawbacks that mean you generally shouldn’t use it. What are these drawbacks the solution manual is referring to? 11.0.0.1 Dean’s Way library(tidyverse) patient_name &lt;- function(path) { path_list &lt;- str_split(path, &quot;/&quot;) %&gt;% unlist() paste(path_list[length(path_list) - 1], path_list[length(path_list)], sep = &quot;_&quot;) } # Vectorize it with Vectorize patient_name_v &lt;- Vectorize(patient_name) patient_name_v(path = c(&quot;some/path/abc/001.txt&quot;, &quot;another/directory/xyz/002.txt&quot;)) ## some/path/abc/001.txt another/directory/xyz/002.txt ## &quot;abc_001.txt&quot; &quot;xyz_002.txt&quot; 11.0.0.2 Jim’s Way patient_name_best &lt;- function(path) { paste0(basename(dirname(path)), &quot;_&quot;, basename(path)) } SIMPLIFY logical or character string; attempt to reduce the result to a vector, matrix or higher dimensional array; see the simplify argument of sapply. This means the type of the function output depends on the input. patient_name_v(&quot;some/path/abc/001.txt&quot;) ## some/path/abc/001.txt ## &quot;abc_001.txt&quot; patient_name_v(character()) ## named list() patient_name_v(NULL) ## list() Vectorize does not generate functions with easily inspect-able code Vectorize functions use do.call(), which can have unexpected performance consequences Vectorize does not actually make your code execute faster "],
["base-types.html", "Chapter 12 Base Types Introduction 12.3 Base types", " Chapter 12 Base Types Introduction encapsulation: the user doesn’t need to worry about details of an object because they are encapsulated behind a standard interface. What is meant here by encapsulation? Random forests, glm, neural nets are implemented differently internally. But to predict the class for a new sample based on a fitted model, you just use the ‘predict’ generic. You don’t need to know how prediction is performed, just that ‘predict(my_fit)’ makes it happen This makes [RC] harder to reason about, but allows them to solve problems that are difficult to solve in the functional OOP style of S3 and S4. Maybe this question is better answered when we finish this section but what are these scenarios in which RC is a better choice than S3 and S4? 12.3 Base types What is a symbol? How is this different from a character? typeof(quote(a)) ## [1] &quot;symbol&quot; symbol is the difference between: &quot;a&quot; and a. One is a string and the other represents an object in the environment. A quoted object is not the same as a string "],
["s3.html", "Chapter 13 S3 13.2 Basics 13.3 Classes 13.3.4.3 Exercises 13.3.4.4 Exercises 13.4.1 Generics 13.4.4.5 Exercises 13.5 Object styles 13.6 Inheritance 13.4.3.3 Exercises 13.7.1 S3 and Base Types 13.7.3 Internal Generics 13.7.4 Double Dispatch", " Chapter 13 S3 13.2 Basics What’s a real use case for unclass? I wanted to pass a paletteer palette to leaflet::colorNumeric which ends up calling the S3 method leaflet:::toPaletteFunc but that only has methods defined for character function and matrix . The paletteer output is a character vector with class color and so colorNumeric(palette, domain) failed. Simple solution: colorNumeric(unclass(palette), domain) 13.3 Classes Can we come up with a simple example for a constructor, validator, and helper? IPA Constructor Create the custom class new_ipa &lt;- function(x = double()) { structure(x, class = &quot;ipa&quot;) } IPA Validator Function to make sure you can use your custom class validate_ipa &lt;- function(x = double()) { stopifnot(is.numeric(x)) # has to be at least 15 bitterness stopifnot(x &gt;= 15) x } IPA Helper Calls both the validator and the constructor ipa &lt;- function(x) { x &lt;- as.numeric(x) # Both helper and valditor x &lt;- new_ipa(x) res &lt;- validate_ipa(x) res } 13.0.0.1 Test it out! Fails as expected: ipa(5) Error in validate_ipa(x) : x &gt;= 15 is not TRUE But this works! ipa(50) ## [1] 50 ## attr(,&quot;class&quot;) ## [1] &quot;ipa&quot; 13.3.4.3 Exercises Can we go over the factor source code, commenting it line for line? # using the example: x &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;one&quot;) factor &lt;- function (x = character(), levels, labels = levels, exclude = NA, ordered = is.ordered(x), nmax = NA) { # if character vector is null set to character() if (is.null(x)) x &lt;- character() # nx - names of x # in our case NULL nx &lt;- names(x) # we didn&#39;t supply levels so it&#39;s missing if (missing(levels)) { # set y to the unique names found in the vector # nmax by default is NA but this is an argument # for unique setting the max number of unique values y &lt;- unique(x, nmax = nmax) # get the order of the unique values # defaults to alphabetical ind &lt;- order(y) # put our vector in order using only unique values levels &lt;- unique(as.character(y)[ind]) } # because the function arg is a promise # we need to eval now to use it? I think? force(ordered) # FALSE # if x isn&#39;t a character string make it one if (!is.character(x)) x &lt;- as.character(x) # match the number of levels with NAs # then if they are NA it will resolve to TRUE # only return the TRUE levels # this is how we get rid of NAs! levels &lt;- levels[is.na(match(levels, exclude))] # get the ordered levels f &lt;- match(x, levels) # if the names aren&#39;t null give f those names if (!is.null(nx)) names(f) &lt;- nx # if missing levels make levels back into a character string? # why? if (missing(labels)) { levels(f) &lt;- as.character(levels) } # otherwise get the legenth of your labels # if its the same as the levels else { nlab &lt;- length(labels) if (nlab == length(levels)) { # xlevls is labels as character # then we get the unique values of that # and set that to xlevs nlevs &lt;- unique(xlevs &lt;- as.character(labels)) # this is null at &lt;- attributes(f) # attr levels at$levels &lt;- nlevs # match the levels with ordered levels # and put the levels back in numeric order? # I think? f &lt;- match(xlevs, nlevs)[f] # now set the attributes to the numeric levels attributes(f) &lt;- at } # if you only have one lavel else if (nlab == 1L) # add numerics to the end of the label? levels(f) &lt;- paste0(labels, seq_along(levels)) # otherwise invalid length else stop(gettextf(&quot;invalid &#39;labels&#39;; length %d should be 1 or %d&quot;, nlab, length(levels)), domain = NA) } # add ordered and factor to f&#39;s class list class(f) &lt;- c(if (ordered) &quot;ordered&quot;, &quot;factor&quot;) f } factor(x) 13.3.4.4 Exercises Now that we’ve gone through the source code, I don’t see where the contrasts attibute comes into play? We can look at the C() function but where is this used within factor()? It is a little misleading to say that factors “have an … attribute”, where I really think he means that “some functions might check if that attribute has been assigned”. Make a factor: f &lt;- factor(c(1,2)) f ## [1] 1 2 ## Levels: 1 2 Set contrasts attribute: f &lt;- C(f) f ## [1] 1 2 ## attr(,&quot;contrasts&quot;) ## unordered ## contr.treatment ## Levels: 1 2 f &lt;- factor(f) f ## [1] 1 2 ## Levels: 1 2 dang’t where did those contrasts go! 13.4.1 Generics In the example: my_new_generic &lt;- function(x) { UseMethod(&quot;my_new_generic&quot;) } The book states: “If you wonder why we have to repeat my_new_generic twice, think back to Section 6.2.3” Can we go over why? I think he’s referring to the fact that you have to use a string representation inside the UseMethod call. I’m guessing part of the answer to this is baked into this warning on the UseMethod function docs: Warning: Prior to R 2.1.0 UseMethod accepted a call with no arguments and tried to deduce the generic from the context. Basically, you’re specifying the name of the function and then telling R to go find this generic function’s methods. You can’t self-reference the name of the generic after it’s been assigned to itself? Maybe the name doesn’t exist! test.default &lt;- function() { &quot;test&quot; } # not sure why you would want to do this, but you can (function() { UseMethod(&quot;test&quot;) })() ## [1] &quot;test&quot; Also because you might have assigned your generic to a new name, how would it know to use the true “generic” name. superuglygenericfunction &lt;- function() { UseMethod(&quot;superuglygenericfunction&quot;) } superuglygenericfunction.default &lt;- function() { &quot;ugh&quot; } nice &lt;- function() { UseMethod(&quot;superuglygenericfunction&quot;) } nice() ## [1] &quot;ugh&quot; #&gt; [1] &quot;ugh&quot; 13.4.4.5 Exercises Can we explain what’s happening here in our own words I was a little confused with the solutions manual? g(x) uses 1 from the .default method but 10 from the generic? Why? g &lt;- function(x) { x &lt;- 10 y &lt;- 10 UseMethod(&quot;g&quot;) } g.default &lt;- function(x) c(x = x, y = y) x &lt;- 1 y &lt;- 1 g(x) x y 1 10 UseMethod creates a new function call with arguments matched as they came in to the generic. Any local variables defined before the call to UseMethod are retained (unlike S). When you call g(x) even though you appear to be ignoring it in your definition of g and assigning x &lt;- 10, when you call UseMethod it will basically match the x in the g.default formals to the x that was passed in. The y isn’t matched to any argument and is retained. Tyler Grant Smith:m: 13 minutes ago r g &lt;- function(x) { x &lt;- 10 y &lt;- 10 UseMethod(“g”) } g.default &lt;- function(x = NULL) c(x = x, y = y) x &lt;- 1 y &lt;- 1 # this is interesting behavior g() #&gt; y #&gt; 10 g(x) #&gt; x y #&gt; 1 10 13.5 Object styles Unfortunately, describing the appropriate use of each of these object styles is beyond the scope of this book. Can we use the vctrs package in a concrete example to address some of these fringe cases and reasons why length(x) is causing an issue? An object style is a pattern for structuring your class. You can use any structure you want but these 4 patterns get used very often. Date and factor are both vector style for example: the core data for objects of both types are stored in a single vector. And there are some other context-appropriate things denoted by attributes in each case. I don’t think length is an issue but when you move away from the vanilla vector style object then the meaning changes. For example, under the hood, a data frame is really a list of vectors. Each of the vectors (columns) has the same length. So if you take the length of a data frame you get the length of the list i.e. the number of columns. length(mtcars) ## [1] 11 The result of calling length on a data.frame isn’t necessarily intuitive: most people would probably say that the number of rows is a more natural value for the length of a data frame. This is the same for dates: which are actually of length 3 when classes and 9 when unclassed. x &lt;- as.POSIXlt(ISOdatetime(2020, 1, 1, 0, 0, 1:3)) length(x) ## [1] 3 length(unclass(x)) ## [1] 11 13.6 Inheritance Can we make our own example of a method with inheritance? Creating an IBU calculator for beer, we can use the .ipa method for a beer of class .wipa: library(sloop) # IBUs are calculated as onces x alpha acid x boil time / constant # we&#39;re going to use a different constant for IPAs and Stouts # generic IBU_calculator &lt;- function(x) { UseMethod(&quot;IBU_calculator&quot;) } # default IBU_calculator.default &lt;- function(x){ stop(&quot;Can only calculate IBU for beers, not &quot;,class(x)) } # ipa IBU_calculator.ipa &lt;- function(x) { 1 * x * 30 / 7.25 } # stout IBU_calculator.stout &lt;- function(x) { 1.5 * x * 30 / 6 } #### some beers #### ipa_1 &lt;- structure( 15, class = c(&quot;ipa&quot;,&quot;beer&quot;) ) # define a wine to see default dispatch wine_1 &lt;- structure(3,class = c(&quot;pinot&quot;,&quot;wine&quot;)) # wipa &quot;inherits&quot; class ipa so we can use that method! wipa_1 &lt;- structure(20, class = c(&quot;wipa&quot;,&quot;ipa&quot;,&quot;beer&quot;)) s3_dispatch(IBU_calculator(ipa_1)) ## =&gt; IBU_calculator.ipa ## IBU_calculator.beer ## * IBU_calculator.default s3_dispatch(IBU_calculator(wipa_1)) ## IBU_calculator.wipa ## =&gt; IBU_calculator.ipa ## IBU_calculator.beer ## * IBU_calculator.default s3_dispatch(IBU_calculator(wine_1)) ## IBU_calculator.pinot ## IBU_calculator.wine ## =&gt; IBU_calculator.default 13.4.3.3 Exercises Can we go over why this doesn’t return a1? generic2 &lt;- function(x) UseMethod(&quot;generic2&quot;) generic2.a1 &lt;- function(x) &quot;a1&quot; generic2.a2 &lt;- function(x) &quot;a2&quot; generic2.b &lt;- function(x) { class(x) &lt;- &quot;a1&quot; NextMethod() } generic2(structure(list(), class = c(&quot;b&quot;, &quot;a2&quot;))) [1] &quot;a2&quot; generic2 &lt;- function(x) UseMethod(&quot;generic2&quot;) generic2.a1 &lt;- function(x) { cat(&quot;generic2.a1\\n&quot;); cat(class(x)) } generic2.a2 &lt;- function(x) { cat(&quot;generic2.a2\\n&quot;); cat(class(x)) } generic2.b &lt;- function(x) { cat(&quot;generic2.b\\n&quot;) cat(&quot;Regardless of what we do, NextMethod will search for the following&quot;, &quot;classes:\\n&quot;, paste0(.Class, collapse = &quot;, &quot;), &quot;\\n&quot;) class(x) &lt;- &quot;a1&quot; NextMethod() } x &lt;- structure(1:1e8, class = c(&quot;b&quot;, &quot;a2&quot;)) generic2(x) ## generic2.b ## Regardless of what we do, NextMethod will search for the following classes: ## b, a2 ## generic2.a2 ## a1 13.7.1 S3 and Base Types WHY isn’t the dispatch of mean(x1) determined by its type??? x1 &lt;- 1:5 class(x1) [1] &quot;integer&quot; s3_dispatch(mean(x1)) mean.integer mean.numeric =&gt; mean.default methods(mean) ## [1] mean.Date mean.default mean.difftime mean.POSIXct mean.POSIXlt ## [6] mean.quosure* ## see &#39;?methods&#39; for accessing help and source code mean doesn’t actually have a specific method defined in base R for int or numeric. the default method handles all base types, type checking along the way: mean.default ## function (x, trim = 0, na.rm = FALSE, ...) ## { ## if (!is.numeric(x) &amp;&amp; !is.complex(x) &amp;&amp; !is.logical(x)) { ## warning(&quot;argument is not numeric or logical: returning NA&quot;) ## return(NA_real_) ## } ## if (na.rm) ## x &lt;- x[!is.na(x)] ## if (!is.numeric(trim) || length(trim) != 1L) ## stop(&quot;&#39;trim&#39; must be numeric of length one&quot;) ## n &lt;- length(x) ## if (trim &gt; 0 &amp;&amp; n) { ## if (is.complex(x)) ## stop(&quot;trimmed means are not defined for complex data&quot;) ## if (anyNA(x)) ## return(NA_real_) ## if (trim &gt;= 0.5) ## return(stats::median(x, na.rm = FALSE)) ## lo &lt;- floor(n * trim) + 1 ## hi &lt;- n + 1 - lo ## x &lt;- sort.int(x, partial = unique(c(lo, hi)))[lo:hi] ## } ## .Internal(mean(x)) ## } ## &lt;bytecode: 0x7fc74294ab70&gt; ## &lt;environment: namespace:base&gt; 13.7.3 Internal Generics Defining a single group generic for your class overrides the default behaviour for all of the members of the group. Does this mean that if I define abs for my class it overrides the behaviour of sign, sqrt and all the others in the Math group? Essentially, these are all (loosely) math-related functions, so R understands how to do these for anything it can understand as a numeric (somehow). If you’re adding a class that isn’t handled in one of these numeric-ish ways, you’ll need to tell R how to handle the mathematics. You can’t make a group like “Math”, “Ops”, “Summary”, or “Complex” and expect R to know what it’s doing. If you define abs for your class it won’t know how to do the other things. Suppose you defined your own min.POSIXct then when you call min(Sys.time()) it will encounter your function, evaluate, and then that is the end. Otherwise, min would call the min Primitive which is implemented in C as found here and if you trace through that you will see that is where the GroupDispatch is called. 13.7.4 Double Dispatch What is happening here: Ops.foo &lt;- function(...) print(&quot;Called twice for some reason?&quot;) x &lt;- structure(2, class = &quot;foo&quot;) x &gt; 0 [1] &quot;Called twice for some reason?&quot; [1] &quot;Called twice for some reason?&quot; Double dispatch – where it’s calling the same method on x and zero. The inequality needs to convert both to the same class. The book mentions that we can use vctrs::vec_arith to avoid the aboce, but does that pertain to this case? I tried: vctrs::vec_arith(&quot;&gt;&quot;, x, 0) But I think my understanding is still off… The vec_arith generic will first dispatch on class(x) So, in this case it tries to find vec_arith.foo but we haven’t defined that yet, so it instead finds vec_arith.default which signals the error. x &lt;- structure(2, class = &quot;foo&quot;) x &gt; 0 [1] TRUE vec_arith(&quot;&gt;&quot;, x, 0) Error: &lt;foo&gt; &gt; &lt;double&gt; is not permitted vec_arith will dispatch to this first, because it finds the &quot;foo&quot; generic vec_arith.foo &lt;- function(op, x, y, ...) { # now it will dispath on y, which in this case is a numeric. UseMethod(&quot;vec_arith.foo&quot;, y) } vec_arith(&quot;&gt;&quot;, x, 0) Error in UseMethod(&quot;vec_arith.foo&quot;, y): no applicable method for &#39;vec_arith.foo&#39; applied to an object of class &quot;c(&#39;double&#39;, &#39;numeric&#39;)&quot; Uh oh another error, and this is super confusing because none of our objects are class double. (typeof(x) is “double”). The problem is that vec_arith.foo further dispatches on the second argument and it is looking for vec_arith.numeric or vec_arith.default, but we haven’t defined that yet. vec_arith.foo.numeric &lt;- function(op, x, y, ...) { vctrs::vec_arith_base(op, x, y, ...) } vec_arith(&quot;&gt;&quot;, x, 0) [1] TRUE vec_arith(&quot;&gt;&quot;, 0, x) Error: &lt;double&gt; &gt; &lt;foo&gt; is not permitted now vec_arith will first dispatch on the 0 and scope to vec_arith.numeric which will then try to dispatch to vec_arith.numeric.foo which we havent defined yet. vec_arith.numeric.foo &lt;- function(op, x, y, ...) { vctrs::vec_arith_base(op, x, y, ...) } vec_arith(&quot;&gt;&quot;, 0, x) [1] FALSE What is happening here?! Math.bar &lt;- function(x) { print(&quot;Math bar&quot;) NextMethod(.Generic) } Math.foo &lt;- function(x) { print(&quot;Math foo&quot;) NextMethod(.Generic) } x &lt;- 1 class(x) &lt;- c(&quot;foo&quot;, &quot;bar&quot;, class(x)) abs(x) `abs.foo` &lt;- function(x) { print(&quot;Generic foo&quot;) NextMethod() } abs(x) `abs.bar` &lt;- function(x) { print(&quot;Generic bar&quot;) NextMethod() } abs(x) rm(abs.foo) # infinite recursion continually calling abs.bar, only calling Math.foo once abs(x) rm(Math.foo) # back to working abs(x) "],
["r6.html", "Chapter 14 R6 14.2 Classes and methods 14.2.2 Important methods Classes and methods 14.2.3 Exercises 14.2.6.4 14.4 Reference semantics", " Chapter 14 R6 14.2 Classes and methods Any … R6 method called for its side effects … should return invisible(self). WHY? What is invisible(self) doing in the add function below? I tried removing this line but it doesn’t change the output… Accumulator &lt;- R6Class(&quot;Accumulator&quot;, list( sum = 0, add = function(x = 1) { self$sum &lt;- self$sum + x invisible(self) }) ) x &lt;- Accumulator$new() Returning self or invisible(self) allows for method chaining. i.e. x$add(1)$add(2) can be done rather than x$add(1); x$add(2). In the absence of anything better to return, why not return itself 14.2.2 Important methods Why don’t we need to specifically call haldey2$print to see the output below)? Is the print method just a built in output of an R6 object? Person &lt;- R6Class(&quot;Person&quot;, list( name = NULL, age = NA, initialize = function(name, age = NA) { self$name &lt;- name self$age &lt;- age }, print = function(...) { cat(&quot;Person: \\n&quot;) cat(&quot; Name: &quot;, self$name, &quot;\\n&quot;, sep = &quot;&quot;) cat(&quot; Age: &quot;, self$age, &quot;\\n&quot;, sep = &quot;&quot;) invisible(self) } )) hadley2 &lt;- Person$new(&quot;Hadley&quot;) hadley2 Person: Name: Hadley Age: NA Print is an S3 generic, so when print is implicitly called, it calls the method for the R6 object. The method for the R6 object is “look for a print function inside the R6 object” Classes and methods 14.2.3 Once instantiated, can you add another method to an R6 object or does the set function only work on the R6 generator? Once instantiated the environments are locked (no new bindings). But, you can fudge with things and still modify existing bindings if you wanted. But, this is not really something to advocate: Beer &lt;- R6::R6Class( &#39;Beer&#39;, public = list( abv = 0.05, percent_abv = function() { sprintf(&#39;%.1f%%&#39;, 100 * self$abv) } ) ) class(Beer) #&gt; [1] &quot;R6ClassGenerator&quot; beer &lt;- Beer$new() unlockBinding(&quot;percent_abv&quot;, beer) beer$percent_abv &lt;- function() { cat(&quot;h@xed&quot;)} lockBinding(&quot;percent_abv&quot;, beer) beer$percent_abv() [1] &quot;R6ClassGenerator&quot; h@xed You can also set the lock_objects option on the generator to FALSE Beer &lt;- R6::R6Class( &#39;Beer&#39;, public = list( abv = 0.05, percent_abv = function() { sprintf(&#39;%.1f%%&#39;, 100 * self$abv) } ), lock_objects = FALSE ) beer &lt;- Beer$new() beer$rating &lt;- 5 beer$rating ## [1] 5 [1] 5 But this still won’t work because the bindings were still locked beer$percent_abv &lt;- function() { cat(&quot;h@xed&quot;)} #&gt; Error in beer$percent_abv &lt;- function() {: cannot change value of locked binding for &#39;percent_abv&#39; Exercises 14.2.6.4 Why can’t we use method chaining to access the current time zone? Timezone &lt;- R6Class( classname = &quot;Timezone&quot;, public = list( get = function() { Sys.timezone() }, set = function(value) { stopifnot(value %in% OlsonNames()) old &lt;- self$get() Sys.setenv(TZ = value) invisible(old) }) ) tz &lt;- Timezone$new() old &lt;- tz$set(&quot;Antarctica/South_Pole&quot;) tz$get() [1] &quot;America/Los_Angeles&quot; tz$set(&quot;Antarctica/South_Pole&quot;)$get() Error in tz$set(&quot;Antarctica/South_Pole&quot;)$get : $ operator is invalid for atomic vectors You’re not returning an R6 object in your first “set”, you’re returning a character vector, so you can’t find the get method of that character vector We can return something using the following code: Timezone &lt;- R6Class( classname = &quot;Timezone&quot;, public = list( get = function() { self$current_zone }, set = function(v) { self$current_zone &lt;- v invisible(self) }, reset = function() { if (!is.null(private$.old)) { self$current_zone &lt;- private$.old } invisible(self) } ), active = list( current_zone = function(v) { if (missing(v)) { return(Sys.timezone()) } stopifnot(v %in% OlsonNames()) old &lt;- Sys.timezone() if (Sys.setenv(TZ=v)) { private$.old &lt;- old } else { stop(&quot;Unable to set timezone.&quot;) } invisible(self) } ), private = list( .old = NULL ) ) tz &lt;- Timezone$new() tz$set(&quot;Antarctica/South_Pole&quot;)$get() #&gt; [1] &quot;Antarctica/South_Pole&quot; tz$reset()$get() #&gt; [1] &quot;US/Central&quot; That said, not every function should support chaining. Sometimes you want the function to return some value (like $get) and in these cases, you just won’t be able to chain, and that is okay. 14.4 Reference semantics $clone() does not recursively clone nested R6 objects. If you want that, you’ll need to use $clone(deep = TRUE). Can we see this in action using a subclass? This example is taken from the R6 documentation: Object c1 contains s, which we will clone. The original and clone both point to the same object, and by using deep = TRUE we can modify s in one object without changing it in the other. Simple &lt;- R6Class(&quot;Simple&quot;, public = list(x = 1)) Cloneable &lt;- R6Class(&quot;Cloneable&quot;, public = list( s = NULL, initialize = function() self$s &lt;- Simple$new() ) ) c1 &lt;- Cloneable$new() c2 &lt;- c1$clone() # Change c1&#39;s `s` field c1$s$x &lt;- 2 # c2&#39;s `s` is the same object, so it reflects the change c2$s$x #&gt; [1] 2 c3 &lt;- c1$clone(deep = TRUE) # Change c1&#39;s `s` field c1$s$x &lt;- 3 # c2&#39;s `s` is different # if we set deep = FALSE this would be 3! c3$s$x #&gt; [1] 2 When or why would I set the clone argument to FALSE? Clone has a large memory footprint so if you’re going to create a lot of R6 methods you may want to exclude this! "],
["s4.html", "Chapter 15 S4 15.2 Basics 15.3.6.2 Exercises Signature 15.5.1 Single dispatch", " Chapter 15 S4 15.2 Basics Broadly, what is a generic and method in S4 and what is their relationship? setClass(&quot;Person&quot;, slots = c( name = &quot;character&quot;, age = &quot;numeric&quot; ) ) setGeneric(&quot;age&quot;, function(x) standardGeneric(&quot;age&quot;)) setGeneric(&quot;age&lt;-&quot;, function(x, value) standardGeneric(&quot;age&lt;-&quot;)) setMethod(&quot;age&quot;, &quot;Person&quot;, function(x) x@age) setMethod(&quot;age&lt;-&quot;, &quot;Person&quot;, function(x, value) { x@age &lt;- value x }) john &lt;- new(&quot;Person&quot;, name = &quot;John Smith&quot;, age = 12) age(john) [1] 12 A generic is a function that will dispatch differently based on the class it is applied to. Above we apply the age generic to Person using setMethod but we could create an age method that behaves differently for another class, like dogs (which will add 7 to the supplied age) setClass(&quot;Person&quot;, slots = c(name = &quot;character&quot;,age = &quot;numeric&quot;)) setGeneric(&quot;age&quot;, function(x) standardGeneric(&quot;age&quot;)) setGeneric(&quot;age&lt;-&quot;, function(x, value) standardGeneric(&quot;age&lt;-&quot;)) setMethod(&quot;age&quot;, &quot;Person&quot;, function(x) x@age) setMethod(&quot;age&lt;-&quot;, &quot;Person&quot;, function(x, value) { x@age &lt;- value x }) setClass(&quot;Dog&quot;, slots = c(name = &quot;character&quot;, age = &quot;numeric&quot;)) # You want the age generic to automatically return 7x the slot in human years setMethod(&quot;age&quot;, &quot;Dog&quot;, function(x) {x@age*7} ) setMethod(&quot;age&lt;-&quot;, &quot;Dog&quot;, function(x, value) { x@age &lt;- value x }) spot &lt;- new(&quot;Dog&quot;, name = &quot;Spot Smith&quot;, age = 12) age(spot) [1] 84 What is standardGeneric doing in the example above? It’s the same thing as UseMethod but for S4 15.3.6.2 Exercises What is a virtual class and how does it relate to setClassUnion [see ?setClass] A virtual class is a class that cannot be instanciated. Rather than define two of the same methods for two classes, give them both a virtual parent class with the shared method. Signature In our own words what exactly is a signature? Are there any signatures within our Person example? If not can we add one? 15.5.1 Single dispatch What’s a use case in the wild for ANY? "],
["trade-offs.html", "Chapter 16 Trade-Offs", " Chapter 16 Trade-Offs Can we make a class using S3, S4, and R6 so we can easily directly compare the three, and their generics and methods? 16.0.1 Using our example from the S4 Chapter: setClass(&quot;Person&quot;, slots = c( name = &quot;character&quot;, age = &quot;numeric&quot; ) ) setGeneric(&quot;age&quot;, function(x) standardGeneric(&quot;age&quot;)) setGeneric(&quot;age&lt;-&quot;, function(x, value) standardGeneric(&quot;age&lt;-&quot;)) setMethod(&quot;age&quot;, &quot;Person&quot;, function(x) x@age) setMethod(&quot;age&lt;-&quot;, &quot;Person&quot;, function(x, value) { x@age &lt;- value x }) john &lt;- new(&quot;Person&quot;, name = &quot;John Smith&quot;, age = 12) age(john) [1] 12 A generic is a function that will dispatch differently based on the class it is applied to. Above we apply the age generic to Person using setMethod but we could create an age method that behaves differently for another class, like dogs (which will add 7 to the supplied age) setClass(&quot;Person&quot;, slots = c(name = &quot;character&quot;,age = &quot;numeric&quot;)) setGeneric(&quot;age&quot;, function(x) standardGeneric(&quot;age&quot;)) setGeneric(&quot;age&lt;-&quot;, function(x, value) standardGeneric(&quot;age&lt;-&quot;)) setMethod(&quot;age&quot;, &quot;Person&quot;, function(x) x@age) setMethod(&quot;age&lt;-&quot;, &quot;Person&quot;, function(x, value) { x@age &lt;- value x }) setClass(&quot;Dog&quot;, slots = c(name = &quot;character&quot;, age = &quot;numeric&quot;)) # You want the age generic to automatically return 7x the slot in human years setMethod(&quot;age&quot;, &quot;Dog&quot;, function(x) {x@age*7} ) setMethod(&quot;age&lt;-&quot;, &quot;Dog&quot;, function(x, value) { x@age &lt;- value x }) spot &lt;- new(&quot;Dog&quot;, name = &quot;Spot Smith&quot;, age = 12) age(spot) We can do this with S3: johnny &lt;- structure( list(name = &quot;Johnny Smith&quot;, age = 12), class = &quot;s3_human&quot;) stripe &lt;- structure( list(name = &quot;Stripe Smith&quot;, age = 12), class = &quot;s3_dog&quot;) s3_age &lt;- function(x){UseMethod(&quot;s3_age&quot;)} s3_age.s3_dog &lt;- function(x){x$age*7} s3_age.s3_human &lt;- function(x){x$age} s3_age(johnny) ## [1] 12 s3_age(stripe) ## [1] 84 And R6 Person &lt;- R6Class(&quot;Person&quot;, list( name = NULL, age = NULL, initialize = function(name, age = NA) { stopifnot(is.character(name), length(name) == 1) stopifnot(is.numeric(age), length(age) == 1) self$name &lt;- name self$age &lt;- age } )) john &lt;- Person$new(name = &quot;John Smith&quot;, age = 12) john$age [1] 12 Dog &lt;- R6Class( &quot;Dog&quot;, inherit = Person, public = list( initialize = function(name, age = NA) { super$initialize(name,age) self$age &lt;- age * 7 } )) spot &lt;- Dog$new(name = &quot;Spot Smith&quot;, age = 12) spot$age [1] 84 "],
["big-picture.html", "Chapter 17 17 Big Picture 17.8 Quosures", " Chapter 17 17 Big Picture 17.8 Quosures What is meant here by “data mask” I love the idea of creating templates then shoving in code using !! can we create a template that inserts a filtering statement into our tidypipeline? # this is my template iris %&gt;% ggplot2::ggplot() + ggplot2::aes(x = Sepal.Length, y = Sepal.Width) + ggplot2::geom_point() # somehow insert this into the template at line 2 dplyr::filter(Sepal.Length &gt; 4.5) %&gt;% # to create something prettier than if (x == 2) { iris %&gt;% dplyr::filter(Sepal.Length &gt; 4.5) %&gt;% ggplot2::ggplot() + ggplot2::aes(x = Sepal.Length, y = Sepal.Width) + ggplot2::geom_point() } else { iris %&gt;% ggplot2::ggplot() + ggplot2::aes(x = Sepal.Length, y = Sepal.Width) + ggplot2::geom_point() } customizable_iris &lt;- function(pipeline_insertion = NULL){ dt &lt;- rlang::expr(iris) pi &lt;- rlang::enexpr(pipeline_insertion) if (!rlang::is_null(pi)) dt &lt;- rlang::expr(!!dt %&gt;% !!pi) rlang::expr( !!dt %&gt;% ggplot2::ggplot() + ggplot2::aes(x = Sepal.Length, y = Sepal.Width) + ggplot2::geom_point() ) } (x &lt;- customizable_iris(dplyr::filter(Sepal.Length &gt; 5))) ## iris %&gt;% dplyr::filter(Sepal.Length &gt; 5) %&gt;% ggplot2::ggplot() + ## ggplot2::aes(x = Sepal.Length, y = Sepal.Width) + ggplot2::geom_point() rlang::eval_bare(x) Any valid r code can be converted into an expression or list of expressions, and expressions can be patched together using this unquoting (forcing) procedure. Probably best thoguht of in terms of the tree structure, by replacing one node with another expression: lobstr::ast(a + b) ## █─`+` ## ├─a ## └─b b &lt;- rlang::expr(x + y) lobstr::ast(!!b) ## █─`+` ## ├─x ## └─y lobstr::ast(a + !!b) ## █─`+` ## ├─a ## └─█─`+` ## ├─x ## └─y so the forcing operation is kind of like performing surgery on the AST, where you cut out one node (the thing being forced) and replacing it with some other code. "],
["expressions.html", "Chapter 18 Expressions", " Chapter 18 Expressions I understand how we can subset expression calls but why/when would you do that? What is the context for extracting stuff from a function as an expression ? Let’s build on this contrived example…. x &lt;- read.table(&quot;important.csv&quot;, row.names = FALSE) lobstr::ast(read.table(&quot;important.csv&quot;, row.names = FALSE)) x[[1]] Making this an expression, we can use subsetting to shove in read.csv or read.tsv where read.table is? You might need to do this in order to insert a line of code inside a function call: f &lt;- function(x) { read.table(&quot;important.csv&quot;, row.names = FALSE) } body(f)[[2]][[1]] &lt;- quote(read.csv) f ## function (x) ## { ## read.csv(&quot;important.csv&quot;, row.names = FALSE) ## } What’s an application for this chapter? library(rlang) replace_sym &lt;- function(x, sym, replace) { if (is_symbol(x, name = sym)) { replace } else if (is_atomic(x)) { x } else if (is_symbol(x)) { x } else if (is_call(x)) { as.call(lapply(x, replace_sym, sym, replace)) } else if (is.pairlist(x)) { as.pairlist(lapply(x, replace_sym, sym, replace)) } else { abort(glue::glue(&quot;Don&#39;t know how to handle {as_label(x)}&quot;)) } } replace_sym(expr(a + b + 1), &quot;b&quot;, expr(f(x))) ## a + f(x) + 1 Why does the expression jump around between “data” and “values” on the env panel in RStudio? It would be nice if it stayed in the “data” pane so you can inspect it Why doesn’t the last line return true? is_assignment &lt;- function(expr) { (expr[[1]] == &quot;&lt;-&quot; || expr[[1]] == &quot;=&quot;) } exprs &lt;- rlang::parse_exprs(&quot;x &lt;- 1;x = 1&quot;) is_assignment(exprs[[1]]) ## [1] TRUE is_assignment(exprs[[2]]) ## [1] TRUE is_assignment(expression(x &lt;- 1)[[1]]) ## [1] TRUE is_assignment(expression(x = 1)[[1]]) ## [1] FALSE It is interpreting x = 1 as an argument to expression. To quote equality you can do parse(text = &quot;x = 1&quot;) and the output will print the same, but it isn’t Does all this go out the book if someone uses &quot;abc&quot; -&gt; x? &quot;abc&quot;-&gt;x is internally parsed as x &lt;- &quot;abc&quot; parse(text = &quot;&#39;xyz&#39; -&gt; x&quot;)[[1]] ## x &lt;- &quot;xyz&quot; Can you clarify the difference between: - call - language - expression - structure identical( structure(expression(a &lt;- print(123))), expression(a &lt;- print(123)) ) ## [1] TRUE is.language(expression(a &lt;- print(123))) ## [1] TRUE xxx When would I use quote() over expression()? Hadley advises not to use expression(), because it just makes a vector of expressions. He prefers lists of expressions, which you’d generate interactively with quote() (or inside functions with substitute()). We’ll touch on the borders of this at least tonight. "],
["quasiquotation.html", "Chapter 19 Quasiquotation 19.2 Motivation 19.3.4 Substitution Exercises 19.3.6.5 19.4.6 Polite fiction of !! 19.4.7 Nonstandard ASTs 19.4.8.2 Exercises Non-quoting 19.6 (…) 19.6.2 exec() 19.6.3 dots_list() 19.6.4 With base R", " Chapter 19 Quasiquotation 19.2 Motivation How does cement compare to glue? Can we look at the source code for quasiquotation and using {} for interpolation? They are opposite; while glue evaluates expressions inside a string, cement quotes expressions. 19.3.4 Substitution Is it supplied by the developer of the code or the user of the code? In other words, is it fixed (supplied in the body of the function) or varying (supplied via an argument)? What are two examples (from the chapter or our own) of the former vs latter This destinction can be put as: do you want exactly what the developer/coder typed or do you want what was put into the function? This will tell you if you want to use expr or enexpr Hadley creates a table for quoting expressions using base R and tidy eval, but there isn’t really a one to one relationship here. For instance substitute is compared to enexprs but that fails here? f4 &lt;- function(x) substitute(x * 2) f4(a + b + c) f5 &lt;- function(x) enexprs(x*2) f5(a + b + c) That is because they are not a 1-1 relationship, substitute has 5 different functions under the hood (but they are not S3 methods!!), these are only related somewhat. Exercises 19.3.6.5 What does the argument .named do in exprs? What does “to ensure all dots are named” mean? You can pass extra arguments to your function as dots, and this will ensure that those extra arguments are named 19.4.6 Polite fiction of !! What exactly is happening here? Why is y evaluating to 6?! df &lt;- data.frame(x = 1:5) y &lt;- 100 with(df, x + !!y) ## [1] 2 3 4 5 6 Any number that isn’t 0 is TRUE in R: as.logical(1.2123) ## [1] TRUE So because y==TRUE, with is taking every element in x and adding 1 to it because once you introduce a + inside with you’re essentially saying as.numeric(TRUE) which is 1. with(df, x + TRUE) == with(df, x + 1) ## [1] TRUE TRUE TRUE TRUE TRUE !x essentially really means !as.logical(x), 1:5 + x essentially really means 1:5 + as.integer(x), so we end up with 1:5 + as.integer(!(!(as.logical(y)))) 19.4.7 Nonstandard ASTs When talking about non-standard ASTs Hadley says: These are valid, and occasionally useful, but their correct use is beyond the scope of this book. What is their correct use? A use for this could potentially be if you need to manipulate an AST and subsitute an environment within the AST? In the question below we are creating a non-standard AST (not that we should be!) 19.4.8.2 Exercises What exactly is going on here? What is &lt;inline integer&gt;? lobstr::ast(mean(1:10)) ## █─mean ## └─█─`:` ## ├─1 ## └─10 lobstr::ast(mean(!!(1:10))) ## █─mean ## └─&lt;inline integer&gt; The inline integer is the actual integers being inserted into the AST rather than as expressions Non-quoting What exactly is the difference between “turn quoting off” and “using unquoting” – maybe to explain this we can we come up with an example for “turning quoting off” when we expect “unquoting” and therefore the operation fails? In base R functions it’s all or nothing: you can either quote everything or nothing, you cannot selectively quote expressions. 19.6 (…) Based on this thread it looks like ... should be the first line of defense before using tidyeval - why? my_groups &lt;- function(df, ...) { df %&gt;% group_by(...) %&gt;% summarise(n = n()) } my_groups &lt;- function(df, col) { df %&gt;% group_by(!!enquo(col)) %&gt;% summarise(n = n()) } The first option lets the robust function group_by figure out any quoting. Furthermore, the second option only allows the user to supply a single column to group by and assumes the user is passing in a valid column. Can we go over the “spatting” example, I have no idea what this means. I think “splatting” is the correct term*. It means taking a single argument in a list and interpreting it as separate arguments. Hadley is referring to the specific use of !!! to unpack a list into function arguments. at least googling for “splatting Ruby” gives lots of relevant hits vs “spatting Ruby” 19.6.2 exec() Can we use this function instead of do.call in our Expressions shiny app? Do we need to change argumentlist() to use list2 rather than list? do.call(call2, argumentlist(), quote = TRUE) exec(call2, !!!argumentlist()) 19.6.3 dots_list() This function seems pretty rad, what’s a use case for it in the wild? We can use this function anytime there’s a use for list2! 19.6.4 With base R What is going on with this RCurl example and how does it avoid using do.call? Can we find some Hadley source code that uses it since he said he liked it at one point? Why do you think he moved away from it? f &lt;- function(..., .dots) { dots &lt;- c(list(...), .dots) # Do something } The dots object combines all the arguments passed as dots and the arguments not passed as dots. This gives a lot (perhaps too much) leeway to the user of the function. "],
["evaluation.html", "Chapter 20 Evaluation 20.1 Introduction 20.2.1 local 20.2.2 source 20.2.3 function 20.2.4.5 Exercises 20.3.3 Dots 20.3.4 Under the hood 20.3.6.2 Exercises 20.4.1 Basics 20.4.3 subset 20.4.5 transform 20.5.2 Handling ambiguity 20.6.1 substitute() 20.6.2 match.call", " Chapter 20 Evaluation 20.1 Introduction There’s an immediate distinction between unquotation (user) and evaluation (developer). What are they? Unquoting seems to be “evaluate this one part and then return the expression” evaluate means “give me the result of this whole expression” 20.2.1 local This is such a cool function - where is it used in the wild? When wanting to have variables stored in the environment of a function, or if you want to run an expression that produces bindings, but you don’t want those bindings to persist. counter &lt;- local({ i &lt;- 0; function() { i &lt;&lt;- i + 1; print(i) } }) counter() ## [1] 1 counter() ## [1] 2 counter() ## [1] 3 We can also wrap for loops in a local call to avoid the object being iterated over getting assigned to the global environment f1 &lt;- function(x) { for (x in 1:10) { # do something } x } f2 &lt;- function(x) { local({ for (x in 1:10) { # do something } }) x } f1(&quot;hello&quot;) #&gt; [1] 10 f2(&quot;hello&quot;) #&gt; [1] &quot;hello&quot; 20.2.2 source Expression vectors get a shout out again (they are an aside in the Expression chapter) and while Hadley advises against introducing another data structure, I wanted to make sure my high level understanding was correct: eval can be vectorized if the input is of type expression vector [but not if it’s of type list]? exp_vec &lt;- expression(x &lt;- 4, x) eval(exp_vec) exp_list &lt;- list2( rlang::expr(x &lt;- 4), rlang::expr(x) ) eval(exp_list) 20.2.3 function I think I understand this issue based on the concrete example but can we summarize the “gotcha” here? It’s basically that the printing of the function is a lie (because base R doesn’t get it). And that’s dangerous and confusing, so use rlang to make it not a lie. x &lt;- 10 y &lt;- 20 f &lt;- eval(expr(function(x, y) !!x + !!y)) f ## function(x, y) !!x + !!y f() ## [1] 30 attributes(f) ## $srcref ## function(x, y) !!x + !!y attr(f, &quot;srcref&quot;) &lt;- NULL f ## function (x, y) ## 10 + 20 The REAL function is 10 + 20, but the initial srcref keeps the !!x and !!y, which is meaningless. This might help explain why there’s a problem: x &lt;- 10 y &lt;- 20 f &lt;- eval(expr(function(x, y) !!x + !!y)) f ## function(x, y) !!x + !!y f() ## [1] 30 x &lt;- 2000 y &lt;- 3000 f() ## [1] 30 #&gt; [1] 30 attributes(f) ## $srcref ## function(x, y) !!x + !!y #&gt; $srcref #&gt; function(x, y) !!x + !!y attr(f, &quot;srcref&quot;) &lt;- NULL f ## function (x, y) ## 10 + 20 ## &lt;bytecode: 0x7f7f25ea2b50&gt; #&gt; function (x, y) #&gt; 10 + 20 #&gt; &lt;bytecode: 0x000000001421eb90&gt; 20.2.4.5 Exercises Can we also go over what is happening in local3? local3 &lt;- function(expr, envir = new.env()) { call &lt;- substitute(eval(quote(expr), envir)) print(call) eval(call, envir = parent.frame()) } local3({ x &lt;- 10 x * 2 }) exists(&quot;x&quot;) It creates a new environment with the calling environment as its parent and then evaluates the expression in that environment. You are evaluating the call in the execution environment of local3. Its confusing because it’s written as eval(call, envir = parent.frame()) but it is important to remember that parent.frame is evaluated in the execution environment of eval. if instead you had: pf &lt;- parent.frame() eval(call, envir = pf) you would get something else. Because in this case, parent.frame() is evaluated in the execution environment of local3 and thus returns .GlobalEnv (presumably you run it from the global env). 20.3.3 Dots I have no idea what’s happening in this section. Can we go over the point/what this code is showing us? f &lt;- function(...) { x &lt;- 1 g(..., f = x) } g &lt;- function(...) { enquos(...) } x &lt;- 0 qs &lt;- f(global = x) qs As a preliminary, I note that the following code also illustrates the point: f &lt;- function(...) { x &lt;- 1 g(..., f = x) } g &lt;- function(...) { enquos(...) } x &lt;- 0 qs &lt;- f(x) qs I think what he’s trying to say is that if you didn’t have quosures you would have to create a list of environments to match the list of expressions if you wanted your expressions to contain the same names but not necessarily have those names have the same meaning. But here we have a magical situation where each quosure has the same expression but each environment is different and thus each x will be evaluated differently when the time comes. I think the real barrier to truly getting it is figuring out a plausible example of wanting the same name to have different meanings in your list of expressions.. and I’m at a loss for that at the moment. 20.3.4 Under the hood Unfortunately, however, there is no clean way to make ~ a quasiquoting function. Can we come up with a (broken) example of trying to quasiquote an object of type formula? I think seeing this fail will help me to understand its limitations To do this you would need to recreate the way rlang worked when quosures WERE formulas, probably by pulling the commit prior to the rewrite off of github. It looks like the old method would encode the expr as a formula and then overload the tilde operator so that it does tidy eval instead of..whatever it does normally 20.3.6.2 Exercises What is going on here?? enenv &lt;- function(x){ get_env(enquo(x)) } # Test capture_env &lt;- function(x){ enenv(x) } enenv(x) #&gt; &lt;environment: R_GlobalEnv&gt; capture_env(x) # functions execution environment is captured #&gt; &lt;environment: 0x60a2538&gt; The enquo is capturing the environment of the x being passed into enenv, so it returns a different environment (the one inside capture_env) than running enenv(x) on its own 20.4.1 Basics I am clearly missing something here. What is so special about multiplying across a vector? Is it that data masks allow us to just write y instead of df$y? I think the simplicity of the multiplication may be what he’s going for: the reader can focus on the language feature provided without the distraction of a complex computation. 20.4.3 subset What is the eval_tidy doing here? subset2 &lt;- function(data, rows) { rows &lt;- enquo(rows) # creates a quosure out of the enquoted rows # and uses the data as its environment rows_val &lt;- eval_tidy(rows, data) stopifnot(is.logical(rows_val)) # then subsets the data data[rows_val, , drop = FALSE] } df &lt;- subset2(palmerpenguins::penguins, species == &quot;Adelie&quot;) table(df$species) ## ## Adelie Chinstrap Gentoo ## 152 0 0 20.4.5 transform Can we say in words what this one is doing or comment all the lines? transform2 &lt;- function(.data, ...) { # create quosures for all the supplied arguments and values dots &lt;- enquos(...) # for all argument value pairs for (i in seq_along(dots)) { # get the names of the arguments name &lt;- names(dots)[[i]] # get their values dot &lt;- dots[[i]] # add column with names equal to argument names # eval_tidy and values (single column) equal to the evaluated quosure (dot)&quot; .data[[name]] &lt;- eval_tidy(dot, .data) } .data } 20.5.2 Handling ambiguity There are subtle differences in when val is evaluated. If you unquote, val will be early evaluated by enquo(); if you use a pronoun, val will be lazily evaluated by eval_tidy(). These differences are usually unimportant, so pick the form that looks most natural. Is there a case where this subtle distinction between .env$val vs !!val matters? threshold_prefix &lt;- function(df, val) { subset2(df, .data$x &gt;= .env$val) } threshold_bangbang &lt;- function(df, val) { subset2(df, .data$x &gt;= !!val) } df &lt;- data.frame(x = 1:3, val = 9:11) threshold_prefix(df, 2) == threshold_bangbang(df, 2) ## x val ## 2 TRUE TRUE ## 3 TRUE TRUE In the !! case, val is evaluated early, (inside of threshold_x) whereas the .env case evaluated later (in the eval_tidy) Tyler Grant Smith:m: 21 minutes ago this could cause problems if, for example, the val in threshold_x was altered after subset2 was called, but before the eval_tidy subset2 &lt;- function(data, rows) { rows &lt;- enquo(rows) # change val from 2 to 3, breaking things env_bind(caller_env(), val = 3) rows_val &lt;- eval_tidy(rows, data) stopifnot(is.logical(rows_val)) data[rows_val, , drop = FALSE] } 20.6.1 substitute() Why exactly can’t we use subset with map? This works, not sure why the book says it wouldn’t…. subset_base &lt;- function(data, rows) { rows &lt;- substitute(rows) rows_val &lt;- eval(rows, data, caller_env()) stopifnot(is.logical(rows_val)) data[rows_val, , drop = FALSE] } local({ zzz &lt;- 2 dfs &lt;- list(data.frame(x = 1:3), data.frame(x = 4:6)) map(dfs, ~subset_base(.x, x == zzz)) }) ## [[1]] ## x ## 2 2 ## ## [[2]] ## [1] x ## &lt;0 rows&gt; (or 0-length row.names) Calling subset() from another function requires some care: you have to use substitute() to capture a call to subset() complete expression Why?! No reason to expect this to work: test &lt;- function(df, expr) { subset(df, expr) } test(mtcars, cyl &gt; 4) #&gt; Error in eval(e, x, parent.frame()): object &#39;cyl&#39; not found substitute only looks at the expression from which it was called. this doesn’t work because subset sees substitute(expr), not cyl &gt; 4 test &lt;- function(df, expr) { subset(df, substitute(expr)) } test(mtcars, cyl &gt; 4) #&gt; Error in subset.data.frame(df, substitute(expr)): &#39;subset&#39; must be logical so instead, we are going to build the call to subset, substituting in what was passed as arguments, and then eval the call. test &lt;- function(df, expr) { subset_call &lt;- substitute(subset(df, expr)) print(subset_call) eval(subset_call) } test(mtcars, cyl &gt; 4) #&gt; subset(mtcars, cyl &gt; 4) 20.6.2 match.call Can we speak more about the differences in these two functions and their pros and cons? resample_lm2 &lt;- function(formula, data, env = caller_env()) { formula &lt;- enexpr(formula) resample_data &lt;- resample(data, n = nrow(data)) lm_env &lt;- env(env, resample_data = resample_data) lm_call &lt;- expr(lm(!!formula, data = resample_data)) expr_print(lm_call) eval(lm_call, lm_env) } resample_lm2(y ~ x, data = df) resample_lm0 &lt;- function( formula, data, resample_data = data[sample(nrow(data), replace = TRUE), , drop = FALSE], env = current_env() ) { formula &lt;- enexpr(formula) lm_call &lt;- expr(lm(!!formula, data = resample_data)) expr_print(lm_call) eval(lm_call, env) } df &lt;- data.frame(x = 1:10, y = 5 + 3 * (1:10) + round(rnorm(10), 2)) (resamp_lm1 &lt;- resample_lm0(y ~ x, data = df)) I think these two functions should work identically assuming formula and data are the only two inputs that are set by the user. (The results will differ unless a seed is set.) I suppose the resample_lm0() here provides more flexibility to the user (compared to resample_lm2(), i.e. the user can specify resample_data (since it’s an argument) instead of being “forced” to use the custom function resample(), which is embedded in the body of resample_lm2(). Downside to resample_lm0 is that there might be too much flexibility. Yes, resample_data is customizable, but so is env. What if the user changes env = current_env() to env = caller_env()? Then the function breaks. Is the closest equivalent to deparse(substitute(x)) with rlang expr_text(enexpr(x)) (assuming this is in a function, hence the en in enexpr)? penguins &lt;- palmerpenguins::penguins add_bleh &lt;- function(df, nm = deparse(substitute(df))) { col_out &lt;- sym(sprintf(&#39;new_%s_col&#39;, nm)) df %&gt;% mutate(!!col_out := &#39;bleh&#39;) } add_bleh(penguins) %&gt;% slice(1) %&gt;% glimpse() ## Rows: 1 ## Columns: 9 ## $ species &lt;fct&gt; Adelie ## $ island &lt;fct&gt; Torgersen ## $ bill_length_mm &lt;dbl&gt; 39.1 ## $ bill_depth_mm &lt;dbl&gt; 18.7 ## $ flipper_length_mm &lt;int&gt; 181 ## $ body_mass_g &lt;int&gt; 3750 ## $ sex &lt;fct&gt; male ## $ year &lt;int&gt; 2007 ## $ new_penguins_col &lt;chr&gt; &quot;bleh&quot; In this thread Lionel says &quot;enexpr should almost never be used. So when should it? Seems like when wrapping a base NSE function like lm or trying to deparse(substitute(x)) using rlang "]
]
