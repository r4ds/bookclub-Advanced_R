\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{hyperref}
\hypersetup{
            pdftitle={Advanced R Companion},
            pdfauthor={R4DS Reading Group},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Fix footnotes in tables (requires footnote package)
\IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{longtable}}{}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\usepackage{booktabs}
\usepackage{amsthm}
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=8pt plus 2pt minus 4pt
  \thm@postskip=\thm@preskip
}
\makeatother
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{Advanced R Companion}
\author{R4DS Reading Group}
\date{2020-05-26}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{welcome}{%
\chapter{Welcome}\label{welcome}}

A companion to \href{https://adv-r.hadley.nz/rcpp.html\#acknowledgments}{Advanced R} and supplement to \href{https://advanced-r-solutions.rbind.io/names-and-values.html\#copy-on-modify}{Advanced R Solutions}

Recordings for the accompanied presentation for each chapter can be seen \href{https://www.youtube.com/watch?v=pQ-xDAPEQaw\&list=PL3x6DOfs2NGi9lH7q-phZlPrl6HKXYDbn}{here}.

\hypertarget{names-and-values}{%
\chapter{Names and Values}\label{names-and-values}}

\hypertarget{binding-basics}{%
\section*{2.2 Binding basics}\label{binding-basics}}
\addcontentsline{toc}{section}{2.2 Binding basics}

Should we care about R internals?

Guided by \href{https://www.brodieg.com/2019/02/18/an-unofficial-reference-for-internal-inspect/}{this blogpost}, we can use the \texttt{.Internal} function to inspect metadata associated with our objects:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{)}
\KeywordTok{.Internal}\NormalTok{(}\KeywordTok{inspect}\NormalTok{(x))}
\CommentTok{# > @0x000001b6a4af9fc8 19 VECSXP g0c1 [NAM(7)] (len=1, tl=0)}
\CommentTok{# > @0x000001b6a3321d90 13 INTSXP g0c0 [NAM(7)]  1 : 5 (compact)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{@0x000001b6a4af9fc8} -- address (memory location)
\item
  \texttt{19\ VECSXP} -- type (\href{https://cran.r-project.org/doc/manuals/r-release/R-ints.html\#SEXPTYPEs}{full list here})
\item
  \texttt{g0} -- garbage collector info token
\item
  \texttt{c1} -- size of object (small vector)
\item
  \texttt{NAM(7)} -- named value of the object (if greater than one copy on modify)
\item
  \texttt{len=1} -- length of object
\item
  \texttt{tl} -- true length of object
\item
  small snippet of the data
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{)}
  \KeywordTok{.Internal}\NormalTok{(}\KeywordTok{inspect}\NormalTok{(x))}
\NormalTok{\}}
\CommentTok{# < @0x000001b6a4b4a3a0 19 VECSXP g0c1 [NAM(1)] (len=1, tl=0)}
\CommentTok{# < @0x000001b6a3a814d0 13 INTSXP g0c0 [NAM(7)]  1 : 5 (compact)}
\end{Highlighting}
\end{Shaded}

It is of note here that without curly brackets we have to use copy-on-modify, but within curly brackes we can use copy-in-place because \texttt{NAM(1)}

\hypertarget{copy-on-modify}{%
\section*{2.3 Copy-on-modify}\label{copy-on-modify}}
\addcontentsline{toc}{section}{2.3 Copy-on-modify}

copy-on-modify vs copy-in-place: is one more preferable in certain situations?

modify in place only happens when objects with a single binding get a special performance optimization and to environments.

\hypertarget{exercises}{%
\section*{2.2.2 Exercises}\label{exercises}}
\addcontentsline{toc}{section}{2.2.2 Exercises}

Question 3 digs into the syntactically valid names created when using \texttt{read.csv()}, but what is the difference between quotation and backticks?

If we create an example csv

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{example2223 <-}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}
  \StringTok{`}\DataTypeTok{if}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{),}
  \StringTok{`}\DataTypeTok{_1234}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{6}\NormalTok{),}
  \StringTok{`}\DataTypeTok{column 1}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{7}\NormalTok{,}\DecValTok{8}\NormalTok{,}\DecValTok{9}\NormalTok{)}
\NormalTok{)}

\KeywordTok{write.csv}\NormalTok{(example2223, }\StringTok{"example2223.csv"}\NormalTok{, }\DataTypeTok{row.names =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Import using adjusted column names to be syntactically valid:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{read.csv}\NormalTok{(}\DataTypeTok{file =} \StringTok{"example2223.csv"}\NormalTok{,}\DataTypeTok{check.names =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   if. X_1234 column.1
## 1   1      4        7
## 2   2      5        8
## 3   3      6        9
\end{verbatim}

Import using non-adjusted column names

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{read.csv}\NormalTok{(}\DataTypeTok{file =} \StringTok{"example2223.csv"}\NormalTok{, }\DataTypeTok{check.names =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   if _1234 column 1
## 1  1     4        7
## 2  2     5        8
## 3  3     6        9
\end{verbatim}

Import using the tidyverse where names are not adjusted

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df_non_syntactic_name  <-}\StringTok{ }\KeywordTok{read_csv}\NormalTok{(}\DataTypeTok{file =} \StringTok{"example2223.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Parsed with column specification:
## cols(
##   `if` = col_double(),
##   `_1234` = col_double(),
##   `column 1` = col_double()
## )
\end{verbatim}

However I really don´t understand the difference between backticks and quotation marks. For example when I select a column in the case of non-syntactic in the tidyverse I can use quotation marks or backticks

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df_non_syntactic_name }\OperatorTok{%>%}\StringTok{ }\KeywordTok{select}\NormalTok{(}\StringTok{"if"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 1
##    `if`
##   <dbl>
## 1     1
## 2     2
## 3     3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df_non_syntactic_name }\OperatorTok{%>%}\StringTok{ }\KeywordTok{select}\NormalTok{(}\StringTok{`}\DataTypeTok{if}\StringTok{`}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

But in base R, I can do this with quotation marks, but not backticks:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df__non_syntactic_name[}\StringTok{"if"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in `[.default`(df__non_syntactic_name, `if`) : invalid subscript type 'special'
\end{verbatim}

According to \texttt{?Quotes} backticks are used for ``non-standard variable names'' but why in base R they don´t work to select columns but in the tidyverse they work to select variables?

The easiest way to think about this is that backticks refer to objects while quotation marks refer to strings. \texttt{dplyr::select()} accepts object references as well as string references, while base R subsetting is done with a string or integer position.

\hypertarget{function-calls}{%
\section*{2.3.2 Function calls}\label{function-calls}}
\addcontentsline{toc}{section}{2.3.2 Function calls}

Can we go over and break down figure in 2.3.2

When you create this function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{crazyfunction <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(eh) \{eh\}}
\end{Highlighting}
\end{Shaded}

\texttt{eh} doesn't exist in memory at this point.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

x exists in memory.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z <-}\StringTok{ }\KeywordTok{crazyfunction}\NormalTok{(x) }
\end{Highlighting}
\end{Shaded}

\texttt{z} now points at \texttt{x}, and \texttt{eh} still doesn't exist (except metaphorically in Canada). \texttt{eh} was created and exists WHILE \texttt{crazyfunction()} was being run, but doesn't get saved to the global environment, so after the function is run you can't see its memory reference.

The round brackets \texttt{(eh)} list the arguments, the curly brackets \texttt{\{eh\}} define the operation that it's doing - and you're assigning it to \texttt{crazyfunction}.

\textbf{R functions automatically return the result of the last expression} so when you call that object (the argument \texttt{eh}) it returns the value of that argument. This is called \textbf{implicit returns}

\hypertarget{lists}{%
\section*{2.3.3 Lists}\label{lists}}
\addcontentsline{toc}{section}{2.3.3 Lists}

Checking the address for a list and its copy we see they share the same references:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l1 <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\NormalTok{l2 <-}\StringTok{ }\NormalTok{l1}
\KeywordTok{identical}\NormalTok{(lobstr}\OperatorTok{::}\KeywordTok{ref}\NormalTok{(l1),lobstr}\OperatorTok{::}\KeywordTok{ref}\NormalTok{(l2))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(l1[[}\DecValTok{1}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x7f93c0e25798"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(l2[[}\DecValTok{1}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x7f93c0e25798"
\end{verbatim}

But why isn't this the case for their subsets? Using \texttt{obj\_addr} they have different addresses, but when we look at their references they are the same

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(l1[}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x7f93be62fb88"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ref}\NormalTok{(l1[}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## █ [1:0x7f93be5fd720] <list> 
## └─[2:0x7f93c0e25798] <dbl>
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(l2[}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x7f93be3cc610"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{identical}\NormalTok{(lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(l1[}\DecValTok{1}\NormalTok{]), lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(l2[}\DecValTok{1}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

This is because using singular brackets wraps the value 1 in a new list that is created on the fly which will have a unique address. We can use double brackets to confirm our mental model that the sublists are also identical:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{identical}\NormalTok{(lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(l1[[}\DecValTok{1}\NormalTok{]]), lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(l2[[}\DecValTok{1}\NormalTok{]]))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

What's the difference between these 2 addresses \texttt{\textless{}0x55d53fa975b8\textgreater{}} and \texttt{0x55d53fa975b8}?

Nothing - it has to do with the printing method:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\KeywordTok{print}\NormalTok{(}\KeywordTok{tracemem}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "<0x7f93c6ada1f8>"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cat}\NormalTok{(}\KeywordTok{tracemem}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## <0x7f93c6ada1f8>
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x7f93c6ada1f8"
\end{verbatim}

When would you prefer a deep copy of a list to a shallow copy? Is this something to consider when writing functions or package development or is this more something that's optimized behind the scenes?

Automagical!

\hypertarget{character-vectors}{%
\section*{2.3.5 Character vectors}\label{character-vectors}}
\addcontentsline{toc}{section}{2.3.5 Character vectors}

Is there a way to clear the ``global string pool''?

According to \href{https://community.rstudio.com/t/memory-usage-and-rs-global-string-pool/4762/3}{this post} it doesn't look like you can directly, but clearing all references to a string that's in the global string pool clears that string from the pool, eventually

\hypertarget{exercise}{%
\section*{2.3.6.2 Exercise}\label{exercise}}
\addcontentsline{toc}{section}{2.3.6.2 Exercise}

When we look at \texttt{tracemem} when we modify \texttt{x} from an integer to numeric, x is assigned to three objects. The first is the integer, and the third numeric - so what's the intermediate type?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(1L, 2L, 3L)}
\KeywordTok{obj_addr}\NormalTok{(x)}
\KeywordTok{tracemem}\NormalTok{(x)}
\NormalTok{x[[}\DecValTok{3}\NormalTok{]] <-}\StringTok{ }\DecValTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "0x7f84b7fe2c88"
[1] "<0x7f84b7fe2c88>"
tracemem[0x7f84b7fe2c88 -> 0x7f84b7fe5288]: 
tracemem[0x7f84b7fe5288 -> 0x7f84bc0817c8]: 
\end{verbatim}

What is \texttt{0x7f84b7fe5288} when the intermediate \texttt{x\ \textless{}-\ c(1L,\ 2L,\ 4)} is impossible?

When we assign the new value as an integer there is no intermediate step. This probably means \texttt{c(1,2,\ NA)} is the intermediate step; creating an intermediate vector that's the same length of the final product with NA values at all locations that are new or to be changed

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(1L, 2L, 3L)}
\KeywordTok{obj_addr}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x7f93c6b78d88"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tracemem}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "<0x7f93c6b78d88>"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[[}\DecValTok{3}\NormalTok{]] <-}\StringTok{ }\NormalTok{4L}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## tracemem[0x7f93c6b78d88 -> 0x7f93c6b9e408]: eval eval withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> render_cur_session render_book FUN lapply unlist render_book render_book_script in_dir <Anonymous> <Anonymous>
\end{verbatim}

You can dig into the C code running this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pryr}\OperatorTok{::}\KeywordTok{show_c_source}\NormalTok{(}\KeywordTok{.Internal}\NormalTok{(}\StringTok{"[<-"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{object-size}{%
\section*{2.4.1 Object size}\label{object-size}}
\addcontentsline{toc}{section}{2.4.1 Object size}

If I have two vectors, one \texttt{1:10} and another \texttt{c(1:10,\ 10)}, intuitively, I would expect the size of the second vector to be greater than the size of the first. However, it seems to be the other way round, why?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\NormalTok{x2 <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_size}\NormalTok{(x1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 680 B
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_size}\NormalTok{(x2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 448 B
\end{verbatim}

If we start with the following three vectors:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L)}
\NormalTok{x2 <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\NormalTok{x3 <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_sizes}\NormalTok{(x1, x2, x3)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## *  96 B
## * 680 B
## * 448 B
\end{verbatim}

Intuitively, we would have expected \texttt{x1} \textless{} \texttt{x2} \textless{} \texttt{x3} but this is not the case. It appears that the \texttt{rep()} function coerces a double into integer and hence optimizes on space. Using \texttt{:}, R internally uses \href{https://blog.revolutionanalytics.com/2017/09/altrep-preview.html}{ALTREP}.

ALTREP would actually be more efficient if the numbers represented were significantly large, say \texttt{1e7}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x4 <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\FloatTok{1e7}
\NormalTok{x5 <-}\StringTok{ }\NormalTok{x4}
\NormalTok{x5[}\DecValTok{1}\NormalTok{] <-}\StringTok{ }\NormalTok{1L}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_sizes}\NormalTok{(x4, x5)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## *        680 B
## * 40,000,048 B
\end{verbatim}

Now, the size of x4 is significantly lower than that of x5 . This seems to indicate that ALTREP becomes super efficient as the vector size is increased.

\hypertarget{modify-in-place}{%
\section*{2.5.1 Modify-in-place}\label{modify-in-place}}
\addcontentsline{toc}{section}{2.5.1 Modify-in-place}

``When it comes to bindings, R can currently only count 0, 1, or many. That means that if an object has two bindings, and one goes away, the reference count does not go back to 1: one less than many is still many. In turn, this means that R will make copies when it sometimes doesn't need to.''

Can we come up with an example of this? It seems really theoretical right now.

First you need to switch your Environment tab to something other than global in RStudio!

Now we can create a vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{(old_address <-}\StringTok{ }\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(v))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x7f93c3a02558"
\end{verbatim}

Changing a value within it changes its address:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v[[}\DecValTok{3}\NormalTok{]] <-}\StringTok{ }\DecValTok{4}
\NormalTok{(new_address <-}\StringTok{ }\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(v))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x7f93c2b75138"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{old_address }\OperatorTok{==}\StringTok{ }\NormalTok{new_address}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

We can assign the modified vector to a new name, where \texttt{y} and \texttt{v} point to the same thing.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\NormalTok{v}
\NormalTok{(y_address <-}\StringTok{ }\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(y))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x7f93c2b75138"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(v_address <-}\StringTok{ }\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(v))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x7f93c2b75138"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y_address }\OperatorTok{==}\StringTok{ }\NormalTok{v_address}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

Now if we modify \texttt{v} it won't point to the same thing as \texttt{y}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v[[}\DecValTok{3}\NormalTok{]] <-}\StringTok{ }\DecValTok{3}
\NormalTok{(y_address <-}\StringTok{ }\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(y))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x7f93c2b75138"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(v_address <-}\StringTok{ }\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(v))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x7f93c255bce8"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y_address }\OperatorTok{==}\StringTok{ }\NormalTok{v_address}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

But if we now change \texttt{y} to look like \texttt{v}, the original address, in theory editing y should occur in place, but it doesn't - the ``count does not go back to one''!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y[[}\DecValTok{3}\NormalTok{]] <-}\StringTok{ }\DecValTok{3}
\NormalTok{(new_y_address <-}\StringTok{ }\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_addr}\NormalTok{(y))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0x7f93bca432d8"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_y_address }\OperatorTok{==}\StringTok{ }\NormalTok{y_address}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Can we break down this code a bit more? I'd like to really understand when and how it's copying three times. \textbf{As of R 4.0 it's now copied twice, the 3rd copy that's external to the function is now eliminated!!}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# dataframe of 5 columns of numbers}
\NormalTok{x <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\KeywordTok{matrix}\NormalTok{(}\KeywordTok{runif}\NormalTok{(}\DecValTok{5} \OperatorTok{*}\StringTok{ }\FloatTok{1e4}\NormalTok{), }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{))}
\CommentTok{# median number for each column}
\NormalTok{medians <-}\StringTok{ }\KeywordTok{vapply}\NormalTok{(x, median, }\KeywordTok{numeric}\NormalTok{(}\DecValTok{1}\NormalTok{))}

\CommentTok{# subtract the median of each column from each value in the column}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(medians)) \{}
\NormalTok{  x[[i]] <-}\StringTok{ }\NormalTok{x[[i]] }\OperatorTok{-}\StringTok{ }\NormalTok{medians[[i]]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cat}\NormalTok{(}\KeywordTok{tracemem}\NormalTok{(x), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<0x7fdc99a6f9a8> 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{) \{}
\NormalTok{  x[[i]] <-}\StringTok{ }\NormalTok{x[[i]] }\OperatorTok{-}\StringTok{ }\NormalTok{medians[[i]]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
tracemem[0x7fdc99a6f9a8 -> 0x7fdc9de83e38]: 
tracemem[0x7fdc9de83e38 -> 0x7fdc9de83ea8]: [[<-.data.frame [[<- 
tracemem[0x7fdc9de83ea8 -> 0x7fdc9de83f18]: [[<-.data.frame [[<- 
tracemem[0x7fdc9de83f18 -> 0x7fdc9de83f88]: 
tracemem[0x7fdc9de83f88 -> 0x7fdc9de83ff8]: [[<-.data.frame [[<- 
tracemem[0x7fdc9de83ff8 -> 0x7fdc9de84068]: [[<-.data.frame [[<- 
tracemem[0x7fdc9de84068 -> 0x7fdc9de840d8]: 
tracemem[0x7fdc9de840d8 -> 0x7fdc9de84148]: [[<-.data.frame [[<- 
tracemem[0x7fdc9de84148 -> 0x7fdc9de841b8]: [[<-.data.frame [[<- 
tracemem[0x7fdc9de841b8 -> 0x7fdc9de84228]: 
tracemem[0x7fdc9de84228 -> 0x7fdc9de84298]: [[<-.data.frame [[<- 
tracemem[0x7fdc9de84298 -> 0x7fdc9de84308]: [[<-.data.frame [[<- 
tracemem[0x7fdc9de84308 -> 0x7fdc9de84378]: 
tracemem[0x7fdc9de84378 -> 0x7fdc9de843e8]: [[<-.data.frame [[<- 
tracemem[0x7fdc9de843e8 -> 0x7fdc9de84458]: [[<-.data.frame [[<- 
\end{verbatim}

When we run \texttt{tracemem} on the for loop above we see each column is copied twice followed by the \texttt{{[}{[}\textless{}-.data.frame\ {[}{[}\textless{}-}, the stack trace showing exactly where the duplication occurred.

So what is \texttt{{[}{[}\textless{}-.data.frame}? It's a function! By looking at `?\texttt{{[}{[}\textless{}-.data.frame} we see this is used to ``extract or replace subsets of data frames.''

When we write \texttt{x{[}{[}i{]}{]}\ \textless{}-\ value}, it's really shorthand for calling the function \texttt{{[}{[}\textless{}-.data.frame} with inputs \texttt{x}, \texttt{i}, and \texttt{value}.

Now let's step into the call of this base function by running \texttt{debug(\textasciigrave{}\textasciigrave{}{[}{[}\textless{}-.data.frame\textasciigrave{}\textasciigrave{})}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{debug}\NormalTok{(}\StringTok{`}\DataTypeTok{[[<-.data.frame}\StringTok{`}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

and once inside, use \texttt{tracemem()} to find where the new values are assigned to the column:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{function}\NormalTok{ (x, i, j, value) }
\NormalTok{\{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{all}\NormalTok{(}\KeywordTok{names}\NormalTok{(}\KeywordTok{sys.call}\NormalTok{()) }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{""}\NormalTok{, }\StringTok{"value"}\NormalTok{))) }
    \KeywordTok{warning}\NormalTok{(}\StringTok{"named arguments are discouraged"}\NormalTok{)}
\NormalTok{  cl <-}\StringTok{ }\KeywordTok{oldClass}\NormalTok{(x)}
  \CommentTok{# this is where another copy of x is made!}
  \KeywordTok{class}\NormalTok{(x) <-}\StringTok{ }\OtherTok{NULL}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 # tracemem[0x7fdc9d852a18 -> 0x7fdc9c99cc08]: 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nrows <-}\StringTok{ }\KeywordTok{.row_names_info}\NormalTok{(x, 2L)}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.atomic}\NormalTok{(value) }\OperatorTok{&&}\StringTok{ }\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(}\KeywordTok{names}\NormalTok{(value))) }
    \KeywordTok{names}\NormalTok{(value) <-}\StringTok{ }\OtherTok{NULL}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{nargs}\NormalTok{() }\OperatorTok{<}\StringTok{ }\NormalTok{4L) \{}
\NormalTok{    nc <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(value)) \{}
\NormalTok{      N <-}\StringTok{ }\KeywordTok{NROW}\NormalTok{(value)}
      \ControlFlowTok{if}\NormalTok{ (N }\OperatorTok{>}\StringTok{ }\NormalTok{nrows) }
        \KeywordTok{stop}\NormalTok{(}\KeywordTok{sprintf}\NormalTok{(}\KeywordTok{ngettext}\NormalTok{(N, }\StringTok{"replacement has %d row, data has %d"}\NormalTok{, }
          \StringTok{"replacement has %d rows, data has %d"}\NormalTok{), N, }
\NormalTok{          nrows), }\DataTypeTok{domain =} \OtherTok{NA}\NormalTok{)}
      \ControlFlowTok{if}\NormalTok{ (N }\OperatorTok{<}\StringTok{ }\NormalTok{nrows) }
        \ControlFlowTok{if}\NormalTok{ (N }\OperatorTok{>}\StringTok{ }\NormalTok{0L }\OperatorTok{&&}\StringTok{ }\NormalTok{(nrows}\OperatorTok{%%}\NormalTok{N }\OperatorTok{==}\StringTok{ }\NormalTok{0L) }\OperatorTok{&&}\StringTok{ }\KeywordTok{length}\NormalTok{(}\KeywordTok{dim}\NormalTok{(value)) }\OperatorTok{<=}\StringTok{ }
\StringTok{          }\NormalTok{1L) }
\NormalTok{          value <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(value, }\DataTypeTok{length.out =}\NormalTok{ nrows)}
        \ControlFlowTok{else} \KeywordTok{stop}\NormalTok{(}\KeywordTok{sprintf}\NormalTok{(}\KeywordTok{ngettext}\NormalTok{(N, }\StringTok{"replacement has %d row, data has %d"}\NormalTok{, }
          \StringTok{"replacement has %d rows, data has %d"}\NormalTok{), N, }
\NormalTok{          nrows), }\DataTypeTok{domain =} \OtherTok{NA}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{    x[[i]] <-}\StringTok{ }\NormalTok{value}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(x) }\OperatorTok{>}\StringTok{ }\NormalTok{nc) \{}
\NormalTok{      nc <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{names}\NormalTok{(x)[nc] }\OperatorTok{==}\StringTok{ ""}\NormalTok{) }
        \KeywordTok{names}\NormalTok{(x)[nc] <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"V"}\NormalTok{, nc)}
      \KeywordTok{names}\NormalTok{(x) <-}\StringTok{ }\KeywordTok{make.unique}\NormalTok{(}\KeywordTok{names}\NormalTok{(x))}
\NormalTok{    \}}
    \KeywordTok{class}\NormalTok{(x) <-}\StringTok{ }\NormalTok{cl}
    \KeywordTok{return}\NormalTok{(x)}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{missing}\NormalTok{(i) }\OperatorTok{||}\StringTok{ }\KeywordTok{missing}\NormalTok{(j)) }
    \KeywordTok{stop}\NormalTok{(}\StringTok{"only valid calls are x[[j]] <- value or x[[i,j]] <- value"}\NormalTok{)}
\NormalTok{  rows <-}\StringTok{ }\KeywordTok{attr}\NormalTok{(x, }\StringTok{"row.names"}\NormalTok{)}
\NormalTok{  nvars <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
  \ControlFlowTok{if}\NormalTok{ (n <-}\StringTok{ }\KeywordTok{is.character}\NormalTok{(i)) \{}
\NormalTok{    ii <-}\StringTok{ }\KeywordTok{match}\NormalTok{(i, rows)}
\NormalTok{    n <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(new.rows <-}\StringTok{ }\KeywordTok{is.na}\NormalTok{(ii))}
    \ControlFlowTok{if}\NormalTok{ (n }\OperatorTok{>}\StringTok{ }\NormalTok{0L) \{}
\NormalTok{      ii[new.rows] <-}\StringTok{ }\KeywordTok{seq.int}\NormalTok{(}\DataTypeTok{from =}\NormalTok{ nrows }\OperatorTok{+}\StringTok{ }\NormalTok{1L, }\DataTypeTok{length.out =}\NormalTok{ n)}
\NormalTok{      new.rows <-}\StringTok{ }\NormalTok{i[new.rows]}
\NormalTok{    \}}
\NormalTok{    i <-}\StringTok{ }\NormalTok{ii}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{all}\NormalTok{(i }\OperatorTok{>=}\StringTok{ }\NormalTok{0L) }\OperatorTok{&&}\StringTok{ }\NormalTok{(nn <-}\StringTok{ }\KeywordTok{max}\NormalTok{(i)) }\OperatorTok{>}\StringTok{ }\NormalTok{nrows) \{}
    \ControlFlowTok{if}\NormalTok{ (n }\OperatorTok{==}\StringTok{ }\NormalTok{0L) \{}
\NormalTok{      nrr <-}\StringTok{ }\NormalTok{(nrows }\OperatorTok{+}\StringTok{ }\NormalTok{1L)}\OperatorTok{:}\NormalTok{nn}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{inherits}\NormalTok{(value, }\StringTok{"data.frame"}\NormalTok{) }\OperatorTok{&&}\StringTok{ }\NormalTok{(}\KeywordTok{dim}\NormalTok{(value)[1L]) }\OperatorTok{>=}\StringTok{ }
\StringTok{        }\KeywordTok{length}\NormalTok{(nrr)) \{}
\NormalTok{        new.rows <-}\StringTok{ }\KeywordTok{attr}\NormalTok{(value, }\StringTok{"row.names"}\NormalTok{)[}\KeywordTok{seq_len}\NormalTok{(nrr)]}
\NormalTok{        repl <-}\StringTok{ }\KeywordTok{duplicated}\NormalTok{(new.rows) }\OperatorTok{|}\StringTok{ }\KeywordTok{match}\NormalTok{(new.rows, }
\NormalTok{          rows, 0L)}
        \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{any}\NormalTok{(repl)) }
\NormalTok{          new.rows[repl] <-}\StringTok{ }\NormalTok{nrr[repl]}
\NormalTok{      \}}
      \ControlFlowTok{else}\NormalTok{ new.rows <-}\StringTok{ }\NormalTok{nrr}
\NormalTok{    \}}
\NormalTok{    x <-}\StringTok{ }\KeywordTok{xpdrows.data.frame}\NormalTok{(x, rows, new.rows)}
\NormalTok{    rows <-}\StringTok{ }\KeywordTok{attr}\NormalTok{(x, }\StringTok{"row.names"}\NormalTok{)}
\NormalTok{    nrows <-}\StringTok{ }\KeywordTok{length}\NormalTok{(rows)}
\NormalTok{  \}}
\NormalTok{  iseq <-}\StringTok{ }\KeywordTok{seq_len}\NormalTok{(nrows)[i]}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{anyNA}\NormalTok{(iseq)) }
    \KeywordTok{stop}\NormalTok{(}\StringTok{"non-existent rows not allowed"}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.character}\NormalTok{(j)) \{}
    \ControlFlowTok{if}\NormalTok{ (}\StringTok{""} \OperatorTok{%in%}\StringTok{ }\NormalTok{j) }
      \KeywordTok{stop}\NormalTok{(}\StringTok{"column name }\CharTok{\textbackslash{}"\textbackslash{}"}\StringTok{ cannot match any column"}\NormalTok{)}
\NormalTok{    jseq <-}\StringTok{ }\KeywordTok{match}\NormalTok{(j, }\KeywordTok{names}\NormalTok{(x))}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{anyNA}\NormalTok{(jseq)) }
      \KeywordTok{stop}\NormalTok{(}\KeywordTok{gettextf}\NormalTok{(}\StringTok{"replacing element in non-existent column: %s"}\NormalTok{, }
\NormalTok{        j[}\KeywordTok{is.na}\NormalTok{(jseq)]), }\DataTypeTok{domain =} \OtherTok{NA}\NormalTok{)}
\NormalTok{  \}}
  \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.logical}\NormalTok{(j) }\OperatorTok{||}\StringTok{ }\KeywordTok{min}\NormalTok{(j) }\OperatorTok{<}\StringTok{ }\NormalTok{0L) }
\NormalTok{    jseq <-}\StringTok{ }\KeywordTok{seq_along}\NormalTok{(x)[j]}
  \ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    jseq <-}\StringTok{ }\NormalTok{j}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{max}\NormalTok{(jseq) }\OperatorTok{>}\StringTok{ }\NormalTok{nvars) }
      \KeywordTok{stop}\NormalTok{(}\KeywordTok{gettextf}\NormalTok{(}\StringTok{"replacing element in non-existent column: %s"}\NormalTok{, }
\NormalTok{        jseq[jseq }\OperatorTok{>}\StringTok{ }\NormalTok{nvars]), }\DataTypeTok{domain =} \OtherTok{NA}\NormalTok{)}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(iseq) }\OperatorTok{>}\StringTok{ }\NormalTok{1L }\OperatorTok{||}\StringTok{ }\KeywordTok{length}\NormalTok{(jseq) }\OperatorTok{>}\StringTok{ }\NormalTok{1L) }
    \KeywordTok{stop}\NormalTok{(}\StringTok{"only a single element should be replaced"}\NormalTok{)}
\NormalTok{  x[[jseq]][[iseq]] <-}\StringTok{ }\NormalTok{value}
  \CommentTok{# here is where x is copied again!}
  \KeywordTok{class}\NormalTok{(x) <-}\StringTok{ }\NormalTok{cl}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# tracemem[0x7fdc992ae9d8 -> 0x7fdc9be55258]: 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  x}
\ErrorTok{\}}
\end{Highlighting}
\end{Shaded}

Thus seeing exactly where the three \textbf{as of R 4.0: two!} copies are happening.

\hypertarget{vectors}{%
\chapter{Vectors}\label{vectors}}

\hypertarget{scalars}{%
\section*{3.2.1 Scalars}\label{scalars}}
\addcontentsline{toc}{section}{3.2.1 Scalars}

Can you have \texttt{NA} in vector

Hell yeah!

\hypertarget{missing-values}{%
\section*{3.2.3 Missing values}\label{missing-values}}
\addcontentsline{toc}{section}{3.2.3 Missing values}

\texttt{NA} is a `sentinel' value for explicit missingness - what does `sentinel' mean?

A sentinel value (also referred to as a flag value, trip value, rogue value, signal value, or dummy data) is a special value in the context of an algorithm which uses its presence as a condition of termination. Also worth noting two NAs are not equal to each other! For instance, in C++ there's a special character to identify the end of a string I think another example of a sentinel value might be in surveys where you sometimes see missing data or N/A coded as 999, or 9999 (or maybe just 9)

Another example of a sentinel value might be in surveys where you sometimes see missing data or \texttt{N/A} coded as \texttt{999}, or \texttt{9999} (or maybe just \texttt{9}). The possible values in a column of data might be:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{9}\NormalTok{), }\DataTypeTok{levels =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{9}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Sentinels are typically employed in situations where it's easier/preferable to have a collection of values of the same type - represented internally using the same conventions and requiring the same amount of memory - but you also need a way to indicate a special circumstance. So like in the case of survey data you may, for example, see a variable indicating that an individual is \texttt{999} years old but the correct way to interpret that is that the data was not collected.

\hypertarget{testing-and-coercion}{%
\section*{3.2.4 Testing and coercion}\label{testing-and-coercion}}
\addcontentsline{toc}{section}{3.2.4 Testing and coercion}

Why does the book warn us against using \texttt{is.vector()}, \texttt{is.atomic()} and \texttt{is.numeric()}? {[}read docs{]}

\begin{itemize}
\tightlist
\item
  \texttt{is.atomic} will also return true if \texttt{NULL}
\item
  \texttt{is.numeric} tests if integer or double \textbf{NOT} factor, Date, POSIXt, difftime
\item
  \texttt{is.vector} will return false if it has attributes other than names
\end{itemize}

\hypertarget{setting-attributes}{%
\section*{3.3.1 Setting Attributes}\label{setting-attributes}}
\addcontentsline{toc}{section}{3.3.1 Setting Attributes}

Working in the medical field I have to import SAS files a lot where the column names have to adhere to specific abbreviations so they're given a label attribute for their full name. What are some other common uses for attributes?

Hypothesis test attributes!

\hypertarget{setnames}{%
\section*{3.3.2 setNames}\label{setnames}}
\addcontentsline{toc}{section}{3.3.2 setNames}

We can use \texttt{setNames} to apply different values to each element in a vector. How do we do this for our own custom attribute? The code below does NOT work!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_vector <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \KeywordTok{structure}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DataTypeTok{x =} \StringTok{"firstatt_1"}\NormalTok{),}
  \KeywordTok{structure}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DataTypeTok{x =} \StringTok{"firstatt_2"}\NormalTok{), }
  \KeywordTok{structure}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DataTypeTok{x =} \StringTok{"firstatt_3"}\NormalTok{)}
\NormalTok{)}

\NormalTok{my_vector <-}\StringTok{ }\KeywordTok{setNames}\NormalTok{(my_vector, }\KeywordTok{c}\NormalTok{(}\StringTok{"name_1"}\NormalTok{, }\StringTok{"name_2"}\NormalTok{, }\StringTok{"name_3"}\NormalTok{))}

\CommentTok{# mental model: shouldn't this should return $names and $x?}
\KeywordTok{attributes}\NormalTok{(my_vector)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $names
## [1] "name_1" "name_2" "name_3"
\end{verbatim}

As soon as you instantiate a vector the attributes are lost. BUT we can store it as a list \emph{within} the vector to keep them! We can create a custom attribute function and use that with \texttt{map} to add a list inside our dataframe:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{custom_attr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, my_attr) \{}
  \KeywordTok{attr}\NormalTok{(x, }\StringTok{"x"}\NormalTok{) <-}\StringTok{ }\NormalTok{my_attr}
  \KeywordTok{return}\NormalTok{(x)}
\NormalTok{\}}

\NormalTok{as_tb <-}\StringTok{ }
\StringTok{  }\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{one =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{),}
  \DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\StringTok{"att_1"}\NormalTok{, }\StringTok{"att_2"}\NormalTok{, }\StringTok{"att_3"}\NormalTok{),}
  \DataTypeTok{with_arr =} \KeywordTok{map2}\NormalTok{(one, x, }\OperatorTok{~}\KeywordTok{custom_attr}\NormalTok{(.x, .y))}
\NormalTok{)}

\NormalTok{as_tb}\OperatorTok{$}\NormalTok{with_arr}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1
## attr(,"x")
## [1] "att_1"
## 
## [[2]]
## [1] 2
## attr(,"x")
## [1] "att_2"
## 
## [[3]]
## [1] 3
## attr(,"x")
## [1] "att_3"
\end{verbatim}

\hypertarget{dimensions}{%
\section*{3.3.3 Dimensions}\label{dimensions}}
\addcontentsline{toc}{section}{3.3.3 Dimensions}

Because \texttt{NROW} and \texttt{NCOL} don't return \texttt{NULL} on a one dimensional vector they just seem to me as a more flexible option. When do you \emph{have} to use \texttt{ncol} and \texttt{nrow}?

It \emph{may} be better practice to always use \texttt{NROW} and \texttt{NCOL}!

As long as the number of rows matches the data frame, it's also possible to have a matrix or array as a column of a data frame. (This requires a slight extension to our definition of a data frame: it's not the \texttt{length()} of each column that must be equal, but the \texttt{NROW()}.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{),}
                 \DataTypeTok{y =} \KeywordTok{c}\NormalTok{(letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{]))}

\KeywordTok{length}\NormalTok{(df}\OperatorTok{$}\NormalTok{y) }\OperatorTok{==}\StringTok{ }\KeywordTok{NROW}\NormalTok{(df}\OperatorTok{$}\NormalTok{y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

What's an example of where \texttt{length()\ !=\ NROW()}

The case of a matrix!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_matrix <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{6}
\KeywordTok{dim}\NormalTok{(my_matrix) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\NormalTok{my_matrix}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(my_matrix) }\OperatorTok{==}\StringTok{ }\KeywordTok{NROW}\NormalTok{(my_matrix) }\CommentTok{# 6 != 3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(my_matrix) }\OperatorTok{==}\StringTok{ }\KeywordTok{NCOL}\NormalTok{(my_matrix) }\CommentTok{# 6 != 2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

The length of the matrix is \texttt{6}, and if we manipulate the dimensions of the matrix we see that the NROW is \texttt{3} and and NCOL is \texttt{2}.

\hypertarget{s3-atomic-vectors}{%
\section*{3.4 S3 atomic vectors}\label{s3-atomic-vectors}}
\addcontentsline{toc}{section}{3.4 S3 atomic vectors}

How is data type \texttt{typeof()} different from \texttt{class()}?

Classes are built on top of base types - they're like special, more specific kinds of types. In fact, if a class isn't specified then \texttt{class()} will default to either the \texttt{implicit\ class} or \texttt{typeof}.

So \texttt{Date}, \texttt{POSIXct}, and \texttt{difftime} are specific kinds of doubles, falling under its umbrella.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lubridate}\OperatorTok{::}\KeywordTok{is.Date}\NormalTok{(}\KeywordTok{Sys.Date}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.double}\NormalTok{(}\KeywordTok{Sys.Date}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lubridate}\OperatorTok{::}\KeywordTok{is.POSIXct}\NormalTok{(}\KeywordTok{Sys.time}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.double}\NormalTok{(}\KeywordTok{Sys.time}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lubridate}\OperatorTok{::}\KeywordTok{is.difftime}\NormalTok{(}\KeywordTok{as.difftime}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"0:3:20"}\NormalTok{, }\StringTok{"11:23:15"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.double}\NormalTok{(}\KeywordTok{as.difftime}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"0:3:20"}\NormalTok{, }\StringTok{"11:23:15"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

But then why does \texttt{my\_factor} fail to be recognized under its more general \texttt{integer} umbrella?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_factor <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{))}
\KeywordTok{is.factor}\NormalTok{(my_factor)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.integer}\NormalTok{(my_factor)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

XXX

\hypertarget{dates}{%
\section*{3.4.2 Dates}\label{dates}}
\addcontentsline{toc}{section}{3.4.2 Dates}

Why are dates calculated from January 1st, 1970?

Unix counts time in seconds since its official ``birthday,'' -- called ``epoch'' in computing terms -- which is Jan.~1, 1970. \href{https://www.wired.com/2001/09/unix-tick-tocks-to-a-billion/}{This article} explains that the early Unix engineers picked that date arbitrarily, because they needed to set a uniform date for the start of time, and New Year's Day, 1970, seemed most convenient.

\hypertarget{lists-1}{%
\section*{3.5.1 Lists}\label{lists-1}}
\addcontentsline{toc}{section}{3.5.1 Lists}

When should you be using \texttt{list()} instead of \texttt{c()}

It's really contingent on the use case. In the case of adding custom classes it's worth noting that those are lost once you \texttt{c()} those objects together!

\hypertarget{data-frames-and-tibbles}{%
\section*{3.6.8 Data frames and tibbles}\label{data-frames-and-tibbles}}
\addcontentsline{toc}{section}{3.6.8 Data frames and tibbles}

What does `lazy' mean in terms of \texttt{as\_tibble}?

Technically \texttt{lazy\ evaluation} means that expressions are not evaluated when they are bound to variables, but their evaluation is deferred until their results are needed by other computations. In this context though we think Hadley just meant that it's treated as a character if it ``looks and smells like a character''.

The solution manual gives the answer and notes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df_coltypes <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{a =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{),}
  \DataTypeTok{b =} \KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{),}
  \DataTypeTok{c =} \KeywordTok{c}\NormalTok{(1L, 0L),}
  \DataTypeTok{d =} \KeywordTok{c}\NormalTok{(}\FloatTok{1.5}\NormalTok{, }\DecValTok{2}\NormalTok{),}
  \DataTypeTok{e =} \KeywordTok{c}\NormalTok{(}\StringTok{"one"}\NormalTok{ =}\StringTok{ }\DecValTok{1}\NormalTok{, }\StringTok{"two"}\NormalTok{ =}\StringTok{ }\DecValTok{2}\NormalTok{),}
  \DataTypeTok{g =} \KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"f1"}\NormalTok{, }\StringTok{"f2"}\NormalTok{)),}
  \DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}
\NormalTok{)}

\KeywordTok{as.matrix}\NormalTok{(df_coltypes)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     a   b       c   d     e   g   
## one "a" "TRUE"  "1" "1.5" "1" "f1"
## two "b" "FALSE" "0" "2.0" "2" "f2"
\end{verbatim}

``Note that \texttt{format()} is applied to the characters, which gives surprising results: \texttt{TRUE} is transformed to \texttt{"\ TRUE"} (starting with a space!).''

\ldots{}But where is the \texttt{format()} call happening? I don't see a space!

After running \texttt{debug(as.matrix(df\_coltypes))} and going down a rabbit hole we found this is a bug that has been addressed! \href{https://github.com/Tazinho/Advanced-R-Solutions/issues/213}{See issue here}

\hypertarget{conclusion}{%
\section*{Conclusion}\label{conclusion}}
\addcontentsline{toc}{section}{Conclusion}

How does vectorization make your code faster

Taking the example from \href{https://csgillespie.github.io/efficientR/programming.html\#vectorised-code}{Efficient R Programming}:

\hypertarget{vectorized}{%
\subsection*{VECTORIZED:}\label{vectorized}}
\addcontentsline{toc}{subsection}{VECTORIZED:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\KeywordTok{log}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\hypertarget{non-vectorized}{%
\subsection*{NON-VECTORIZED:}\label{non-vectorized}}
\addcontentsline{toc}{subsection}{NON-VECTORIZED:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s <-}\StringTok{ }\DecValTok{0}
\ControlFlowTok{for}\NormalTok{(x0 }\ControlFlowTok{in}\NormalTok{ x) \{}
\NormalTok{  s <-}\StringTok{ }\NormalTok{s }\OperatorTok{+}\StringTok{ }\KeywordTok{log}\NormalTok{(x0)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The vectorized code is faster because it obeys the golden rule of R programming: \emph{``access the underlying C/Fortran routines as quickly as possible; the fewer functions calls required to achieve this, the better''}.

\begin{itemize}
\tightlist
\item
  Vectorized Version:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    \texttt{sum} {[}called once{]}
  \item
    \texttt{log} {[}called once{]}
  \end{enumerate}
\item
  Non-vectorized:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    \texttt{+} {[}called \texttt{length(x)} times{]}
  \item
    \texttt{log} {[}called \texttt{length(x)} times{]}
  \end{enumerate}
\end{itemize}

In the vectorised version, there are two primitive function calls: one to \texttt{log} (which performs \texttt{length(x)} steps in the C level) and one to \texttt{sum} (which performs \texttt{x} updates in the C level). So you end up doing a similar number of operations at C level regardless of the route.

In the non-vectorised form you are passing the logic back and forth between R and C many many times and this is why the non-vectorised form is much slower.

\textbf{A vectorized function calls primitives directly, but a loop calls each function \texttt{length(x)} times, and there are \texttt{1\ +\ length(x)} assignments to \texttt{s}. Theres on the order of 3x primitive function calls in the non-vectorised form!!}

Resources:

\begin{itemize}
\item
  \href{https://speakerdeck.com/jennybc/row-oriented-workflows-in-r-with-the-tidyverse}{Check out Jenny Brian's slides}
\item
  \href{https://www.noamross.net/archives/2014-04-16-vectorization-in-r-why/}{Great article by Noam Ross}
\end{itemize}

Putting it all together in a single diagram:

\includegraphics[width=26.44in]{images/vectors}

\hypertarget{subsetting}{%
\chapter{Subsetting}\label{subsetting}}

\hypertarget{introduction}{%
\section*{4.1 Introduction}\label{introduction}}
\addcontentsline{toc}{section}{4.1 Introduction}

"There are three subsetting operators \texttt{{[}}. \texttt{{[}{[}}, \texttt{\$}. What is the distinction between an operator and a function? When you look up the help page it brings up the same page for all three extraction methods. What are their distinctions and do their definitions change based on what you're subsetting? Can we make a table?

{[}

{[}{[}

\$

ATOMIC

RETURNS VECTOR WITH ONE ELEMENT

SAME AS {[}

NOPE!

LIST

RETURNS A LIST

RETURNS SINGLE ELEMENT FROM WITHIN LIST

RETURN SINGLE ELEMENT FROM LIST {[}CAN ONLY USE WHEN LIST VECTOR HAS A NAME{]}

MATRIX

RETURNS A VECTOR

RETURNS A VECTOR OR SINGLE VALUE

NOPE!

DATA FRAME

RETURNS A VECTOR OR DATA FRAME

RETURNS VECTOR/LIST/MATRIX OR SINGLE VALUE

RETURNS VECTOR/LIST/MATRIX USING COLUMN NAME

TIBBLE

RETURNS A TIBBLE

RETURNS A VECTOR OR SINGLE VALUE

RETURNS THE STR OF THE COLUMN - TIBBLE/LIST/MATRIX

If we think of everything as sets (which have the properties of 0,1, or many elements), if the set has 1 element it only contains itself and \texttt{NULL} subsets. Before you subset using \texttt{{[}} or \texttt{{[}{[}} count the elements in the set. If it has zero elements you are done, if it has one element \texttt{{[}} will return itself - to go further you need to use \texttt{{[}{[}} to return its contents. If there is more than one element in the set then \texttt{{[}} will return those elements. \href{https://bookdown.org/rdpeng/rprogdatascience/subsetting-r-objects.html\#subsetting-a-vector}{You can read more about subsetting here}

\hypertarget{selecting-multiple-elements}{%
\section*{4.2.1 Selecting multiple elements}\label{selecting-multiple-elements}}
\addcontentsline{toc}{section}{4.2.1 Selecting multiple elements}

Why is \texttt{numeric(0)} ``helpful for test data?''

This is more of a general comment that one should make sure one's code doesn't crash with vectors of zero length (or data frames with zero rows)

Why is subsetting with factors ``not a good idea''

Hadley's notes seem to say subsetting with factors uses the ``integer vector of levels'' - and if they all have the same level, it'll just return the first argument. Subsetting a factor vector leaves the factor levels behind unless you explicitly drop the unused levels

\hypertarget{lists-2}{%
\section*{4.2.2 lists}\label{lists-2}}
\addcontentsline{toc}{section}{4.2.2 lists}

We've been talking about \texttt{\$} as a shorthand for \texttt{{[}{[}}. Using the example list \texttt{x\ \textless{}-\ list(1:3,\ "a",\ 4:6)} can we use \texttt{x\$1} as shorthand for \texttt{x{[}{[}1{]}{]}}?

The ``shorthand'' refers to using the name of the vector to extract the vector. If we give \texttt{1:3} a name such as test = \texttt{1:3}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{named_vector =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\DecValTok{4}\OperatorTok{:}\DecValTok{6}\NormalTok{)}
\NormalTok{x[[}\DecValTok{1}\NormalTok{]] }\OperatorTok{==}\StringTok{ }\NormalTok{x}\OperatorTok{$}\NormalTok{named_vector}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE TRUE TRUE
\end{verbatim}

As such, \texttt{\$} is a shorthand for \texttt{x{[}{[}"name\_of\_vector"{]}{]}} and not shorthand for \texttt{x{[}{[}index{]}{]}}

\hypertarget{section}{%
\section*{\texorpdfstring{4.3.1 \texttt{{[}{[}}}{4.3.1 {[}{[}}}\label{section}}
\addcontentsline{toc}{section}{4.3.1 \texttt{{[}{[}}}

The book states:

\emph{While you must use {[}{[} when working with lists, I'd also recommend using it with atomic vectors whenever you want to extract a single value. For example, instead of writing:}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{2}\OperatorTok{:}\KeywordTok{length}\NormalTok{(x)) \{}
\NormalTok{  out[i] <-}\StringTok{ }\KeywordTok{fun}\NormalTok{(x[i], out[i }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{])}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\emph{It's better to write}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{2}\OperatorTok{:}\KeywordTok{length}\NormalTok{(x)) \{}
\NormalTok{  out[[i]] <-}\StringTok{ }\KeywordTok{fun}\NormalTok{(x[[i]], out[[i }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{]])}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Why? Can we see this in action by giving \texttt{x}, \texttt{out}, and \texttt{fun} real life values?

If we have a vector

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df_x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Advanced"}\NormalTok{,}\StringTok{"R"}\NormalTok{,}\StringTok{"Book"}\NormalTok{,}\StringTok{"Club"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can use \texttt{{[}} or \texttt{{[}{[}} to extract the third element of \texttt{df\_x}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df_x[}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Book"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df_x[[}\DecValTok{3}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Book"
\end{verbatim}

But in the case where we want to extract an element from a list \texttt{{[}} and \texttt{{[}{[}} no longer give us the same results

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df_x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{A =} \StringTok{"Advanced"}\NormalTok{, }\DataTypeTok{B =} \StringTok{"R"}\NormalTok{, }\DataTypeTok{C =} \StringTok{"Book"}\NormalTok{, }\DataTypeTok{D =} \StringTok{"Club"}\NormalTok{)}

\NormalTok{df_x[}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $C
## [1] "Book"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df_x[[}\DecValTok{3}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Book"
\end{verbatim}

Because using \texttt{{[}{[}} returns ``one element of this vector'' in both cases, it makes sense to default to \texttt{{[}{[}} instead of \texttt{{[}} since it will reliably return a single element.

\hypertarget{exercise-1}{%
\section*{4.3.5 Exercise}\label{exercise-1}}
\addcontentsline{toc}{section}{4.3.5 Exercise}

The question asks to describe the \texttt{upper.tri} function - let's dig into it!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{outer}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{FUN =} \StringTok{"*"}\NormalTok{)}
\KeywordTok{upper.tri}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       [,1]  [,2]  [,3]  [,4]  [,5]
## [1,] FALSE  TRUE  TRUE  TRUE  TRUE
## [2,] FALSE FALSE  TRUE  TRUE  TRUE
## [3,] FALSE FALSE FALSE  TRUE  TRUE
## [4,] FALSE FALSE FALSE FALSE  TRUE
## [5,] FALSE FALSE FALSE FALSE FALSE
\end{verbatim}

We see that it returns the upper triangle of the matrix. But I wanted to walk through how this function actually works and what is meant in the solution manual by leveraging \texttt{.row(dim(x))\ \textless{}=\ .col(dim(x))}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# ?upper.tri}
\ControlFlowTok{function}\NormalTok{ (x, }\DataTypeTok{diag =} \OtherTok{FALSE}\NormalTok{) }
\NormalTok{\{}
\NormalTok{    d <-}\StringTok{ }\KeywordTok{dim}\NormalTok{(x)}
    \CommentTok{# if you have an array thats more than 2 dimension}
    \CommentTok{# we need to flatten it to a matrix}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(d) }\OperatorTok{!=}\StringTok{ }\NormalTok{2L) }
\NormalTok{        d <-}\StringTok{ }\KeywordTok{dim}\NormalTok{(}\KeywordTok{as.matrix}\NormalTok{(x))}
    \ControlFlowTok{if}\NormalTok{ (diag) }
      \CommentTok{# this is our subsetting logical!}
         \KeywordTok{.row}\NormalTok{(d) }\OperatorTok{<=}\StringTok{ }\KeywordTok{.col}\NormalTok{(d)}
    \ControlFlowTok{else} \KeywordTok{.row}\NormalTok{(d) }\OperatorTok{<}\StringTok{ }\KeywordTok{.col}\NormalTok{(d)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The function \texttt{.row()} and \texttt{.col()} return a matrix of integers indicating their row number

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{.row}\NormalTok{(}\KeywordTok{dim}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    1    1    1    1
## [2,]    2    2    2    2    2
## [3,]    3    3    3    3    3
## [4,]    4    4    4    4    4
## [5,]    5    5    5    5    5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{.col}\NormalTok{(}\KeywordTok{dim}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    2    3    4    5
## [2,]    1    2    3    4    5
## [3,]    1    2    3    4    5
## [4,]    1    2    3    4    5
## [5,]    1    2    3    4    5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{.row}\NormalTok{(}\KeywordTok{dim}\NormalTok{(x)) }\OperatorTok{<=}\StringTok{ }\KeywordTok{.col}\NormalTok{(}\KeywordTok{dim}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       [,1]  [,2]  [,3]  [,4] [,5]
## [1,]  TRUE  TRUE  TRUE  TRUE TRUE
## [2,] FALSE  TRUE  TRUE  TRUE TRUE
## [3,] FALSE FALSE  TRUE  TRUE TRUE
## [4,] FALSE FALSE FALSE  TRUE TRUE
## [5,] FALSE FALSE FALSE FALSE TRUE
\end{verbatim}

Is there a high level meaning to a \texttt{.} before function? Does this refer to internal functions? {[}see: ?\texttt{row} vs ?\texttt{.row}{]}

Objects in the global environment prefixed with \texttt{.} are hidden in the R (and RStudio) environment panes - so functions prefixed as such are not visible unless you do \texttt{ls(all=TRUE)}. \href{https://community.rstudio.com/t/function-argument-naming-conventions-x-vs-x/7764}{Read more here} and (here){[}\url{https://stackoverflow.com/questions/7526467/what-does-the-dot-mean-in-r-personal-preference-naming-convention-or-more}{]}

\hypertarget{missing-and-oob}{%
\section*{4.3.3 Missing and OOB}\label{missing-and-oob}}
\addcontentsline{toc}{section}{4.3.3 Missing and OOB}

Let's walk through examples of each

\hypertarget{logical-atomic}{%
\subsection*{LOGICAL ATOMIC}\label{logical-atomic}}
\addcontentsline{toc}{subsection}{LOGICAL ATOMIC}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)[[}\DecValTok{0}\NormalTok{]] }\CommentTok{# zero length}
\CommentTok{# attempt to select less than one element in get1index <real>}
\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)[[}\DecValTok{4}\NormalTok{]] }\CommentTok{# out of bounds}
\CommentTok{# subscript out of bounds}
\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)[[}\OtherTok{NA}\NormalTok{]] }\CommentTok{# missing}
\CommentTok{# subscript out of bounds}
\end{Highlighting}
\end{Shaded}

\hypertarget{list}{%
\subsection*{LIST}\label{list}}
\addcontentsline{toc}{subsection}{LIST}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\OtherTok{NULL}\NormalTok{)[[}\DecValTok{0}\NormalTok{]] }\CommentTok{# zero length}
\CommentTok{# attempt to select less than one element in get1index <real>}
\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\OtherTok{NULL}\NormalTok{)[[}\DecValTok{3}\NormalTok{]] }\CommentTok{# out of bounds}
\CommentTok{# subscript out of bounds}
\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\OtherTok{NULL}\NormalTok{)[[}\OtherTok{NA}\NormalTok{]] }\CommentTok{# missing}
\CommentTok{# NULL}
\end{Highlighting}
\end{Shaded}

\hypertarget{null}{%
\subsection*{NULL}\label{null}}
\addcontentsline{toc}{subsection}{NULL}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{NULL}\NormalTok{[[}\DecValTok{0}\NormalTok{]] }\CommentTok{# zero length}
\CommentTok{# NULL}
\OtherTok{NULL}\NormalTok{[[}\DecValTok{1}\NormalTok{]] }\CommentTok{# out of bounds}
\CommentTok{# NULL}
\OtherTok{NULL}\NormalTok{[[}\OtherTok{NA}\NormalTok{]] }\CommentTok{# missing}
\CommentTok{# NULL}
\end{Highlighting}
\end{Shaded}

\hypertarget{logical-subsetting}{%
\section*{4.5.8 Logical subsetting}\label{logical-subsetting}}
\addcontentsline{toc}{section}{4.5.8 Logical subsetting}

``Remember to use the vector Boolean operators \texttt{\&} and \texttt{\textbar{}}, not the short-circuiting scalar operators \texttt{\&\&} and \texttt{\textbar{}\textbar{}}, which are more useful inside if statements.''

Can we go over the difference between \texttt{\&} and \texttt{\&\&} (and \texttt{\textbar{}} vs \texttt{\textbar{}\textbar{}}) I use brute force to figure out which ones I need\ldots{}

\texttt{\&\&} and \texttt{\textbar{}\textbar{}} only ever return a single (scalar, length-1 vector) \texttt{TRUE} or \texttt{FALSE} value, whereas \texttt{\textbar{}} and \texttt{\&} return a vector after doing element-by-element comparisons.

The only place in R you routinely use a scalar \texttt{TRUE}/\texttt{FALSE} value is in the conditional of an \texttt{if} statement, so you'll often see \texttt{\&\&} or \texttt{\textbar{}\textbar{}} used in idioms like: \texttt{if\ (length(x)\ \textgreater{}\ 0\ \&\&\ any(is.na(x)))\ \{\ do.something()\ \}}

In most other instances you'll be working with vectors and use \texttt{\&} and \texttt{\textbar{}} instead.

Using \texttt{\&\&} or \texttt{\textbar{}\textbar{}} results in some unexpected behavior - which could be a big performance gain in some cases:

\begin{itemize}
\tightlist
\item
  \texttt{\textbar{}\textbar{}} will not evaluate the second argument when the first is \texttt{TRUE}
\item
  \texttt{\&\&} will not evaluate the second argument when the first is \texttt{FALSE}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{true_one <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{ }\KeywordTok{print}\NormalTok{(}\StringTok{"true_one evaluated."}\NormalTok{); }\OtherTok{TRUE}\NormalTok{\}}
\NormalTok{true_two <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{ }\KeywordTok{print}\NormalTok{(}\StringTok{"true_two evaluated."}\NormalTok{); }\OtherTok{TRUE}\NormalTok{\}}
\CommentTok{# arguments are evaluated lazily.  Unexpected behavior can result:}
\KeywordTok{c}\NormalTok{(T, }\KeywordTok{true_one}\NormalTok{()) }\OperatorTok{&&}\StringTok{ }\KeywordTok{c}\NormalTok{(T, }\KeywordTok{true_two}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "true_one evaluated."
## [1] "true_two evaluated."
\end{verbatim}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(T, }\KeywordTok{true_one}\NormalTok{()) }\OperatorTok{&&}\StringTok{ }\KeywordTok{c}\NormalTok{(F, }\KeywordTok{true_two}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "true_one evaluated."
## [1] "true_two evaluated."
\end{verbatim}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(F, }\KeywordTok{true_one}\NormalTok{()) }\OperatorTok{&&}\StringTok{ }\KeywordTok{c}\NormalTok{(T, }\KeywordTok{true_two}\NormalTok{()) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "true_one evaluated."
\end{verbatim}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(F, }\KeywordTok{true_one}\NormalTok{()) }\OperatorTok{&&}\StringTok{ }\KeywordTok{c}\NormalTok{(F, }\KeywordTok{true_two}\NormalTok{()) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "true_one evaluated."
\end{verbatim}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(T, }\KeywordTok{true_one}\NormalTok{()) }\OperatorTok{||}\StringTok{ }\KeywordTok{c}\NormalTok{(T, }\KeywordTok{true_two}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "true_one evaluated."
\end{verbatim}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(T, }\KeywordTok{true_one}\NormalTok{()) }\OperatorTok{||}\StringTok{ }\KeywordTok{c}\NormalTok{(F, }\KeywordTok{true_two}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "true_one evaluated."
\end{verbatim}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(F, }\KeywordTok{true_one}\NormalTok{()) }\OperatorTok{||}\StringTok{ }\KeywordTok{c}\NormalTok{(T, }\KeywordTok{true_two}\NormalTok{()) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "true_one evaluated."
## [1] "true_two evaluated."
\end{verbatim}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(F, }\KeywordTok{true_one}\NormalTok{()) }\OperatorTok{||}\StringTok{ }\KeywordTok{c}\NormalTok{(F, }\KeywordTok{true_two}\NormalTok{()) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "true_one evaluated."
## [1] "true_two evaluated."
\end{verbatim}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Read more about \href{https://cran.r-project.org/doc/manuals/r-release/R-ints.html\#Special-primitives}{Special Primatives} here

\hypertarget{boolean-algebra}{%
\section*{4.5.8 Boolean algebra}\label{boolean-algebra}}
\addcontentsline{toc}{section}{4.5.8 Boolean algebra}

The \texttt{unwhich()} function takes a boolean and turns it into a numeric - would this ever be useful? How?

XXX

``\texttt{x{[}-which(y){]}} is not equivalent to \texttt{x{[}!y{]}}: if \texttt{y} is all FALSE, \texttt{which(y)} will be \texttt{integer(0)} and \texttt{-integer(0)} is still \texttt{integer(0)}, so you'll get no values, instead of all values.''

Can we come up with an example for this plugging in values for \texttt{x} and \texttt{y}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)[}\OperatorTok{-}\KeywordTok{which}\NormalTok{(}\OtherTok{FALSE}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## logical(0)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)[}\OperatorTok{!}\OtherTok{FALSE}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE FALSE
\end{verbatim}

\hypertarget{control-flow}{%
\chapter{Control Flow}\label{control-flow}}

\hypertarget{vectorised-if}{%
\section*{5.2.2 Vectorised if}\label{vectorised-if}}
\addcontentsline{toc}{section}{5.2.2 Vectorised if}

Why does \texttt{if} \texttt{else} print \texttt{"Out\ of\ range"} once but \texttt{ifelse} prints it twice?

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{sample}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{1}\NormalTok{) }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{) }\KeywordTok{print}\NormalTok{(}\StringTok{"In range"}\NormalTok{) }\ControlFlowTok{else} \KeywordTok{print}\NormalTok{(}\StringTok{"Out of range"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "Out of range"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ifelse}\NormalTok{((}\KeywordTok{sample}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{1}\NormalTok{) }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{), }\KeywordTok{print}\NormalTok{(}\StringTok{"In range"}\NormalTok{), }\KeywordTok{print}\NormalTok{(}\StringTok{"Out of range"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "Out of range"
[1] "Out of range"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{sample}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{1}\NormalTok{) }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{) }\KeywordTok{print}\NormalTok{(}\StringTok{"In range"}\NormalTok{)}
\NormalTok{var}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
NULL
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var <-}\StringTok{ }\KeywordTok{ifelse}\NormalTok{((}\KeywordTok{sample}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{1}\NormalTok{) }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{), }\KeywordTok{print}\NormalTok{(}\StringTok{"In range"}\NormalTok{), }\KeywordTok{print}\NormalTok{(}\StringTok{"Out of range"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Out of range"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Out of range"
\end{verbatim}

\texttt{ifelse} explicitly returns its result, whereas \texttt{if} invisibly returns it!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ifelse}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{), }\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 3 1
\end{verbatim}

Honestly, \texttt{ifelse()} is weird. Try this too:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ifelse}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{), }\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 3 3
\end{verbatim}

\hypertarget{loops}{%
\section*{5.3 Loops}\label{loops}}
\addcontentsline{toc}{section}{5.3 Loops}

Can the body of the loop change the set?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_set <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{99}\NormalTok{)}

\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in}\NormalTok{ my_set)\{}
  \ControlFlowTok{if}\NormalTok{ (i}\OperatorTok{==}\DecValTok{1}\NormalTok{)\{}
\NormalTok{    my_set[}\DecValTok{9}\NormalTok{]=}\StringTok{ }\DecValTok{20}
\NormalTok{    \}}
  \KeywordTok{print}\NormalTok{(}\StringTok{"hello"}\NormalTok{)}
  \KeywordTok{print}\NormalTok{(my_set)}
\NormalTok{  \}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "hello"
## [1]  1 20 99 NA NA NA NA NA 20
## [1] "hello"
## [1]  1 20 99 NA NA NA NA NA 20
## [1] "hello"
## [1]  1 20 99 NA NA NA NA NA 20
\end{verbatim}

Looks like you can't!

\hypertarget{switch-statement}{%
\section*{5.2.3 switch statement}\label{switch-statement}}
\addcontentsline{toc}{section}{5.2.3 switch statement}

``Closely related to if is the \texttt{switch()} statement. It's a compact, special purpose equivalent''

What is meant here by ``special purpose''? Can we come up with a case where you can't substitute \texttt{if} for \texttt{switch} or the other way around? Use \texttt{switch}. Is it safe to say to \texttt{switch} when you have character inputs (as the book suggests) and use \texttt{case\_when} or \texttt{if} for numerics?

Switch is special in that only ONE value can be true, as in the case from our presentation the shiny input can only ever be ONE of the strings on the left it cannot be multiple.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datasetInput <-}\StringTok{ }\KeywordTok{reactive}\NormalTok{(\{ }
  \ControlFlowTok{switch}\NormalTok{(input}\OperatorTok{$}\NormalTok{dataset,}
         \StringTok{"materials"}\NormalTok{ =}\StringTok{ }\NormalTok{brewing_materials,}
         \StringTok{"size"}\NormalTok{ =}\StringTok{ }\NormalTok{brewer_size,}
         \StringTok{"states"}\NormalTok{ =}\StringTok{ }\NormalTok{beer_states,}
         \StringTok{"taxed"}\NormalTok{ =}\StringTok{ }\NormalTok{beer_taxed)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{common-pitfalls}{%
\section*{5.3.1 common pitfalls}\label{common-pitfalls}}
\addcontentsline{toc}{section}{5.3.1 common pitfalls}

What does the book mean by leveraging \texttt{vector} for preallocating the loop output? How is this different from creating an empty list to instantiate the loop?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{means <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{20}\NormalTok{)}

\NormalTok{out_vector <-}\StringTok{ }\KeywordTok{vector}\NormalTok{(}\StringTok{"list"}\NormalTok{, }\KeywordTok{length}\NormalTok{(means))}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{(means)) \{}
\NormalTok{  out_vector[[i]] <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{, means[[i]])}
\NormalTok{\}}

\NormalTok{out_list <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{(means)) \{}
\NormalTok{  out_list[[i]] <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{, means[[i]])}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

By preallocating the length of the \texttt{out\_vector} we're leveraging \texttt{modify-in-place} rather than \texttt{copy-on-modify}.

The book warns against using \texttt{length(x)} and suggests using \texttt{seq\_along} instead. Is there any downside to using \texttt{seq\_along} or a case when you'd prefer \texttt{length(x)} over \texttt{seq\_along(x)}? I can't think of any downsides to using it!

We have yet to find a downside but should look into this further!

\hypertarget{exercises-1}{%
\section*{5.3.3.1 Exercises}\label{exercises-1}}
\addcontentsline{toc}{section}{5.3.3.1 Exercises}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{numeric}\NormalTok{()}
\NormalTok{out <-}\StringTok{ }\KeywordTok{vector}\NormalTok{(}\StringTok{"list"}\NormalTok{, }\KeywordTok{length}\NormalTok{(x))}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{(x)) \{}
\NormalTok{  out[i] <-}\StringTok{ }\NormalTok{x[i] }\OperatorTok{^}\StringTok{ }\DecValTok{2}
\NormalTok{\}}
\NormalTok{out}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] NA
\end{verbatim}

I understand that this works because we can count down in a loop - so the first iteration \texttt{x{[}1{]}\ ==\ NA}, and the second \texttt{x{[}2{]}\ ==\ numeric(0)} but where does this value go? Is it just evaluated but not stored since R counts from 1?

This question is actually the bigger question, ``Can you assign something to index 0 in R?'' and it doesn't seem that you can.

\hypertarget{assignment-to-a-valid-index}{%
\subsection*{Assignment to a valid index}\label{assignment-to-a-valid-index}}
\addcontentsline{toc}{subsection}{Assignment to a valid index}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist =}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{mylist[}\DecValTok{1}\NormalTok{] <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"something"}\NormalTok{)}
\NormalTok{mylist[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] "something"
\end{verbatim}

\hypertarget{assignment-to-0}{%
\subsection*{Assignment to {[}0{]}}\label{assignment-to-0}}
\addcontentsline{toc}{subsection}{Assignment to {[}0{]}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist =}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{mylist[}\DecValTok{0}\NormalTok{] <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"something"}\NormalTok{)}
\NormalTok{mylist[}\DecValTok{0}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## list()
\end{verbatim}

It's interesting that it's syntactically correct to assign to \texttt{mylist{[}0{]}} but it does nothing!

\hypertarget{empty-index}{%
\subsection*{Empty index}\label{empty-index}}
\addcontentsline{toc}{subsection}{Empty index}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist =}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{mylist[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## NULL
\end{verbatim}

R defaultly accesses the first layer using \texttt{{[}} and says there are no elements in the first layer of \texttt{mylist} and returns \texttt{NULL}. But when you do \texttt{mylist{[}{[}1{]}{]}} R says \texttt{Out\ of\ Bounds} because the first layer of \texttt{mylist} has been called and there is no layer at all. That's why R throws error in \texttt{{[}{[}} case.

\hypertarget{impossible-index}{%
\subsection*{\texorpdfstring{Impossible Index \texttt{{[}{[}}}{Impossible Index {[}{[}}}\label{impossible-index}}
\addcontentsline{toc}{subsection}{Impossible Index \texttt{{[}{[}}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist =}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{mylist[[}\DecValTok{0}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in mylist[[0]] : attempt to select less than one element in get1index <real>
\end{verbatim}

\texttt{{[}{[}} isolates one element whereas \texttt{{[}} can be used to get subsets of varying sizes.
\texttt{{[}{[}} gets precisely one element, no more no less, or it fails. So \texttt{{[}{[}0{]}{]}\textless{}-} cannot work because index zero cannot hold a value.

\hypertarget{impossible-index--}{%
\subsection*{\texorpdfstring{Impossible Index \texttt{{[}{[}\textless{}-}}{Impossible Index {[}{[}\textless{}-}}\label{impossible-index--}}
\addcontentsline{toc}{subsection}{Impossible Index \texttt{{[}{[}\textless{}-}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist =}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{mylist[[}\DecValTok{0}\NormalTok{]] <-}\StringTok{ "something"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in mylist[[0]] <- "something" : attempt to select less than one element in integerOneIndex
\end{verbatim}

\hypertarget{undefined-name}{%
\subsection*{Undefined name}\label{undefined-name}}
\addcontentsline{toc}{subsection}{Undefined name}

Selection using an undefined - but possible name - gives NULL

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist =}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{mylist[[}\StringTok{"undefined_name"}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\hypertarget{out-of-bounds}{%
\subsection*{Out of Bounds}\label{out-of-bounds}}
\addcontentsline{toc}{subsection}{Out of Bounds}

Selection using a possible - but not currently allocated - index gives an out of bounds error

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist =}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{mylist[[}\DecValTok{10}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in mylist[[10]] : subscript out of bounds 
\end{verbatim}

\hypertarget{conclusion-1}{%
\section*{Conclusion}\label{conclusion-1}}
\addcontentsline{toc}{section}{Conclusion}

Can we put these concepts together in diagram form? Let's work on improving these schematics!

Let's first put functions into words:

\begin{itemize}
\tightlist
\item
  If condition then run code, else quit
\item
  A vectorized version of: if condition then run code, else run other code
\item
  For every element in list of elements do what is in between the curly braces
\item
  While this condition is true do this
\item
  Repeat this until something tells you to break out
\end{itemize}

\includegraphics[width=40in]{images/controlflow}

We can visualize how the \texttt{ifelse} logic on a single element above will operate on each element within a vector:

\begin{center}\includegraphics[width=9.76in]{images/ifelse} \end{center}

For instance if we can run:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ifelse}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{), }\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 3 1
\end{verbatim}

Lets break down what's happening:

Create a test answer:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{test <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\NormalTok{yes <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{2}
\NormalTok{no <-}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

which indices in the test are TRUE and which are FALSE

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{yes_idx <-}\StringTok{ }\KeywordTok{which}\NormalTok{(test) }\CommentTok{# 1,3}
\NormalTok{no_idx <-}\StringTok{ }\KeywordTok{which}\NormalTok{(}\OperatorTok{!}\NormalTok{test) }\CommentTok{# 2}
\end{Highlighting}
\end{Shaded}

set up our answer

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{answer <-}\StringTok{ }\NormalTok{test }\CommentTok{# T, F, T}
\end{Highlighting}
\end{Shaded}

grow the yes and no answers to the length of the test (input)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{yes_final <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(yes, }\DataTypeTok{length.out =} \KeywordTok{length}\NormalTok{(test))}
\NormalTok{no_final <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(no, }\DataTypeTok{length.out =} \KeywordTok{length}\NormalTok{(test))}
\end{Highlighting}
\end{Shaded}

fill the answer with yes or no from the enlarged yes/no answers

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{answer[yes_idx] <-}\StringTok{ }\NormalTok{yes_final[yes_idx]  }\CommentTok{# 1,1}
\NormalTok{answer[no_idx] <-}\StringTok{ }\NormalTok{no_final[no_idx]     }\CommentTok{# 3}
\end{Highlighting}
\end{Shaded}

return our final answer:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{answer}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 3 1
\end{verbatim}

Another example: we can run

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ifelse}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{), }\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\StringTok{"FALSE"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1"     "FALSE" "3"     "FALSE" "5"     "6"
\end{verbatim}

we can see that ifelse places the numbers in \texttt{1:10} based on their index where our condition is to \texttt{TRUE} and inserts the string \texttt{"FALSE"} whenever the condition is \texttt{FALSE}

\hypertarget{complexity}{%
\section*{Complexity}\label{complexity}}
\addcontentsline{toc}{section}{Complexity}

Cyclomatic complexity is a software metric used to indicate the complexity of a program. It is computed using the control flow graph of the program: the nodes of the graph correspond to indivisible groups of commands of a program, and a directed edge connects two nodes if the second command might be executed immediately after the first command.

We can use the package \texttt{cyclocomp} to look at the cyclomatic complexity of functions. Looking at each function from the Chapter 5 presentation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{controlflow_functions <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{if_func =}\NormalTok{ if_func,}
  \DataTypeTok{if_else_func =}\NormalTok{ if_else_func,}
  \DataTypeTok{ifelse_func =}\NormalTok{ ifelse_func,}
  \DataTypeTok{casewhen_func =}\NormalTok{ casewhen_func,}
  \DataTypeTok{switch_func =}\NormalTok{ switch_func, }
  \DataTypeTok{for_func =}\NormalTok{ for_func,}
  \DataTypeTok{while_func =}\NormalTok{ while_func,}
  \DataTypeTok{repeat_func =}\NormalTok{ repeat_func)}

\NormalTok{purrr}\OperatorTok{::}\KeywordTok{map_df}\NormalTok{(controlflow_functions, cyclocomp)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 1 x 8
##   if_func if_else_func ifelse_func casewhen_func switch_func for_func while_func
##     <int>        <int>       <int>         <int>       <int>    <int>      <int>
## 1       2            2           1             1           1       23          3
## # ... with 1 more variable: repeat_func <int>
\end{verbatim}

We see that the \texttt{for} loop was our most complex function and \texttt{while} had a complexity of 3. The rest of our functions had a complexity of \texttt{1}.

As \href{https://engineering-shiny.org/successfulshinyapp.html}{Colin Fay states}:

``Splitting a complex function into smaller functions is not a magic solution because (A) the global complexity of the app is not lowered by splitting things into pieces (just local complexity), and (B) the deeper the call stack, the harder it can be to debug.''

\hypertarget{functions}{%
\chapter{Functions}\label{functions}}

\hypertarget{primitives}{%
\section*{6.2.2 Primitives}\label{primitives}}
\addcontentsline{toc}{section}{6.2.2 Primitives}

So if you are familiar with C can you just write a function in C \emph{in} R? What does that process look like? I think this is a bigger question of digging into the relationship between C and R.

Primitives are part of R core, and can only be written by the R-core team. At its heart, R \emph{is} the set of primitive C functions underneath it.

You can use Rcpp to include C++ code in your R code, but these aren't Primitives. There are also other techniques which we'll likely see covered in later chapters. Here's an example using Rcpp.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Rcpp}\OperatorTok{::}\KeywordTok{cppFunction}\NormalTok{(}\StringTok{'#include<string>}
\StringTok{  std::string IPA() \{}
\StringTok{  std::string val = "IPAs suck";    }
\StringTok{  return val;}
\StringTok{  \}'}\NormalTok{)}
\NormalTok{val <-}\StringTok{ }\KeywordTok{IPA}\NormalTok{()}
\NormalTok{val}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "IPAs suck"
\end{verbatim}

Are there any non-base primitives? If so how is that possible!

XXX

\hypertarget{exercises-2}{%
\section*{6.2.5.1 Exercises}\label{exercises-2}}
\addcontentsline{toc}{section}{6.2.5.1 Exercises}

\href{https://github.com/Tazinho/Advanced-R-Solutions/blob/5043d9b06c7469a010c568ecb85e12bedca75207/2-06-Functions.Rmd\#L9}{This question is flagged as ``started'' let's try to complete it!}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{{Q}}: Given a name, like \texttt{"mean"}, \texttt{match.fun()} lets you find a function. Given a function, can you find its name? Why doesn't that make sense in R?

  \textbf{{A}}: A name can only point to a single object, but an object can be pointed to by 0, 1, or many names. What are names of the functions in the following block?

\begin{Shaded}
\begin{Highlighting}[]
  \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sd}\NormalTok{(x) }\OperatorTok{/}\StringTok{ }\KeywordTok{mean}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function(x) sd(x) / mean(x)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) (x }\OperatorTok{-}\StringTok{ }\KeywordTok{min}\NormalTok{(x)) }\OperatorTok{/}\StringTok{ }\NormalTok{(}\KeywordTok{max}\NormalTok{(x) }\OperatorTok{-}\StringTok{ }\KeywordTok{min}\NormalTok{(x))}
\NormalTok{  f2 <-}\StringTok{ }\NormalTok{f1}
\NormalTok{  f3 <-}\StringTok{ }\NormalTok{f1}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

There isn't a 1 to 1 mapping between functions and names in R. Multiple names may point to the same function as we see for \texttt{f1}, \texttt{f2}, and \texttt{f3}. Also, each function has its own environment so it's possible that two functions might have the same ``code'' but are not the same because they have different environments (or closures). Lastly, anonymous functions don't have names so we'd have no way to look these up.

We could find the names of our functions if they are all in the global environment using \texttt{body(x)\ ==\ body(y)}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{names}\NormalTok{(}\KeywordTok{which}\NormalTok{(}\KeywordTok{sapply}\NormalTok{(}\KeywordTok{mget}\NormalTok{(}\KeywordTok{lsf.str}\NormalTok{()), }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{body}\NormalTok{(x) }\OperatorTok{==}\StringTok{ }\KeywordTok{body}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x) (x }\OperatorTok{-}\StringTok{ }\KeywordTok{min}\NormalTok{(x)) }\OperatorTok{/}\StringTok{ }\NormalTok{(}\KeywordTok{max}\NormalTok{(x) }\OperatorTok{-}\StringTok{ }\KeywordTok{min}\NormalTok{(x))))))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] f1  f2  f3
\end{verbatim}

But that's just deparsing the body into a string and comparing the values. So if you want to think of two functions as being equal if their deparsed body strings as the same, then that's technically possible but that is just like searching for every variable that has the value of 5 {[}possible but not efficient{]}.

The main point is that \texttt{name\ -\textgreater{}\ object} is a one way (non-unique) look up in R. There's no efficient way to go backwards. This is true for all values, not just functions.

\hypertarget{function-composition}{%
\section*{6.3 Function composition}\label{function-composition}}
\addcontentsline{toc}{section}{6.3 Function composition}

When comparing nested, intermediate, and piping functions, it looks like Hadley flips the order of \texttt{f()} and \texttt{g()} between bullet points

It does look like he does that!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(z) \{}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"g is:"}\NormalTok{, z)}
\NormalTok{\}}

\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  x }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{nested}{%
\subsection{Nested}\label{nested}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{f}\NormalTok{(}\KeywordTok{g}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## g is: 4
\end{verbatim}

\hypertarget{intermediate}{%
\subsection{Intermediate}\label{intermediate}}

This is written in the book as \texttt{y\ \textless{}-\ f(x);\ g(y)} but should be flipped to \texttt{y\ \textless{}-\ g(x);\ f(y)} if we are to follow the nested example

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\KeywordTok{g}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\KeywordTok{f}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## g is: 4
\end{verbatim}

\hypertarget{piping}{%
\subsection{Piping}\label{piping}}

This also needs to be flipped from \texttt{x\ \%\textgreater{}\%\ f()\ \%\textgreater{}\%\ g()} to \texttt{x\ \%\textgreater{}\%\ g()\ \%\textgreater{}\%\ f()}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{%>%}\StringTok{ }\KeywordTok{g}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{f}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## g is: 4
\end{verbatim}

\hypertarget{lexical-scoping}{%
\section*{6.4 Lexical scoping}\label{lexical-scoping}}
\addcontentsline{toc}{section}{6.4 Lexical scoping}

``The scoping rules use a parse-time, rather than a run-time structure''? What is ``parse-time'' and ``run-time''? How do they differ?

parse-time is when the function gets defined: when the formals and body get set. run-time is when it actually gets called. This function doesn't get past parse-time because of the syntax error

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{get_state <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(in_df, state_name)\{}
\NormalTok{  out_df % in_df[in_df}\OperatorTok{$}\NormalTok{state }\OperatorTok{==}\StringTok{ }\NormalTok{state_name, ]}
  \KeywordTok{return}\NormalTok{(out_df)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
get_state <- function(in_df, state_name){
  out_df % in_df[in_df$state == state_name, ]

Error: unexpected input in:

"get_state <- function(in_df, state_name){
  out_df % in_df[in_df$state == state_name, ]"
  return(out_df)

Error: object 'out_df' not found
}

Error: unexpected '}' in "}"
\end{verbatim}

This function will get parsed successfully but could fail at run at run-time if the input data frame doesn't have a column named state:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{get_state <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(in_df, state_name)\{}
\NormalTok{  out_df <-}\StringTok{ }\NormalTok{in_df[in_df}\OperatorTok{$}\NormalTok{state }\OperatorTok{==}\StringTok{ }\NormalTok{state_name, ]}
  \KeywordTok{return}\NormalTok{(out_df)}
\NormalTok{\}  }

\KeywordTok{get_state}\NormalTok{(iris, }\StringTok{'setosa'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] Sepal.Length Sepal.Width  Petal.Length Petal.Width  Species     
## <0 rows> (or 0-length row.names)
\end{verbatim}

At R's build-time, if you want to run a function from a package that isn't loaded it will not throw an error but at run-time it will if the required package is not loaded:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{func_}\DecValTok{1}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, x) \{}
  \KeywordTok{select}\NormalTok{(\{\{ df \}\}, \{\{ x \}\})}
\NormalTok{\}}

\NormalTok{test_tbl <-}\StringTok{ }\NormalTok{tibble}\OperatorTok{::}\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{x1 =} \KeywordTok{runif}\NormalTok{(}\DecValTok{5}\NormalTok{),}
             \DataTypeTok{x2 =} \KeywordTok{rnorm}\NormalTok{(}\DecValTok{5}\NormalTok{),}
             \DataTypeTok{x3 =} \KeywordTok{rpois}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DataTypeTok{lambda =} \DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Without \texttt{dplyr} this will fail

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{func_1}\NormalTok{(test_tbl, x1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in select({: could not find function "select"
\end{verbatim}

This will work:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(dplyr)}
\CommentTok{#> }
\CommentTok{#> Attaching package: 'dplyr'}
\CommentTok{#> The following objects are masked from 'package:stats':}
\CommentTok{#> }
\CommentTok{#>     filter, lag}
\CommentTok{#> The following objects are masked from 'package:base':}
\CommentTok{#> }
\CommentTok{#>     intersect, setdiff, setequal, union}
\KeywordTok{func_1}\NormalTok{(test_tbl, x1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 5 x 1
##      x1
##   <dbl>
## 1 0.447
## 2 0.564
## 3 0.883
## 4 0.864
## 5 0.136
\end{verbatim}

\hypertarget{a-fresh-start}{%
\section*{6.4.3 A fresh start}\label{a-fresh-start}}
\addcontentsline{toc}{section}{6.4.3 A fresh start}

How would we change this code so that the second call of \texttt{g11()} is 2?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g11 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{exists}\NormalTok{(}\StringTok{"a"}\NormalTok{)) \{}
\NormalTok{    a <-}\StringTok{ }\DecValTok{1}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    a <-}\StringTok{ }\NormalTok{a }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{  \}}
\NormalTok{  a}
\NormalTok{\}}

\KeywordTok{g11}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g11 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{exists}\NormalTok{(}\StringTok{"a"}\NormalTok{)) \{}
\NormalTok{    a <-}\StringTok{ }\DecValTok{1}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    a <-}\StringTok{ }\NormalTok{a }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{  \}}
\NormalTok{  a <<-}\StringTok{ }\NormalTok{a}
\NormalTok{  a}
\NormalTok{\}}

\KeywordTok{g11}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\hypertarget{lazy-evaluation}{%
\section*{6.5 Lazy evaluation}\label{lazy-evaluation}}
\addcontentsline{toc}{section}{6.5 Lazy evaluation}

``This allows you to do things like include potentially expensive computations in function arguments that will only be evaluated if needed''

Does anyone have an example of this? We discussed a function that will only perform expensive tasks given the context of the function perhaps?

Maybe a situation where we can give a function default arguments where \texttt{sample}is a stand in for longer expensive functions like different fancy modeling techniques? We can workshop this\ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mega_model <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(values, }\DataTypeTok{x =} \KeywordTok{sample}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{, }\DecValTok{10}\NormalTok{), }\DataTypeTok{y =} \KeywordTok{sample}\NormalTok{(}\DecValTok{200}\OperatorTok{:}\DecValTok{300}\NormalTok{, }\DecValTok{10}\NormalTok{), }\DataTypeTok{z =} \KeywordTok{sample}\NormalTok{(}\DecValTok{300}\OperatorTok{:}\DecValTok{400}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{) \{}
\NormalTok{  dplyr}\OperatorTok{::}\KeywordTok{case_when}\NormalTok{(}
    \KeywordTok{is.numeric}\NormalTok{(values) }\OperatorTok{~}\StringTok{ }\NormalTok{x,}
    \KeywordTok{is.character}\NormalTok{(values) }\OperatorTok{~}\StringTok{ }\NormalTok{y,}
    \OtherTok{TRUE} \OperatorTok{~}\StringTok{ }\NormalTok{z}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{mega_model}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 297 268 228 213 290 204 265 201 287 281
\end{verbatim}

\hypertarget{promises}{%
\section*{6.5.1 Promises}\label{promises}}
\addcontentsline{toc}{section}{6.5.1 Promises}

Can we discuss the order that this happening in? Is it that \texttt{Calculating...} is printed, then \texttt{x*2} then \texttt{x*2} again? I am still reading this as: \texttt{h03(double(20),\ double(20))} which is an incorrect mental model because the message is only printed once\ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{double <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{ }
  \KeywordTok{message}\NormalTok{(}\StringTok{"Calculating..."}\NormalTok{)}
\NormalTok{  x }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\NormalTok{\}}

\NormalTok{h03 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{c}\NormalTok{(x, x)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Explain what's happeining here below in words, and restructure the promise image to make more sense

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{double <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(y) \{}
  \KeywordTok{message}\NormalTok{(}\StringTok{"Calculating..."}\NormalTok{)}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"double before}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \KeywordTok{print}\NormalTok{(pryr}\OperatorTok{::}\KeywordTok{promise_info}\NormalTok{(y))}
  \KeywordTok{force}\NormalTok{(y)}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"double after}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \KeywordTok{print}\NormalTok{(pryr}\OperatorTok{::}\KeywordTok{promise_info}\NormalTok{(y))}
\NormalTok{  y }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\NormalTok{\}}
\NormalTok{h03 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{cat}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}\StringTok{"h03 before}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{))}
  \KeywordTok{print}\NormalTok{(pryr}\OperatorTok{::}\KeywordTok{promise_info}\NormalTok{(x))}
  \KeywordTok{force}\NormalTok{(x)}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"h03 after}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \KeywordTok{print}\NormalTok{(pryr}\OperatorTok{::}\KeywordTok{promise_info}\NormalTok{(x))}
  \KeywordTok{c}\NormalTok{(x, x)}
\NormalTok{\}}
\KeywordTok{double}\NormalTok{(}\KeywordTok{h03}\NormalTok{(}\DecValTok{20}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Calculating...
\end{verbatim}

\begin{verbatim}
## double before
## $code
## h03(20)
## 
## $env
## <environment: R_GlobalEnv>
## 
## $evaled
## [1] FALSE
## 
## $value
## NULL
## 
## h03 before
## $code
## [1] 20
## 
## $env
## <environment: R_GlobalEnv>
## 
## $evaled
## [1] FALSE
## 
## $value
## NULL
## 
## h03 after
## $code
## [1] 20
## 
## $env
## NULL
## 
## $evaled
## [1] TRUE
## 
## $value
## [1] 20
## 
## double after
## $code
## h03(20)
## 
## $env
## NULL
## 
## $evaled
## [1] TRUE
## 
## $value
## [1] 20 20
\end{verbatim}

\begin{verbatim}
## [1] 40 40
\end{verbatim}

\begin{center}\includegraphics[width=20.22in]{images/promise} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plop <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) a }\OperatorTok{*}\StringTok{ }\DecValTok{10}
\KeywordTok{plop}\NormalTok{(}\DecValTok{2}\NormalTok{, var_doesnt_exist)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 20
\end{verbatim}

\texttt{var\_doesnt\_exist} is a promise within \texttt{g}, we use the promises within \texttt{g} when we call \texttt{f} but \texttt{f} never uses its second argument so this runs without a problem. When would we want to leverage this behavior?

The unevaluated \texttt{var\_doesnt\_exist} doesn't exist , but we can use \texttt{substitute} to to get the expression out of a promise! If we modify our function we can play with the expression contained in b:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plop <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) \{}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"You entered"}\NormalTok{, }\KeywordTok{deparse}\NormalTok{(}\KeywordTok{substitute}\NormalTok{(b)), }\StringTok{"as `b` }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{  a }\OperatorTok{*}\StringTok{ }\DecValTok{10}
\NormalTok{\}}
\KeywordTok{plop}\NormalTok{(}\DataTypeTok{a =} \DecValTok{2}\NormalTok{, }\DataTypeTok{b =}\NormalTok{ var_doesnt_exist)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## You entered var_doesnt_exist as `b`
\end{verbatim}

\begin{verbatim}
## [1] 20
\end{verbatim}

We can even evaluate \texttt{b} and use it to create a \texttt{dplyr} like \texttt{pull} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plop <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) \{}
  \KeywordTok{eval}\NormalTok{(}\KeywordTok{substitute}\NormalTok{(b), }\DataTypeTok{envir =}\NormalTok{ a)}
\NormalTok{\}}
\KeywordTok{plop}\NormalTok{(iris, Species)[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa
## Levels: setosa versicolor virginica
\end{verbatim}

\hypertarget{default-arguments}{%
\section*{6.5.2 Default arguments}\label{default-arguments}}
\addcontentsline{toc}{section}{6.5.2 Default arguments}

I don't quite understand why \texttt{x\ =\ ls()} is different from \texttt{ls()} here; aren't we still assigning \texttt{x\ =\ ls()} but without specifying x?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h05 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{ls}\NormalTok{()) \{}
\NormalTok{  a <-}\StringTok{ }\DecValTok{1}
\NormalTok{  x}
\NormalTok{\}}

\CommentTok{# this makes sense to me}
\KeywordTok{h05}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "a" "x"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# how is this different from above?}
\KeywordTok{h05}\NormalTok{(}\KeywordTok{ls}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "a"                     "answer"                "as_tb"                
##  [4] "casewhen_func"         "controlflow_functions" "custom_attr"          
##  [7] "df"                    "df_coltypes"           "df_non_syntactic_name"
## [10] "df_x"                  "double"                "example2223"          
## [13] "f"                     "f1"                    "f2"                   
## [16] "f3"                    "for_func"              "func_1"               
## [19] "g"                     "g11"                   "get_state"            
## [22] "h03"                   "h05"                   "i"                    
## [25] "if_else_func"          "if_func"               "ifelse_func"          
## [28] "IPA"                   "l1"                    "l2"                   
## [31] "means"                 "medians"               "mega_model"           
## [34] "my_factor"             "my_matrix"             "my_set"               
## [37] "my_vector"             "mylist"                "new_address"          
## [40] "new_y_address"         "no"                    "no_final"             
## [43] "no_idx"                "old_address"           "out"                  
## [46] "out_list"              "out_vector"            "plop"                 
## [49] "repeat_func"           "subsetting_table"      "switch_func"          
## [52] "test"                  "test_tbl"              "true_one"             
## [55] "true_two"              "v"                     "v_address"            
## [58] "val"                   "var"                   "while_func"           
## [61] "x"                     "x1"                    "x2"                   
## [64] "x3"                    "x4"                    "x5"                   
## [67] "y"                     "y_address"             "yes"                  
## [70] "yes_final"             "yes_idx"
\end{verbatim}

The difference is where the promise is created. \texttt{ls()} is always evaluated inside \texttt{h05} when \texttt{x} is evaluated. The difference is the environment. When \texttt{ls()} is provided as an explicit parameter, \texttt{x} is a promise whose environment is the global environment. When \texttt{ls()} is a default parameter, it is evaluated in the local environment where it is used.

Hypothesis: does nesting \texttt{ls()} in \texttt{h05} first evaluate \texttt{ls()} then evaluate \texttt{h05()} ?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(magrittr)}
\NormalTok{h05 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ \{y <-}\StringTok{ }\DecValTok{4}\NormalTok{;}\KeywordTok{ls}\NormalTok{()\}) \{}
\NormalTok{   a <-}\StringTok{ }\DecValTok{1}
\NormalTok{   x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{h05}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "a" "x" "y"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ls}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "h05"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\{y <-}\StringTok{ }\DecValTok{4}\NormalTok{;}\KeywordTok{ls}\NormalTok{()\} }\OperatorTok{%>%}\StringTok{ }\KeywordTok{h05}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "h05" "y"  
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ls}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "h05" "y" 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{h05}\NormalTok{(\{x <-}\StringTok{ }\DecValTok{5}\NormalTok{;}\KeywordTok{ls}\NormalTok{()\})}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "h05" "x"   "y" 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ls}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "h05" "x"   "y" 
\end{verbatim}

Notice in all of the latter calls, a is not returned - so it's not evaluating \texttt{ls()} inside of the function.

\hypertarget{exercise-2}{%
\section*{6.5.4.3 Exercise}\label{exercise-2}}
\addcontentsline{toc}{section}{6.5.4.3 Exercise}

I understand this problem is showing us an example of name masking (the function doesn't need to use the \texttt{y\ =\ 0} argument because it gets \texttt{y} from within the definition of x, but I'm fuzzy on what exactly the \texttt{;} does. What does the syntax \texttt{\{y\ \textless{}-\ 1;\ 2\}} mean? Could it be read as "Set \texttt{y\ \textless{}-\ 1} and \texttt{x\ \textless{}-\ 2}?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\DecValTok{10}
\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ \{y <-}\StringTok{ }\DecValTok{1}\NormalTok{; }\DecValTok{2}\NormalTok{\}, }\DataTypeTok{y =} \DecValTok{0}\NormalTok{) \{}
  \KeywordTok{c}\NormalTok{(x, y)}
\NormalTok{\}}
\KeywordTok{f1}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 1
\end{verbatim}

The curly brackets are an expression, which can be read as

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\{}
\NormalTok{  y <-}\StringTok{ }\DecValTok{1}
  \DecValTok{2}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

This is returning \texttt{2} and setting \texttt{1} to \texttt{y}. The colon can be read as a new line in the expression. \texttt{x} is called inside the function and overwrites the argument value of \texttt{y}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ \{y <-}\StringTok{ }\DecValTok{1}\NormalTok{; }\DecValTok{2}\NormalTok{\}, }\DataTypeTok{y =} \DecValTok{0}\NormalTok{) \{}
  \CommentTok{# At this point, neither x nor y have been needed or evaluated. This is "lazy".}
  \KeywordTok{cat}\NormalTok{(y) }
  \CommentTok{# "Summon the current state of y". }
  \CommentTok{# R looks first in the function env - is there a y there? No}
  \CommentTok{# R then looks at the arguments - is there a y there? Yes, it's 0 -> print out zero }
  \CommentTok{# If R had not found y in the arguments, then it would look in the parent environment of the function - the global env.}
  \CommentTok{# That's where it would find y = NULL - but since it already found a default arg, it already stopped evaluating. }
  \KeywordTok{cat}\NormalTok{(x)}
  \CommentTok{# "Summon the current state of x"}
  \CommentTok{# x is an expression that first sets y to equal 1 and then returns the number 2 -> print out 2}
  \KeywordTok{c}\NormalTok{(x, }\CommentTok{# "Summon the current state of x" - x is still the expression that sets y to 1 and then x to 2}
\NormalTok{    y) }\CommentTok{# "Summon the current state of y" - y was set to 1, so y is 1 here.}
\NormalTok{\}}
\KeywordTok{f1}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 02
\end{verbatim}

\begin{verbatim}
## [1] 2 1
\end{verbatim}

Compare to:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ \{y <-}\StringTok{ }\DecValTok{1}\NormalTok{; }\DecValTok{2}\NormalTok{\}, }\DataTypeTok{y =} \DecValTok{0}\NormalTok{) \{}
  \KeywordTok{c}\NormalTok{(y, }\CommentTok{# "Summon the current state of y" - y has not yet been set to anything else, so it returns zero}
\NormalTok{    x) }\CommentTok{# "Summon the current state of x" - x is still the expression that sets y to 1 and then x to 2}
       \CommentTok{# However, y has already been returned - so even though y is now set to 1, it's called after the previous y and does not affect the previous y.}
\NormalTok{\}}
\NormalTok{x =}\StringTok{ }\OtherTok{NULL}
\NormalTok{y =}\StringTok{ }\OtherTok{NULL}
\KeywordTok{f1}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0 2
\end{verbatim}

What is happening here:
- The default value of \texttt{x} is ``assign 1 to y then return 2 implicitly.''
- The default value of \texttt{y} is \texttt{0}.
- \texttt{x} and \texttt{y} aren't their defaults until they're referenced and there isn't a value, so when you invoke the question \texttt{x} is the default, but \texttt{y} is never the default.
- When you get to \texttt{c(x}, \texttt{x} is evaluated. Now the value of \texttt{y} is \texttt{1} instead of its default value!
- When you get to \texttt{c(x,\ y)}, \texttt{y} is now \texttt{1}, so the return is \texttt{2} \texttt{1}

Using the original \texttt{f1} function, if we write \texttt{f1(x\ \textless{}-\ 5)} we get \texttt{5} \texttt{0}, When you make that call, the function's x argument gets set to x \textless{}- 5 (instead of the default). When you get to c(x, the x \textless{}- 5 call gets evaluated in the calling environment (global, most likely, unless you're calling it from inside a function or something).

To see where x gets assigned, try this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ \{y <-}\StringTok{ }\DecValTok{1}\NormalTok{; }\DecValTok{2}\NormalTok{\}, }\DataTypeTok{y =} \DecValTok{0}\NormalTok{) \{}
  \CommentTok{# c(x, y)}
  \StringTok{"Nothing to see here."}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{f2}\NormalTok{(x <-}\StringTok{ }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Nothing to see here."
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error: object 'x' not found
\end{verbatim}

Since \texttt{x} is never used in this version, the \texttt{x\ =\ \{x\ \textless{}-\ 5\}} promise never gets evaluated, so \texttt{x} never gets set in the calling environment. But if you do the same thing with \texttt{f1}, \texttt{x} is now \texttt{5} in the calling environment.

Also note that calling the \texttt{\textless{}-} function returns the value (the second argument) invisibly, so \texttt{y\ \textless{}-\ \{x\ \textless{}-\ 5\}} assigns \texttt{5} to both \texttt{y} and \texttt{x}. I wouldn't recommend ever doing this on purpose, but it's useful to know for debugging weird cases.

A piece that \textbf{ALMOST} confused me was that the function's default value only ever ``exists'' in the function's environment, not in the calling environment, so the original case doesn't change \texttt{y} to \texttt{1} globally. But \texttt{f1(\{y\ \textless{}-\ 1;\ 2\})} \textbf{WILL} change \texttt{y} globally\ldots{} but does not change the value of \texttt{y} inside the function.

\hypertarget{exercise-3}{%
\section*{6.5.4.4 Exercise}\label{exercise-3}}
\addcontentsline{toc}{section}{6.5.4.4 Exercise}

I know this isn't exactly needed to answer the question, but how do we access a function that has methods? For instance - here I want to dig into the \texttt{hist} function using \texttt{hist}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hist}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function (x, ...) 
## UseMethod("hist")
## <bytecode: 0x7f93b9b88d80>
## <environment: namespace:graphics>
\end{verbatim}

does not give me the actual contents of the actual function\ldots{}.

We need to access is using \texttt{hist.\textless{}method\textgreater{}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hist.default}
\end{Highlighting}
\end{Shaded}

\hypertarget{dot-dot-dot}{%
\section*{6.6 dot dot dot}\label{dot-dot-dot}}
\addcontentsline{toc}{section}{6.6 dot dot dot}

``(See also \texttt{rlang::list2()} to support splicing and to silently ignore trailing commas\ldots{}'' Can we come up with a simple use case for \texttt{list2} here? The docs use \texttt{list2(a\ =\ 1,\ a\ =\ 2,\ b\ =\ 3,\ b\ =\ 4,\ 5,\ 6)} but how is this different from \texttt{list}?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{identical}\NormalTok{(}
\NormalTok{  rlang}\OperatorTok{::}\KeywordTok{list2}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{a =} \DecValTok{2}\NormalTok{, }\DataTypeTok{b =} \DecValTok{3}\NormalTok{, }\DataTypeTok{b =} \DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{) ,}
  \KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{a =} \DecValTok{2}\NormalTok{, }\DataTypeTok{b =} \DecValTok{3}\NormalTok{, }\DataTypeTok{b =} \DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\texttt{list2} is most helpful when we need to force environment variables with data variables. We can see this by creating a function that takes a variable number of arguments:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rlang)}

\NormalTok{numeric_list <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  dots <-}\StringTok{ }\KeywordTok{list}\NormalTok{(...)}
\NormalTok{  num <-}\StringTok{ }\KeywordTok{as.numeric}\NormalTok{(dots)}
  \KeywordTok{set_names}\NormalTok{(num, }\KeywordTok{names}\NormalTok{(dots))}
\NormalTok{\}}

\NormalTok{numeric_list2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  dots <-}\StringTok{ }\KeywordTok{list2}\NormalTok{(...)}
\NormalTok{  num <-}\StringTok{ }\KeywordTok{as.numeric}\NormalTok{(dots)}
  \KeywordTok{set_names}\NormalTok{(num, }\KeywordTok{names}\NormalTok{(dots))}
\NormalTok{\}}

\KeywordTok{numeric_list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{numeric_list2}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3
\end{verbatim}

The main difference with list(\ldots{}) is that list2(\ldots{}) enables the \texttt{!!!} syntax to splice lists:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\KeywordTok{numeric_list2}\NormalTok{(}\DecValTok{1}\NormalTok{, }\OperatorTok{!!!}\StringTok{ }\NormalTok{x, }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{numeric_list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\OperatorTok{!!!}\StringTok{ }\NormalTok{x, }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in !x : invalid argument type
\end{verbatim}

``\texttt{lapply()} uses \texttt{...} to pass \texttt{na.rm} on to \texttt{mean()}'' Um, how?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\OtherTok{NA}\NormalTok{), }\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{6}\NormalTok{))}
\KeywordTok{str}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(x, mean, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 2
##  $ : num 2
##  $ : num 5
\end{verbatim}

An lapply takes on two main arguments: what you want to loop over and the function to apply to each element. By including \texttt{...} \texttt{lapply} allows you to supply additional arguments which will be passed to the function inside the \texttt{lapply}. In this case, \texttt{na.rm\ =\ TRUE} is being applied to mean every time it's being called in the loop.

\hypertarget{exercise-4}{%
\section*{6.6.1.2 Exercise}\label{exercise-4}}
\addcontentsline{toc}{section}{6.6.1.2 Exercise}

I tried running \texttt{browser(plot(1:10,\ col\ =\ "red"))} to peek under the hood but only got \texttt{Called\ from:\ top\ level} in the console. What am I missing?

We can use \texttt{debugonce}!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{debugonce}\NormalTok{(}\KeywordTok{plot}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\hypertarget{exit-handlers}{%
\section*{6.7.4 Exit handlers}\label{exit-handlers}}
\addcontentsline{toc}{section}{6.7.4 Exit handlers}

``Always set \texttt{add\ =\ TRUE} when using \texttt{on.exit()} If you don't, each call to \texttt{on.exit()} will overwrite the previous exit handler.'' What does this mean?

\texttt{add\ =\ TRUE} is important when you have more than one \texttt{on.exit} function!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{j08 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{message}\NormalTok{(}\StringTok{"a"}\NormalTok{))}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{message}\NormalTok{(}\StringTok{"b"}\NormalTok{), }\DataTypeTok{add=}\OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{j08}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## a
\end{verbatim}

\begin{verbatim}
## b
\end{verbatim}

Can we go over this code? How does it not change your working directory after you run the function

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cleanup <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(dir, code) \{}
\NormalTok{  old_dir <-}\StringTok{ }\KeywordTok{setwd}\NormalTok{(dir)}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{setwd}\NormalTok{(old_dir), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
  
\NormalTok{  old_opt <-}\StringTok{ }\KeywordTok{options}\NormalTok{(}\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{)}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{options}\NormalTok{(old_opt), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}


\KeywordTok{cleanup}\NormalTok{(}\StringTok{"~"}\NormalTok{)}
\KeywordTok{getwd}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "/Users/mayagans/Documents/bookclub-Advanced_R/QandA"
\end{verbatim}

The behavior of \href{https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/getwd}{\texttt{setwd}} ``changing the working directory'' is actually a \textbf{side effect} of the function - it invisibly returns the previous working directory as the value of the function (potentially for the exact purpose demonstrated). We can use this within our \texttt{on.exit} function to change back to the prior working directory!

If \texttt{on.exit} fails will it continue onto the next \texttt{on.exit} so long as \texttt{add\ ==\ TRUE}
?``on.exit fails it'll continue onto the next one

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{stop}\NormalTok{(}\StringTok{"Error"}\NormalTok{))}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{message}\NormalTok{(}\StringTok{"yay, still called."}\NormalTok{), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in f() : Error
yay, still called.
\end{verbatim}

\hypertarget{exercise-5}{%
\section*{6.7.5.4 Exercise}\label{exercise-5}}
\addcontentsline{toc}{section}{6.7.5.4 Exercise}

\href{https://github.com/Tazinho/Advanced-R-Solutions/blob/5043d9b06c7469a010c568ecb85e12bedca75207/2-06-Functions.Rmd\#L350}{This question is flagged as ``started'' let's try to complete it!} Hadley comments in the repo: ``I think I'm more interested in supplying a path vs.~a logical value here''.

\textbf{{Q}}: How does the \texttt{chdir} parameter of \texttt{source()} compare to \texttt{with\_dir()}? Why might you prefer one approach to the other?
The \texttt{with\_dir()} approach was given in the book as

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    in_dir <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(dir, code) \{}
\NormalTok{      old <-}\StringTok{ }\KeywordTok{setwd}\NormalTok{(dir)}
      \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{setwd}\NormalTok{(old))}
      
      \KeywordTok{force}\NormalTok{(code)}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: \texttt{with\_dir()} takes a path to a working directory as an argument. First the working directory is changed accordingly. \texttt{on.exit()} ensures that the modification to the working directory are reset to the initial value when the function exits.

\texttt{with\_dir} gives you the flexibility to change the path to wherever you want (maybe a parent-level folder) whereas \texttt{source(chdir=TRUE)} changes the path to ``where that file lives specifically''.

Given the following file structure:

\begin{center}\includegraphics[width=12.11in]{images/filetree} \end{center}

Imagine I want to run \texttt{import\_data.R}, but it needs to reference \texttt{images/controlflow.png}. we can do this by setting the \texttt{wd} to \texttt{advRbookclub}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{with_dir}\NormalTok{(}\StringTok{"/advRbookclub/data/import_data.R"}\NormalTok{,}\StringTok{"/advRbookclub"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Or we can use:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{source}\NormalTok{(}\StringTok{"/advRbookclub/data/import_data.R"}\NormalTok{, }\DataTypeTok{chdir=}\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

but then, we'd need to include something like \texttt{setwd(here::here())} in \texttt{import\_data.R} so that it goes back to \texttt{AdvancedR.Rproj} and sets the working directory there.

In conclusion:

\begin{itemize}
\item
  \texttt{source} is a base R function so reduces dependencies. Once set, you could use \texttt{setwd("..")}assuming you can have some confidence that it's part of a repository or something?
\item
  \texttt{with\_dir} is exported from the \texttt{withr} package but is a more fine-tuned control by passing the specific folder name as opposed to a boolean \texttt{TRUE} \textbar{} \texttt{FALSE}.
\end{itemize}

\hypertarget{exercise-6}{%
\section*{6.7.5.5 Exercise}\label{exercise-6}}
\addcontentsline{toc}{section}{6.7.5.5 Exercise}

Can we go over the source code of \texttt{capture.output} and \texttt{capture.output2}?

There were several new terms here to me when going over this function:

\begin{itemize}
\tightlist
\item
  \texttt{stderr} error output
\item
  \texttt{stdout} normal output
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#!/usr/bin/env Rscript}
\CommentTok{# redirect.r -- experiments with warning and error messages}

\CommentTok{# Get any arguments (and ignore them)}
\NormalTok{arguments <-}\StringTok{ }\KeywordTok{commandArgs}\NormalTok{(}\DataTypeTok{trailingOnly=}\OtherTok{TRUE}\NormalTok{)}

\CommentTok{# Default}
\KeywordTok{write}\NormalTok{(}\StringTok{"1) write() to stderr"}\NormalTok{, }\KeywordTok{stderr}\NormalTok{())}
\KeywordTok{write}\NormalTok{(}\StringTok{"1) write() to stdout"}\NormalTok{, }\KeywordTok{stdout}\NormalTok{())}
\KeywordTok{warning}\NormalTok{(}\StringTok{"1) warning()"}\NormalTok{)}

\CommentTok{# Ignore all warnings}
\KeywordTok{options}\NormalTok{(}\DataTypeTok{warn =} \DecValTok{-1}\NormalTok{)}
\KeywordTok{write}\NormalTok{(}\StringTok{"2) write() to stderr"}\NormalTok{, }\KeywordTok{stderr}\NormalTok{())}
\KeywordTok{write}\NormalTok{(}\StringTok{"2) write() to stdout"}\NormalTok{, }\KeywordTok{stdout}\NormalTok{())}
\KeywordTok{warning}\NormalTok{(}\StringTok{"2) warning()"}\NormalTok{)}

\CommentTok{# Send all STDERR to STDOUT using sink()}
\KeywordTok{options}\NormalTok{(}\DataTypeTok{warn =} \DecValTok{0}\NormalTok{) }\CommentTok{# default setting}
\KeywordTok{sink}\NormalTok{(}\KeywordTok{stdout}\NormalTok{(), }\DataTypeTok{type=}\StringTok{"message"}\NormalTok{)}
\KeywordTok{write}\NormalTok{(}\StringTok{"3) write() to stderr"}\NormalTok{, }\KeywordTok{stderr}\NormalTok{())}
\KeywordTok{write}\NormalTok{(}\StringTok{"3) write() to stdout"}\NormalTok{, }\KeywordTok{stdout}\NormalTok{())}
\KeywordTok{warning}\NormalTok{(}\StringTok{"3) warning()"}\NormalTok{)}

\CommentTok{# Send all STDOUT to STDERR using sink()}
\KeywordTok{sink}\NormalTok{(}\OtherTok{NULL}\NormalTok{, }\DataTypeTok{type=}\StringTok{"message"}\NormalTok{) }\CommentTok{# default setting}
\KeywordTok{sink}\NormalTok{(}\KeywordTok{stderr}\NormalTok{(), }\DataTypeTok{type=}\StringTok{"output"}\NormalTok{)}
\KeywordTok{write}\NormalTok{(}\StringTok{"4) write() to stderr"}\NormalTok{, }\KeywordTok{stderr}\NormalTok{())}
\KeywordTok{write}\NormalTok{(}\StringTok{"4) write() to stdout"}\NormalTok{, }\KeywordTok{stdout}\NormalTok{())}
\KeywordTok{warning}\NormalTok{(}\StringTok{"4) warning()"}\NormalTok{)}

\CommentTok{# Send messages and output to separate files}
\NormalTok{msg <-}\StringTok{ }\KeywordTok{file}\NormalTok{(}\StringTok{"message.Rout"}\NormalTok{, }\DataTypeTok{open=}\StringTok{"wt"}\NormalTok{)}
\NormalTok{out <-}\StringTok{ }\KeywordTok{file}\NormalTok{(}\StringTok{"output.Rout"}\NormalTok{, }\DataTypeTok{open=}\StringTok{"wt"}\NormalTok{)}
\KeywordTok{sink}\NormalTok{(msg, }\DataTypeTok{type=}\StringTok{"message"}\NormalTok{)}
\KeywordTok{sink}\NormalTok{(out, }\DataTypeTok{type=}\StringTok{"output"}\NormalTok{)}
\KeywordTok{write}\NormalTok{(}\StringTok{"5) write() to stderr"}\NormalTok{, }\KeywordTok{stderr}\NormalTok{())}
\KeywordTok{write}\NormalTok{(}\StringTok{"5) write() to stdout"}\NormalTok{, }\KeywordTok{stdout}\NormalTok{())}
\KeywordTok{warning}\NormalTok{(}\StringTok{"5) warning()"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{sink} diverts R output to a connection.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zz <-}\StringTok{ }\KeywordTok{file}\NormalTok{(}\StringTok{"all.Rout"}\NormalTok{, }\DataTypeTok{open =} \StringTok{"wt"}\NormalTok{)}
\KeywordTok{sink}\NormalTok{(zz)}
\KeywordTok{sink}\NormalTok{(zz, }\DataTypeTok{type =} \StringTok{"message"}\NormalTok{)}
\KeywordTok{try}\NormalTok{(}\KeywordTok{log}\NormalTok{(}\StringTok{"a"}\NormalTok{))}
\CommentTok{## revert output back to the console -- only then access the file!}
\KeywordTok{sink}\NormalTok{(}\DataTypeTok{type =} \StringTok{"message"}\NormalTok{)}
\KeywordTok{sink}\NormalTok{()}
\KeywordTok{file.show}\NormalTok{(}\StringTok{"all.Rout"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{textConnection} allows R character vectors to be read as if they were being read from a text file.

  \begin{itemize}
  \tightlist
  \item
    They can capture R output to a character vector
  \item
    They can be used to create a new character object or append to an existing one in the user's workspace.
  \item
    At all times the complete lines output to the connection are available in the R object. Closing the connection writes any remaining output to a final element of the character vector.
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{function}\NormalTok{ (..., }\DataTypeTok{file =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{append =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{type =} \KeywordTok{c}\NormalTok{(}\StringTok{"output"}\NormalTok{,}
                                                    \StringTok{"message"}\NormalTok{), }\DataTypeTok{split =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{\{}
  \CommentTok{# Capture dots}
  \CommentTok{# [-1L] removes the list()}
\NormalTok{  args <-}\StringTok{ }\KeywordTok{substitute}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\KeywordTok{cat}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)))[}\OperatorTok{-}\NormalTok{1L]}
  
  \CommentTok{# match}
\NormalTok{  type <-}\StringTok{ }\KeywordTok{match.arg}\NormalTok{(type)}
  \CommentTok{# set default return value}
\NormalTok{  rval <-}\StringTok{ }\OtherTok{NULL}
  \CommentTok{# set default closer}
\NormalTok{  closeit <-}\StringTok{ }\OtherTok{TRUE}
  \CommentTok{# if file is null, then}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(file))}
    \CommentTok{# If file is null, then create a write-only text connection object which will}
    \CommentTok{# save to the variable rval in the execution environment (local = TRUE).}
    \CommentTok{# see https://biostatmatt.com/R/R-conn-ints.pdf for gritty info on connections (and sinks)}
\NormalTok{    file <-}\StringTok{ }\KeywordTok{textConnection}\NormalTok{(}\StringTok{"rval"}\NormalTok{, }\StringTok{"w"}\NormalTok{, }\DataTypeTok{local =} \OtherTok{TRUE}\NormalTok{)}
  \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.character}\NormalTok{(file))}
    \CommentTok{# if "file" is a character vector, then interpret it as a filename.  Open a}
    \CommentTok{# file connection in either append or write mode, depending on the value of}
    \CommentTok{# "append"}
\NormalTok{    file <-}\StringTok{ }\KeywordTok{file}\NormalTok{(file, }\ControlFlowTok{if}\NormalTok{ (append)}
      \StringTok{"a"}
      \ControlFlowTok{else} \StringTok{"w"}\NormalTok{)}
  \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{inherits}\NormalTok{(file, }\StringTok{"connection"}\NormalTok{)) \{}
    \CommentTok{# if "file" is already a connection object, check if it is open.  If not, open it}
    \CommentTok{# in append mode, if specified, otherwise in write mode.}
    \CommentTok{# inherits refers to the S3 class system.}
    \CommentTok{#}
    \CommentTok{# Browse[2]> class(file)}
    \CommentTok{# [1] "textConnection" "connection"}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{isOpen}\NormalTok{(file))}
      \KeywordTok{open}\NormalTok{(file, }\ControlFlowTok{if}\NormalTok{ (append)}
        \StringTok{"a"}
        \ControlFlowTok{else} \StringTok{"w"}\NormalTok{)}
    \CommentTok{# if the connection is already open, don't close it in this function.}
    \ControlFlowTok{else}\NormalTok{ closeit <-}\StringTok{ }\OtherTok{FALSE}
\NormalTok{  \}}
  \CommentTok{# if you get here, then you misspecified "file"}
  \ControlFlowTok{else} \KeywordTok{stop}\NormalTok{(}\StringTok{"'file' must be NULL, a character string or a connection"}\NormalTok{)}
  \CommentTok{# sink all output of type "type" into the connection "file".  If you would like}
  \CommentTok{# the output to continue to its original source, then "split" it.}
  \CommentTok{#}
  \CommentTok{# by default, messages (messages, warnings, errors) go to stderr and}
  \CommentTok{# everything else to stdout.}
  \KeywordTok{sink}\NormalTok{(file, }\DataTypeTok{type =}\NormalTok{ type, }\DataTypeTok{split =}\NormalTok{ split)}
  \KeywordTok{on.exit}\NormalTok{(\{}
    \CommentTok{# on exit, call sink with the same arguments and without "file" being specified.}
    \CommentTok{# this will cause the sink from the line before to terminate.}
    \KeywordTok{sink}\NormalTok{(}\DataTypeTok{type =}\NormalTok{ type, }\DataTypeTok{split =}\NormalTok{ split)}
    \CommentTok{# Close the connection (always, unless "file" was provided as}
    \CommentTok{# an already open connection)}
    \ControlFlowTok{if}\NormalTok{ (closeit) }\KeywordTok{close}\NormalTok{(file)}
\NormalTok{  \})}
  \CommentTok{# store the calling environment in pf.  i.e. pf refers to the environment in}
  \CommentTok{# which capture.output was called.}
\NormalTok{  pf <-}\StringTok{ }\KeywordTok{parent.frame}\NormalTok{()}
  \CommentTok{# define a local function which will evaluate its sole argument (expr) in the}
  \CommentTok{# parent frame.}
\NormalTok{  evalVis <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) }\KeywordTok{withVisible}\NormalTok{(}\KeywordTok{eval}\NormalTok{(expr, pf))}
  \CommentTok{# for each argument collected in the dot dot dot.}
  \CommentTok{#}
  \CommentTok{# use split = TRUE to help you debug at this point.  When you try to poke around}
  \CommentTok{# with the sink applied, you are rightfully stymied because all output is going}
  \CommentTok{# to the sink connection!}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(args)) \{}
    \CommentTok{# store the argument in expr}
\NormalTok{    expr <-}\StringTok{ }\NormalTok{args[[i]]}
    \CommentTok{# based on the mode of the expr, evaluate it.}
\NormalTok{    tmp <-}\StringTok{ }\ControlFlowTok{switch}\NormalTok{(}\KeywordTok{mode}\NormalTok{(expr),}
                  \DataTypeTok{expression =} \KeywordTok{lapply}\NormalTok{(expr, evalVis),}
                  \DataTypeTok{call =}\NormalTok{ ,}
                  \DataTypeTok{name =} \KeywordTok{list}\NormalTok{(}\KeywordTok{evalVis}\NormalTok{(expr)),}
                  \KeywordTok{stop}\NormalTok{(}\StringTok{"bad argument"}\NormalTok{))}
    \CommentTok{# print any visible values output during evaluation.}
    \CommentTok{# This print will be collected by the sink we set up earlier and saved to}
    \CommentTok{# the file connection.}
    \ControlFlowTok{for}\NormalTok{ (item }\ControlFlowTok{in}\NormalTok{ tmp) }\ControlFlowTok{if}\NormalTok{ (item}\OperatorTok{$}\NormalTok{visible)}
      \KeywordTok{print}\NormalTok{(item}\OperatorTok{$}\NormalTok{value)}
\NormalTok{  \}}
  \CommentTok{# calling on.exit with no arguments will clear the exit handler.}
  \CommentTok{# we are doing this because the on.exit was designed to safeguard the sink}
  \CommentTok{# and files being closed in the case of an exception when evaluating the}
  \CommentTok{# passed in arguments.}
  \KeywordTok{on.exit}\NormalTok{()}
  \CommentTok{# undo the sink}
  \KeywordTok{sink}\NormalTok{(}\DataTypeTok{type =}\NormalTok{ type, }\DataTypeTok{split =}\NormalTok{ split)}
  \CommentTok{# close the file if necessary}
  \ControlFlowTok{if}\NormalTok{ (closeit)}
    \KeywordTok{close}\NormalTok{(file)}
  \CommentTok{# return the captured output or null invisibly otherwise.}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(rval))}
    \KeywordTok{invisible}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
  \ControlFlowTok{else}\NormalTok{ rval}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{capture.output2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
\NormalTok{  temp <-}\StringTok{ }\KeywordTok{tempfile}\NormalTok{()}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{file.remove}\NormalTok{(temp), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}

  \KeywordTok{sink}\NormalTok{(temp)}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{sink}\NormalTok{(), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}

  \KeywordTok{force}\NormalTok{(code)}
  \KeywordTok{readLines}\NormalTok{(temp)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The second function will always sink output to a temporary file, and then return the results by reading the file back in (and returning a character vector). It uses two exit handlers, one to clean up the temporary file, and one to remove the sink.

\hypertarget{replacement-functions}{%
\section*{6.8.4 Replacement functions}\label{replacement-functions}}
\addcontentsline{toc}{section}{6.8.4 Replacement functions}

Can we put into words the translation for

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{, }\DataTypeTok{c =} \DecValTok{3}\NormalTok{)}
\KeywordTok{names}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "a" "b" "c"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{names}\NormalTok{(x)[}\DecValTok{2}\NormalTok{] <-}\StringTok{ "two"}
\KeywordTok{names}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "a"   "two" "c"
\end{verbatim}

Being equal to

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{*tmp*}\StringTok{`}\NormalTok{ <-}\StringTok{ }\NormalTok{x}
\NormalTok{x <-}\StringTok{ `}\DataTypeTok{names<-}\StringTok{`}\NormalTok{(}\StringTok{`}\DataTypeTok{*tmp*}\StringTok{`}\NormalTok{, }\StringTok{`}\DataTypeTok{[<-}\StringTok{`}\NormalTok{(}\KeywordTok{names}\NormalTok{(}\StringTok{`}\DataTypeTok{*tmp*}\StringTok{`}\NormalTok{), }\DecValTok{2}\NormalTok{, }\StringTok{"two"}\NormalTok{))}
\KeywordTok{rm}\NormalTok{(}\StringTok{`}\DataTypeTok{*tmp*}\StringTok{`}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can dig into the \href{https://github.com/wch/r-source/blob/2cdea4811caa2417e2cf32a0c7ad3be70325eec1/src/main/eval.c\#L2787}{source code}, but the jist is that in order to implement these complex assignments:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Copy \texttt{x} into a temporary variable \texttt{*temp*}
\item
  \texttt{{[}\textless{}-(names(*tmp*),\ 2,\ "two")} modifies the second element of the names of \texttt{*temp*},
\item
  \texttt{names\textless{}-}(\texttt{*tmp*} assigns step 2 to \texttt{*temp*} names
\item
  Clean up by removing the temp variable
\end{enumerate}

\hypertarget{exercise-7}{%
\section*{6.8.6.3 Exercise}\label{exercise-7}}
\addcontentsline{toc}{section}{6.8.6.3 Exercise}

\href{https://github.com/Tazinho/Advanced-R-Solutions/blob/5043d9b06c7469a010c568ecb85e12bedca75207/2-06-Functions.Rmd\#L433}{This question is flagged as ``started'' let's try to complete it!}

\textbf{{Q}}: Explain why the following code fails:

\texttt{r\ \ \ \ \ modify(get("x"),\ 1)\ \textless{}-\ 10\ \ \ \ \ \#\textgreater{}\ Error:\ target\ of\ assignment\ expands\ to\ non-language\ object}

\textbf{{A}}: First, let's define \texttt{x} and recall the definition of \texttt{modify()} from the textbook:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{3}
    
    \StringTok{`}\DataTypeTok{modify<-}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, position, value) \{}
\NormalTok{      x[position] <-}\StringTok{ }\NormalTok{value}
\NormalTok{      x}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

R internally transforms the code and the transformed code reproduces the error above.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{get}\NormalTok{(}\StringTok{"x"}\NormalTok{) <-}\StringTok{ `}\DataTypeTok{modify<-}\StringTok{`}\NormalTok{(}\KeywordTok{get}\NormalTok{(}\StringTok{"x"}\NormalTok{), }\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\CommentTok{#> Error in get("x") <- `modify<-`(get("x"), 1, 10) : }
\CommentTok{#> target of assignment expands to non-language object}
\end{Highlighting}
\end{Shaded}

The error occurs during the assignment, because no corresponding replacement function, i.e. \texttt{get\textless{}-} exists for \texttt{get()}. To confirm this we can reproduce the error via the following simple example.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{get}\NormalTok{(}\StringTok{"x"}\NormalTok{) <-}\StringTok{ }\DecValTok{2}
\CommentTok{#> Error in get("x") <- 2 : target of assignment expands to non-language object}
\end{Highlighting}
\end{Shaded}

I don't really see why this needs to be expanded upon\ldots{}.

\hypertarget{environments}{%
\chapter{Environments}\label{environments}}

\hypertarget{parents}{%
\section*{7.2.3 Parents}\label{parents}}
\addcontentsline{toc}{section}{7.2.3 Parents}

What's the relationship between base, empty enviornment, and global enviornment?

The working environment is the environment whose names would currently mask names in any other environment. Note that in the book, the term current environment is used not working environment. At any given time there is an environment that is most immediately-visible i.e.~its names will mask the same names in any other environment. This is the current environment. The identity of the current environment can change e.g.~when entering a function. It is often the case that the current environment is the global environment i.e.~typically when working interactively.

Are functions the only mechanism for changing the current environment? (I believe the answer is yes.)

Consider the following from the book:

\begin{quote}
The current environment, or \texttt{current\_env()} is the environment in which code is currently executing. When you're experimenting interactively, that's usually the global environment, or \texttt{global\_env()}.
\end{quote}

The use of the word ``usually'' in this sentence raises the possibility that there's an exception. That exception could possibly mean

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  There's a way to change the environment in interactive mode without going into a function
\item
  You can experiment interactively within a function or
\item
  Something I'm ignorant of.
\end{enumerate}

I know that you can step-through a function in the debug browser so maybe that's what he means?

But then the very next line in the text says:

\begin{quote}
The global environment is sometimes called your ``workspace'', as it's where all interactive (i.e.~outside of a function) computation takes place.
\end{quote}

It both i) defines interactive specifically to exclude the inside of a function and ii) makes a stronger claim, ``all interactive computation'' vs ``usually''.

If you put a breakpoint or \texttt{browser()} call inside a function, then you would be working interactively in a function environment.

Does hierarchy of environments have a computer science name (linked list?)?

The hierarchy of environments is not a linked list, it is a directed graph.

Clarification: the global environment's parent is all the packages loaded within the environment, not the empty environment, right? How do we check this? \texttt{parent.env(global)}?

Each package becomes a parent to the global environment. We can inspect local enviornments using \texttt{search\_envs()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{search_envs}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [[1]] $ <env: global>
##  [[2]] $ <env: package:openintro>
##  [[3]] $ <env: package:rlang>
##  [[4]] $ <env: package:cyclocomp>
##  [[5]] $ <env: package:lobstr>
##  [[6]] $ <env: package:kableExtra>
##  [[7]] $ <env: package:forcats>
##  [[8]] $ <env: package:stringr>
##  [[9]] $ <env: package:dplyr>
## [[10]] $ <env: package:purrr>
## [[11]] $ <env: package:readr>
## [[12]] $ <env: package:tidyr>
## [[13]] $ <env: package:tibble>
## [[14]] $ <env: package:ggplot2>
## [[15]] $ <env: package:tidyverse>
## [[16]] $ <env: package:stats>
## [[17]] $ <env: package:graphics>
## [[18]] $ <env: package:grDevices>
## [[19]] $ <env: package:utils>
## [[20]] $ <env: package:datasets>
## ... and 3 more environments
\end{verbatim}

\hypertarget{super-assignment}{%
\section*{7.2.4 Super assignment}\label{super-assignment}}
\addcontentsline{toc}{section}{7.2.4 Super assignment}

Let's expand on the concept of super assignment

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{0}
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  x <-}\StringTok{ }\DecValTok{2}
\NormalTok{  x <<-}\StringTok{ }\DecValTok{1}
\NormalTok{  x}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

Note that the assignment inside \texttt{f} is local, but super assignment ``never creates a variable in the current environment'' so it modifies the global \texttt{x} and not the local \texttt{x}.

If you want to break your brain a bit, check out:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{0}
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  x <-}\StringTok{ }\NormalTok{x}
\NormalTok{  x <<-}\StringTok{ }\NormalTok{x }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{  x}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{f}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{f}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\hypertarget{getting-and-setting}{%
\section*{7.2.5 Getting and setting}\label{getting-and-setting}}
\addcontentsline{toc}{section}{7.2.5 Getting and setting}

``But you can't use \texttt{{[}{[}} with numeric indices, and you can't use \texttt{{[}}:''

It makes sense to me that you can't use numeric indexes because objects in an environment aren't ordered, but why can't you use \texttt{{[}}? \emph{The solutions manual states: "The second option would return two objects at the same time. What data structure would they be contained inside?}

\texttt{{[}} returns an object of the same type, if we were to apply this to environments we'd have an environment returning an environment.

\hypertarget{advanced-bindings}{%
\section*{7.2.6 Advanced bindings}\label{advanced-bindings}}
\addcontentsline{toc}{section}{7.2.6 Advanced bindings}

Hadley mentions delayed bindings are used when autoloading datasets with packages - can we find an example of this? How is this different from including \texttt{LazyData:\ true} in your description file?

The \texttt{LazyData:\ true} entry in \texttt{DESCRIPTION} just informs that delayed binding should be used. \texttt{autoload} \textbf{does} use delayed bindings {[}from source code: \texttt{do.call("delayedAssign",\ list(name,\ newcall,\ .GlobalEnv,\ .AutoloadEnv))}{]} but lazydata that gets used by packages is ultimately implemented as an internal function. If you scan through \texttt{View(loadNamespace)}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{file.exists}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(dbbase, }\StringTok{".rdb"}\NormalTok{))) }
      \KeywordTok{lazyLoad}\NormalTok{(dbbase, env)}
\NormalTok{    dbbase <-}\StringTok{ }\KeywordTok{file.path}\NormalTok{(pkgpath, }\StringTok{"data"}\NormalTok{, }\StringTok{"Rdata"}\NormalTok{)}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{file.exists}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(dbbase, }\StringTok{".rdb"}\NormalTok{))) }
      \KeywordTok{lazyLoad}\NormalTok{(dbbase, }\KeywordTok{.getNamespaceInfo}\NormalTok{(env, }\StringTok{"lazydata"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

and \texttt{lazyLoad} eventually calls \texttt{.Internal(makeLazy(vars,\ vals,\ expr,\ db,\ envir))} which leads you to \url{https://github.com/wch/r-source/blob/726bce63825844715860d35fdf76539445529f52/src/main/builtin.c\#L103}
and ultimately the delayed binding is realized as a promise with \texttt{defineVar(name,\ mkPROMISE(expr0,\ eenv),\ aenv);}.

\hypertarget{recursing-over-environments}{%
\section*{7.3 Recursing over environments}\label{recursing-over-environments}}
\addcontentsline{toc}{section}{7.3 Recursing over environments}

How can we re-write \texttt{where} so that it returns all functions with the same name?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{where2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(in_name, }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
  
\NormalTok{  all_functions <-}\StringTok{ ""}
\NormalTok{  index <-}\StringTok{ }\DecValTok{1}

  \ControlFlowTok{while}\NormalTok{ (}\OperatorTok{!}\KeywordTok{identical}\NormalTok{(env, }\KeywordTok{empty_env}\NormalTok{())) \{}
    \CommentTok{# if success}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{env_has}\NormalTok{(env, in_name)) \{}
\NormalTok{      all_functions[index] <-}\StringTok{ }\KeywordTok{env_name}\NormalTok{(env)}
\NormalTok{      index <-}\StringTok{ }\NormalTok{index }\OperatorTok{+}\StringTok{ }\DecValTok{1}
      \CommentTok{#return()}
\NormalTok{    \}}
    \CommentTok{# inspect parent}
\NormalTok{    env <-}\StringTok{ }\KeywordTok{env_parent}\NormalTok{(env)}
\NormalTok{  \}}
  \CommentTok{# base case - I'm missing this I think}
  \KeywordTok{return}\NormalTok{(all_functions)}
\NormalTok{\}}

\CommentTok{# load dplyr so you have two filters}
\KeywordTok{library}\NormalTok{(dplyr)}
\KeywordTok{where2}\NormalTok{(}\StringTok{"filter"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "package:dplyr" "package:stats"
\end{verbatim}

We can also create a function that emulates \texttt{pryr}'s where:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{where3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, }\DataTypeTok{env =} \KeywordTok{parent.frame}\NormalTok{(), }\DataTypeTok{found =} \KeywordTok{character}\NormalTok{()) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{identical}\NormalTok{(env, }\KeywordTok{emptyenv}\NormalTok{()))}
    \KeywordTok{return}\NormalTok{(found)}
  \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{exists}\NormalTok{(name, env, }\DataTypeTok{inherits =} \OtherTok{FALSE}\NormalTok{)) \{}
    \KeywordTok{Recall}\NormalTok{(name, }\KeywordTok{parent.env}\NormalTok{(env), }\KeywordTok{c}\NormalTok{(found, }\KeywordTok{environmentName}\NormalTok{(env)))}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \KeywordTok{Recall}\NormalTok{(name, }\KeywordTok{parent.env}\NormalTok{(env), found)}
\NormalTok{  \}}
\NormalTok{\}}
  
\KeywordTok{where3}\NormalTok{(}\StringTok{"filter"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "package:dplyr" "package:stats"
\end{verbatim}

\hypertarget{exercises-3}{%
\section*{7.3.1.2 Exercises}\label{exercises-3}}
\addcontentsline{toc}{section}{7.3.1.2 Exercises}

I understood the recursion in the prior example, but what is inherits doing here? Can we go through this line for line and discuss what is happening in this function?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fget <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{(), }\DataTypeTok{inherits =} \OtherTok{TRUE}\NormalTok{) \{}
  \CommentTok{# Base case}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{env_has}\NormalTok{(env, name)) \{}
\NormalTok{    obj <-}\StringTok{ }\KeywordTok{env_get}\NormalTok{(env, name)}

    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.function}\NormalTok{(obj)) \{}
      \KeywordTok{return}\NormalTok{(obj)}
\NormalTok{    \}}
\NormalTok{  \}}

  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{identical}\NormalTok{(env, }\KeywordTok{emptyenv}\NormalTok{()) }\OperatorTok{||}\StringTok{ }\OperatorTok{!}\NormalTok{inherits) \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Could not find function called }\CharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, name, }\StringTok{"}\CharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{  \}}

  \CommentTok{# Recursive Case}
  \KeywordTok{fget}\NormalTok{(name, }\KeywordTok{env_parent}\NormalTok{(env))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Test}
\NormalTok{mean <-}\StringTok{ }\DecValTok{10}
\KeywordTok{fget}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\DataTypeTok{inherits =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function (x, ...) 
## UseMethod("mean")
## <bytecode: 0x7f93b99bc290>
## <environment: namespace:base>
\end{verbatim}

Inherits is an argument that stops the function from performing the recursive action of looking into the parent environment for the name. Inherits is acting like a valve. If false, and the name wasnt found in the current environment, then stop because the next expression searches the parent of env. In the case environment is the empty environment then stop because the empty environment doesnt have a parent.

\hypertarget{function-enviornment}{%
\section*{7.4.2 Function enviornment}\label{function-enviornment}}
\addcontentsline{toc}{section}{7.4.2 Function enviornment}

I found this section a little confusing. Can we go over the second figure in the section? Where does \texttt{x} live? \texttt{g} points to x but \texttt{x} is in the global enviornment? Can we come up with our own example for a function being bound to the global environment but accessing variables from its own enviornment? (I think this is what the second figure in the section is trying to display)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\DecValTok{1}
\NormalTok{e <-}\StringTok{ }\KeywordTok{env}\NormalTok{()}
\NormalTok{e}\OperatorTok{$}\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\DecValTok{1}
\NormalTok{e}\OperatorTok{$}\NormalTok{g}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function() 1
\end{verbatim}

This can be seen in our \texttt{where2} example in the recursion section!

\hypertarget{namespaces}{%
\section*{7.4.3 Namespaces}\label{namespaces}}
\addcontentsline{toc}{section}{7.4.3 Namespaces}

``Every binding in the package environment is also found in the namespace environment; this ensures every function can use every other function in the package. But some bindings only occur in the namespace environment. These are known as internal or non-exported objects, which make it possible to hide internal implementation details from the user.''

When you're developing a package does the namespace environment just come with your package for free when you build it or you need to create both your package and its namespace env?

How do you create functions that exist only in the namespace environment?

When you are building the package, everything in the NAMESPACE file gets generated by \texttt{roxygen2}. Attaching a package puts the package in the search path of namespaces. So when you run \texttt{library(package)} or \texttt{require(package)} it creates the namespace environment. Package developers control what names are available by exporting to namespace (and otherwise you can call non-exported with \texttt{:::}).

For example let's say you want to extend \texttt{forcats} to use ordered factors to lump the tails. In order to get it to work, we need to use some forcats helper functions. We could just copy the code for the functions and added them to our scripts, but for prototyping it's easy enough to just use \texttt{:::}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fct_lump_ordered <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f, n, prop, q, }\DataTypeTok{w =} \OtherTok{NULL}\NormalTok{,}
                             \DataTypeTok{other_level_low =} \StringTok{"Other Low"}\NormalTok{,}
                             \DataTypeTok{other_level_high =} \StringTok{"Other High"}\NormalTok{,}
                             \DataTypeTok{ties.method =} \KeywordTok{c}\NormalTok{(}\StringTok{"min"}\NormalTok{, }\StringTok{"average"}\NormalTok{, }\StringTok{"first"}\NormalTok{, }\StringTok{"last"}\NormalTok{, }\StringTok{"random"}\NormalTok{, }\StringTok{"max"}\NormalTok{)) \{}
\NormalTok{  f <-}\StringTok{ }\KeywordTok{check_ordered}\NormalTok{(f)}
\NormalTok{  w <-}\StringTok{ }\NormalTok{forcats}\OperatorTok{:::}\KeywordTok{check_weights}\NormalTok{(w, }\KeywordTok{length}\NormalTok{(f))}
\NormalTok{  ties.method <-}\StringTok{ }\KeywordTok{match.arg}\NormalTok{(ties.method)}
\NormalTok{  levels <-}\StringTok{ }\KeywordTok{levels}\NormalTok{(f)}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(w)) \{}
\NormalTok{    count <-}\StringTok{ }\KeywordTok{as.vector}\NormalTok{(}\KeywordTok{table}\NormalTok{(f))}
\NormalTok{    total <-}\StringTok{ }\KeywordTok{length}\NormalTok{(f)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    count <-}\StringTok{ }\KeywordTok{as.vector}\NormalTok{(}\KeywordTok{tapply}\NormalTok{(w, f, }\DataTypeTok{FUN =}\NormalTok{ sum))}
\NormalTok{    total <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(w)}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{all}\NormalTok{(}\KeywordTok{missing}\NormalTok{(n), }\KeywordTok{missing}\NormalTok{(prop), }\KeywordTok{missing}\NormalTok{(q))) \{}
\NormalTok{    lump <-}\StringTok{ }\NormalTok{forcats}\OperatorTok{:::}\KeywordTok{in_smallest}\NormalTok{(count)}
\NormalTok{    lump <-}\StringTok{ }\KeywordTok{lump_range}\NormalTok{(}\OperatorTok{!}\NormalTok{lump)}
\NormalTok{    new_levels <-}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(lump }\OperatorTok{==}\StringTok{ }\OperatorTok{-}\NormalTok{1L,other_level_low, }\KeywordTok{ifelse}\NormalTok{(lump }\OperatorTok{==}\StringTok{ }\NormalTok{1L, other_level_high, levels))}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{missing}\NormalTok{(n) ) \{}
    \ControlFlowTok{if}\NormalTok{ (n }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\NormalTok{      rank <-}\StringTok{ }\KeywordTok{rank}\NormalTok{(count, }\DataTypeTok{ties =}\NormalTok{ ties.method)}
\NormalTok{      n <-}\StringTok{ }\OperatorTok{-}\NormalTok{n}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{      rank <-}\StringTok{ }\KeywordTok{rank}\NormalTok{(}\OperatorTok{-}\NormalTok{count, }\DataTypeTok{ties =}\NormalTok{ ties.method)}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{sum}\NormalTok{(rank }\OperatorTok{>}\StringTok{ }\NormalTok{n) }\OperatorTok{<=}\StringTok{ }\DecValTok{1}\NormalTok{) \{}
      \KeywordTok{return}\NormalTok{(f)}
\NormalTok{    \}}
\NormalTok{    lump <-}\StringTok{ }\KeywordTok{lump_range}\NormalTok{(rank }\OperatorTok{<=}\StringTok{ }\NormalTok{n)}
\NormalTok{    new_levels <-}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(lump }\OperatorTok{==}\StringTok{ }\OperatorTok{-}\NormalTok{1L, other_level_low, }\KeywordTok{ifelse}\NormalTok{(lump }\OperatorTok{==}\StringTok{ }\NormalTok{1L, other_level_high, levels))}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{missing}\NormalTok{(prop)) \{}
\NormalTok{    prop_n <-}\StringTok{ }\NormalTok{count}\OperatorTok{/}\NormalTok{total}
    \ControlFlowTok{if}\NormalTok{(prop }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\NormalTok{      lump <-}\StringTok{ }\KeywordTok{lump_range}\NormalTok{(prop_n }\OperatorTok{<=}\StringTok{ }\OperatorTok{-}\NormalTok{prop)}
\NormalTok{      new_levels <-}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(lump }\OperatorTok{==}\StringTok{ }\OperatorTok{-}\NormalTok{1L, other_level_low, }\KeywordTok{ifelse}\NormalTok{(lump }\OperatorTok{==}\StringTok{ }\NormalTok{1L, other_level_high, levels))}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{sum}\NormalTok{(prop_n }\OperatorTok{<=}\StringTok{ }\NormalTok{prop) }\OperatorTok{<=}\StringTok{ }\DecValTok{1}\NormalTok{) \{}
        \KeywordTok{return}\NormalTok{(f)}
\NormalTok{      \}}
\NormalTok{      lump <-}\StringTok{ }\KeywordTok{lump_range}\NormalTok{(prop_n }\OperatorTok{>=}\StringTok{ }\NormalTok{prop)}
\NormalTok{      new_levels <-}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(lump }\OperatorTok{==}\StringTok{ }\OperatorTok{-}\NormalTok{1L, other_level_low, }\KeywordTok{ifelse}\NormalTok{(lump }\OperatorTok{==}\StringTok{ }\NormalTok{1L, other_level_high, levels))}
\NormalTok{    \}}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{missing}\NormalTok{(q)) \{}
\NormalTok{    cdf <-}\StringTok{ }\KeywordTok{cumsum}\NormalTok{(count)}\OperatorTok{/}\KeywordTok{sum}\NormalTok{(count)}
\NormalTok{    lump <-}\StringTok{ }\KeywordTok{lump_range}\NormalTok{(cdf }\OperatorTok{>=}\StringTok{ }\NormalTok{q[}\DecValTok{1}\NormalTok{] }\OperatorTok{&}\StringTok{ }\NormalTok{cdf }\OperatorTok{<=}\StringTok{ }\NormalTok{q[}\DecValTok{2}\NormalTok{])}
\NormalTok{    new_levels <-}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(lump }\OperatorTok{==}\StringTok{ }\OperatorTok{-}\NormalTok{1L, other_level_low, }\KeywordTok{ifelse}\NormalTok{(lump }\OperatorTok{==}\StringTok{ }\NormalTok{1L, other_level_high, levels))}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{ (other_level_low }\OperatorTok{%in%}\StringTok{ }\NormalTok{new_levels }\OperatorTok{&&}\StringTok{ }\NormalTok{other_level_high }\OperatorTok{%in%}\StringTok{ }\NormalTok{new_levels) \{}
\NormalTok{    f <-}\StringTok{ }\NormalTok{forcats}\OperatorTok{::}\KeywordTok{lvls_revalue}\NormalTok{(f, new_levels)}
\NormalTok{    forcats}\OperatorTok{::}\KeywordTok{fct_relevel}\NormalTok{(f, other_level_low)}
\NormalTok{    forcats}\OperatorTok{::}\KeywordTok{fct_relevel}\NormalTok{(f, other_level_high, }\DataTypeTok{after =} \OtherTok{Inf}\NormalTok{)}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (other_level_low }\OperatorTok{%in%}\StringTok{ }\NormalTok{new_levels) \{}
\NormalTok{    f <-}\StringTok{ }\NormalTok{forcats}\OperatorTok{::}\KeywordTok{lvls_revalue}\NormalTok{(f, new_levels)}
\NormalTok{    forcats}\OperatorTok{::}\KeywordTok{fct_relevel}\NormalTok{(f, other_level_low)}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (other_level_high }\OperatorTok{%in%}\StringTok{ }\NormalTok{new_levels) \{}
\NormalTok{    f <-}\StringTok{ }\NormalTok{forcats}\OperatorTok{::}\KeywordTok{lvls_revalue}\NormalTok{(f, new_levels)}
\NormalTok{    forcats}\OperatorTok{::}\KeywordTok{fct_relevel}\NormalTok{(f, other_level_high, }\DataTypeTok{after =} \OtherTok{Inf}\NormalTok{)}
\NormalTok{  \}}
  \ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    f}
\NormalTok{  \}}
\end{Highlighting}
\end{Shaded}

How do conflicted packages identify duplicate function names and print them out

We can use \texttt{conflict\_scout}!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{conflicted}\OperatorTok{::}\NormalTok{conflict_scout}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## function (pkgs = NULL) 
## {
##     pkgs <- pkgs %||% pkgs_attached()
##     objs <- lapply(pkgs, pkg_ls)
##     names(objs) <- pkgs
##     index <- invert(objs)
##     potential <- Filter(function(x) length(x) > 1, index)
##     unique <- Map(unique_obj, names(potential), potential)
##     conflicts <- Filter(function(x) length(x) > 1, unique)
##     conflicts <- map2(names(conflicts), conflicts, superset_principle)
##     conflicts <- map2(names(conflicts), conflicts, drop_moved)
##     for (fun in ls(prefs)) {
##         if (!has_name(conflicts, fun)) 
##             next
##         conflicts[[fun]] <- prefs_resolve(fun, conflicts[[fun]])
##     }
##     conflicts <- compact(conflicts)
##     new_conflict_report(conflicts)
## }
## <bytecode: 0x7f93c254faf8>
## <environment: namespace:conflicted>
\end{verbatim}

\hypertarget{call-stacks}{%
\section*{7.5 Call stacks}\label{call-stacks}}
\addcontentsline{toc}{section}{7.5 Call stacks}

What exactly is a frame?

A frame is a singular step within the CST - in thr following example, \texttt{f}, \texttt{g}, and \texttt{h} are each frames

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{g}\NormalTok{(}\DataTypeTok{x =} \DecValTok{2}\NormalTok{)}
\NormalTok{\}}
\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{h}\NormalTok{(}\DataTypeTok{x =} \DecValTok{3}\NormalTok{)}
\NormalTok{\}}
\NormalTok{h <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{stop}\NormalTok{()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{data-structures}{%
\section*{7.6 Data Structures}\label{data-structures}}
\addcontentsline{toc}{section}{7.6 Data Structures}

Can we discuss what's happening in this function? Since it's similar to the \texttt{setwd} function from last week could we build on this function to include \texttt{on.exit()}?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_env <-}\StringTok{ }\KeywordTok{new.env}\NormalTok{(}\DataTypeTok{parent =} \KeywordTok{emptyenv}\NormalTok{())}
\NormalTok{my_env}\OperatorTok{$}\NormalTok{a <-}\StringTok{ }\DecValTok{1}

\NormalTok{get_a <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  my_env}\OperatorTok{$}\NormalTok{a}
\NormalTok{\}}

\NormalTok{set_a <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(value) \{}
\NormalTok{  old <-}\StringTok{ }\NormalTok{my_env}\OperatorTok{$}\NormalTok{a}
\NormalTok{  my_env}\OperatorTok{$}\NormalTok{a <-}\StringTok{ }\NormalTok{value}
  \KeywordTok{invisible}\NormalTok{(old)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We can use those two functions like we did getting and setting the work directory inside another function - using the old value within \texttt{on.exit} to reset \texttt{my\_env\$a} outside of the function: Hadley suggests returning invisible old so that you don't need to explicitly call \texttt{get\_a}, you can just assign the output of \texttt{set\_a}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{set_a <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(value) \{}
\NormalTok{  old <-}\StringTok{ }\NormalTok{my_env}\OperatorTok{$}\NormalTok{a}
\NormalTok{  my_env}\OperatorTok{$}\NormalTok{a <-}\StringTok{ }\NormalTok{value}
  \KeywordTok{invisible}\NormalTok{(old)}
\NormalTok{\}}

\KeywordTok{do_thing_where_env_a_is_value}\NormalTok{(value, code) \{}
\NormalTok{  myoldenv <-}\StringTok{ }\KeywordTok{set_a}\NormalTok{(value) }\CommentTok{# sets a to the NEW value and returns the OLD value for storage}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{set_a}\NormalTok{(myoldenv), }\DataTypeTok{add=}\OtherTok{TRUE}\NormalTok{)}
  \KeywordTok{force}\NormalTok{(code)}
\NormalTok{\} }
\end{Highlighting}
\end{Shaded}

The bullet point mentions hashmaps but I'm still really unclear on what that is. What are hash tables and are they related?

They are sort of like fast look-up tables! It may be impossible to show with a small example. To demonstrate that the lookup is fast you'd need to store a lot of stuff in it first. You'd also probably need an alternative implementation of a lookup table to compare it to. We could probably implement a hash table relatively easily* using environments. Demonstrating that using environments is a good way to do it seems difficult.

\begin{itemize}
\tightlist
\item
  looking at a data structures textbook (Cormen, Lieserson \& Rivest), a hash table is expected to provide users with fast functions for insert, search, and delete.
\end{itemize}

\hypertarget{conditions}{%
\chapter{Conditions}\label{conditions}}

\hypertarget{ignoring-conditions}{%
\section*{8.3 Ignoring conditions}\label{ignoring-conditions}}
\addcontentsline{toc}{section}{8.3 Ignoring conditions}

I can't quite think of a time where \texttt{try} is more appropriate than \texttt{tryCatch} - does anyone have an example?

It seems that try is just a wrapper for \texttt{tryCatch} and you can use it whenever you'd use \texttt{try}

When would you actually use \texttt{suppressWarning}? Maybe when loading libraries? I created an example for \texttt{suppressMessages}, but does someone have a better, practical use case?

As a function user, it's common to suppress warnings when loading in data and using \texttt{readr} and \texttt{dplyr} - but not so much as a function creator

\hypertarget{exiting-handlers}{%
\section*{8.4.2 Exiting handlers}\label{exiting-handlers}}
\addcontentsline{toc}{section}{8.4.2 Exiting handlers}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tryCatch}\NormalTok{(}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\StringTok{"There"}\NormalTok{,}
\NormalTok{  \{}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Here"}\NormalTok{)}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"This code is never run!"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{)}
\CommentTok{#> [1] "There"}
\end{Highlighting}
\end{Shaded}

\begin{quote}
The protected code is evaluated in the environment of \texttt{tryCatch()}, but the handler code is not, because the handlers are functions.
\end{quote}

Clarification question what is the ``handler code'' and ``protected code''?

The protected code is inside the \texttt{\{\}} and the handler code is \texttt{message\ =\ function(cnd)\ "There"}

In the tryCatch example where we have \texttt{finally} print ``Thank God for Beer'' I find it interesting that this is printed \textbf{before} the code inside the tryCatch. Can anyone explain why?

From the help it's, ``expression to be evaluated before returning or exiting.'' That means it's the final thing that happens inside the \texttt{tryCatch}, but it happens before the return (of NA or the string), so it happens first.

\hypertarget{calling-handlers}{%
\section*{8.4.3 Calling handlers}\label{calling-handlers}}
\addcontentsline{toc}{section}{8.4.3 Calling handlers}

How would you define bubbling up?

\textbf{Bubbling up:} By default, a condition will continue to propagate to parent handlers, all the way up to the default handler (or an exiting handler, if provided)

I would consider what is being described there ``bubbling up''.

Why is this message executed once per message in the function?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{withCallingHandlers}\NormalTok{(}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{cat}\NormalTok{(}\StringTok{"Caught a message!}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{), }
\NormalTok{  \{}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Someone there?"}\NormalTok{)}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Why, yes!"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> Caught a message!
#> Someone there?
#> Caught a message!
#> Why, yes!
\end{verbatim}

\texttt{withCallingHandlers} could be understood as: ``for each \{message\}, do x''

\begin{quote}
The return value of a calling handler is ignored because the code continues to execute after the handler completes; where would the return value go? That means that calling handlers are only useful for their side-effects.
\end{quote}

Can we come up with an example for this masking? I think seeing it will help me understand\ldots{}

This just means that you cannot capture the return value of your handler (but you sort of can)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  my_lovin <-}\StringTok{ }\OtherTok{NULL}
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) \{my_lovin <<-}\StringTok{ "not this time"}\NormalTok{\},}
\NormalTok{    \{}
\NormalTok{      never_ever_gunna_get_it =}\StringTok{ }\KeywordTok{message}\NormalTok{(}\StringTok{"No, you're never gonna get it"}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{  my_lovin}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## No, you're never gonna get it
\end{verbatim}

\begin{verbatim}
## [1] "not this time"
\end{verbatim}

How does muffling differ from \texttt{suppressWarnings}?

muffling allows for an over-ride/replacement of messages, while suppress just quiets everything:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fn <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{inform}\NormalTok{(}\StringTok{"Beware!"}\NormalTok{, }\StringTok{"my_particular_msg"}\NormalTok{)}
  \KeywordTok{inform}\NormalTok{(}\StringTok{"On your guard!"}\NormalTok{)}
  \StringTok{"foobar"}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now we can use a new definition of \texttt{my\_particular\_msg} to replace ``Beware''

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{with_handlers}\NormalTok{(}\KeywordTok{fn}\NormalTok{(),}
  \DataTypeTok{my_particular_msg =} \KeywordTok{calling}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(cnd) \{}
    \KeywordTok{inform}\NormalTok{(}\StringTok{"Dealt with this particular message"}\NormalTok{)}
    \KeywordTok{cnd_muffle}\NormalTok{(cnd)}
\NormalTok{  \})}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Dealt with this particular message
\end{verbatim}

\begin{verbatim}
## On your guard!
\end{verbatim}

\begin{verbatim}
## [1] "foobar"
\end{verbatim}

whereas suppressMessages just returns foobar:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{suppressMessages}\NormalTok{(}\KeywordTok{fn}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "foobar"
\end{verbatim}

\hypertarget{exercises-4}{%
\section*{8.4.5.2 Exercises}\label{exercises-4}}
\addcontentsline{toc}{section}{8.4.5.2 Exercises}

In the example

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{show_condition <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
  \KeywordTok{tryCatch}\NormalTok{(}
    \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) }\StringTok{"error"}\NormalTok{,}
    \DataTypeTok{warning =} \ControlFlowTok{function}\NormalTok{(cnd) }\StringTok{"warning"}\NormalTok{,}
    \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\StringTok{"message"}\NormalTok{,}
\NormalTok{    \{}
\NormalTok{      code}
      \OtherTok{NULL}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The first three calls to \texttt{show\_condition} make sense to me, and I even understand that the first time the code is evaluated inside a \texttt{tryCatch} it exists (that's why it returns \texttt{message}) but how are you supplying \texttt{3} arguments to a function that just takes on one argument, \texttt{code}? Is that what the \texttt{\{\}} are for?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{show_condition}\NormalTok{(\{}
  \DecValTok{10}
  \KeywordTok{message}\NormalTok{(}\StringTok{"?"}\NormalTok{)}
  \KeywordTok{warning}\NormalTok{(}\StringTok{"?!"}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\texttt{\{\}} let us execute multiple lines of code!

\hypertarget{exercises-5}{%
\section*{8.4.5.3 Exercises}\label{exercises-5}}
\addcontentsline{toc}{section}{8.4.5.3 Exercises}

I couldn't follow the manual's answer for what's happening here, can we come up with our own answer for what's happening here in words?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{withCallingHandlers}\NormalTok{(}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{message}\NormalTok{(}\StringTok{"b"}\NormalTok{),}
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{message}\NormalTok{(}\StringTok{"a"}\NormalTok{),}
    \KeywordTok{message}\NormalTok{(}\StringTok{"c"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## b
\end{verbatim}

\begin{verbatim}
## a
\end{verbatim}

\begin{verbatim}
## b
\end{verbatim}

\begin{verbatim}
## c
\end{verbatim}

The first call to \texttt{withcallinghandlers} adds a condition handler for conditions with class ``message'' to the handler stack (not sure if its actually a stack?) and then executes the second \texttt{withcallinghandlers} which adds another condition handler for conditions with class ``message'' to the handler stack (see above), and then executes the code \texttt{message("c")}.

What happens next is a chain reaction of handlers. The call \texttt{message("c")} is handled by the inner handler, which then calls \texttt{message("a")}, but \texttt{message("a")} is caught by the outer handler, and so it outputs \texttt{b} first.

Then the inner handler resolves itself and outputs \texttt{a} and then that condition (having not been muffled) ``bubbles up'' to the outer handler, which calls \texttt{message("b")} again producing the second \texttt{b} and again since the message wasn't muffled, the original condition \texttt{message("c")} ``bubbles up'' to the top where it is evaluated producing the output \texttt{c}

Another exercise: Guess the output of these two functions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i <-}\StringTok{ }\DecValTok{1}
\KeywordTok{withCallingHandlers}\NormalTok{(}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) \{}\KeywordTok{message}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(i, }\StringTok{". b"}\NormalTok{)); i <<-}\StringTok{ }\NormalTok{i}\OperatorTok{+}\DecValTok{1}\NormalTok{\},}
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) \{}\KeywordTok{message}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(i, }\StringTok{". a"}\NormalTok{)); i <<-}\StringTok{ }\NormalTok{i}\OperatorTok{+}\DecValTok{1}\NormalTok{\},}
\NormalTok{    \{}\KeywordTok{message}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(i, }\StringTok{". c"}\NormalTok{))\}}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 1. b
\end{verbatim}

\begin{verbatim}
## 1. a
\end{verbatim}

\begin{verbatim}
## 3. b
\end{verbatim}

\begin{verbatim}
## 1. c
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i <-}\StringTok{ }\DecValTok{1}
\KeywordTok{withCallingHandlers}\NormalTok{(}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) \{i <<-}\StringTok{ }\NormalTok{i}\OperatorTok{+}\DecValTok{1}\NormalTok{; }\KeywordTok{message}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(i, }\StringTok{". b"}\NormalTok{))\},}
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) \{i <<-}\StringTok{ }\NormalTok{i}\OperatorTok{+}\DecValTok{1}\NormalTok{; }\KeywordTok{message}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(i, }\StringTok{". a"}\NormalTok{))\},}
\NormalTok{    \{}\KeywordTok{message}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(i, }\StringTok{". c"}\NormalTok{))\}}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 3. b
\end{verbatim}

\begin{verbatim}
## 2. a
\end{verbatim}

\begin{verbatim}
## 4. b
\end{verbatim}

\begin{verbatim}
## 1. c
\end{verbatim}

\hypertarget{resignal}{%
\section*{8.6.3 Resignal}\label{resignal}}
\addcontentsline{toc}{section}{8.6.3 Resignal}

Can we go over what is happening here?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{warning2error <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{warning =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{abort}\NormalTok{(}\KeywordTok{conditionMessage}\NormalTok{(cnd)),}
\NormalTok{    expr}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{warning2error}\NormalTok{(\{}
\NormalTok{  x <-}\StringTok{ }\DecValTok{2} \OperatorTok{^}\StringTok{ }\DecValTok{4}
  \KeywordTok{warn}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error: Hello
\end{verbatim}

The function \texttt{warning2error} captures an expression which is evaluated by \texttt{withCallingHandlers} where you have defined a handler for warning conditions. The handler captures the condition cnd raised by warn which is \texttt{structure(list(message\ =\ "Hello"),\ class\ =\ c("warning",\ "condition")}

The function \texttt{conditionMessage} is an s3 generic which evaluates to \texttt{conditionMessage.condition} which simply accesses \texttt{cnd\$message} this is then the input to abort which raises an error with the message \texttt{"Hello"}

\hypertarget{record}{%
\section*{8.6.4 Record}\label{record}}
\addcontentsline{toc}{section}{8.6.4 Record}

Why are we using \texttt{cnd\_muffle} here?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{catch_cnds <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
\NormalTok{  conds <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{  add_cond <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(cnd) \{}
\NormalTok{    conds <<-}\StringTok{ }\KeywordTok{append}\NormalTok{(conds, }\KeywordTok{list}\NormalTok{(cnd))}
    \KeywordTok{cnd_muffle}\NormalTok{(cnd)}
\NormalTok{  \}}
  
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{message =}\NormalTok{ add_cond,}
    \DataTypeTok{warning =}\NormalTok{ add_cond,}
\NormalTok{    expr}
\NormalTok{  )}
  
\NormalTok{  conds}
\NormalTok{\}}

\KeywordTok{catch_cnds}\NormalTok{(\{}
  \KeywordTok{inform}\NormalTok{(}\StringTok{"a"}\NormalTok{)}
  \KeywordTok{warn}\NormalTok{(}\StringTok{"b"}\NormalTok{)}
  \KeywordTok{inform}\NormalTok{(}\StringTok{"c"}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

If we remove \texttt{cnd\_muffle} we see that \texttt{a}, \texttt{b}, and \texttt{c} are printed to the console prior to getting the \texttt{conds} output.

Would it be possible in the second Record example to create a function that doesn't require us to put the \texttt{abort} statement at the end, just ignoring it? Or because \texttt{abort} is an exiting handler it needs to be last?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{catch_cnds <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
\NormalTok{  conds <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{  add_cond <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(cnd) \{}
\NormalTok{    conds <<-}\StringTok{ }\KeywordTok{append}\NormalTok{(conds, }\KeywordTok{list}\NormalTok{(cnd))}
    \KeywordTok{cnd_muffle}\NormalTok{(cnd)}
\NormalTok{  \}}
  
  \KeywordTok{tryCatch}\NormalTok{(}
    \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
\NormalTok{      conds <<-}\StringTok{ }\KeywordTok{append}\NormalTok{(conds, }\KeywordTok{list}\NormalTok{(cnd))}
\NormalTok{    \},}
    \KeywordTok{withCallingHandlers}\NormalTok{(}
      \DataTypeTok{message =}\NormalTok{ add_cond,}
      \DataTypeTok{warning =}\NormalTok{ add_cond,}
\NormalTok{      expr}
\NormalTok{    )}
\NormalTok{  )}
  
\NormalTok{  conds}
\NormalTok{\}}

\KeywordTok{catch_cnds}\NormalTok{(\{}
  \KeywordTok{abort}\NormalTok{(}\StringTok{"a"}\NormalTok{)}
  \KeywordTok{inform}\NormalTok{(}\StringTok{"b"}\NormalTok{)}
  \KeywordTok{warn}\NormalTok{(}\StringTok{"c"}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

I'm not positive, but I don't think so without mucking around in the C code. You ``can'' using try instead of \texttt{tryCatch}, but I can't think of a way to have it let you try each line in your passed in expression for example

What is \texttt{signal} and what is it doing here?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{log <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(message, }\DataTypeTok{level =} \KeywordTok{c}\NormalTok{(}\StringTok{"info"}\NormalTok{, }\StringTok{"error"}\NormalTok{, }\StringTok{"fatal"}\NormalTok{)) \{}
  \CommentTok{# if we remove match.arg and just use level}
  \CommentTok{# the signal returns infoerrorfatal as a single string}
  \CommentTok{# we need match.arg to find the selected level}
  \CommentTok{# and it defaults to the first if none are selected}
\NormalTok{  level <-}\StringTok{ }\KeywordTok{match.arg}\NormalTok{(level)}
  \KeywordTok{signal}\NormalTok{(message, }\StringTok{"log"}\NormalTok{, }\DataTypeTok{level =}\NormalTok{ level)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Signal is a general function that calls abort, inform or warn. It has the same signature as those functions except for the class argument that is necessary for signal but NULL by default for each of the others

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{signal <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(message, class, ..., .subclass) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{missing}\NormalTok{(.subclass)) \{}
    \KeywordTok{deprecate_subclass}\NormalTok{(.subclass)}
\NormalTok{  \}}
\NormalTok{  message <-}\StringTok{ }\KeywordTok{collapse_cnd_message}\NormalTok{(message)}
\NormalTok{  cnd <-}\StringTok{ }\KeywordTok{cnd}\NormalTok{(class, ..., }\DataTypeTok{message =}\NormalTok{ message)}
  \KeywordTok{cnd_signal}\NormalTok{(cnd)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
If you create a condition object by hand, and signal it with signalCondition(), cnd\_muffle() will not work. Instead you need to call it with a muffle restart defined, like this: \texttt{withRestarts(signalCondition(cond),\ muffle\ =\ function()\ NULL)}
\end{quote}

Where does this code go given the prior example?

We would replace the code \texttt{cnd\_muffle(cnd)}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ignore_log_levels <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr, levels) \{}
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{log =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
      \ControlFlowTok{if}\NormalTok{ (cnd}\OperatorTok{$}\NormalTok{level }\OperatorTok{%in%}\StringTok{ }\NormalTok{levels) \{}
        \CommentTok{# cnd_muffle(cnd)}
        \KeywordTok{withRestarts}\NormalTok{(}\KeywordTok{signalCondition}\NormalTok{(cnd), }\DataTypeTok{muffle =} \ControlFlowTok{function}\NormalTok{() }\OtherTok{NULL}\NormalTok{)}
\NormalTok{      \}}
\NormalTok{    \},}
\NormalTok{    expr}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{record_log}\NormalTok{(}\KeywordTok{ignore_log_levels}\NormalTok{(}\KeywordTok{log}\NormalTok{(}\StringTok{"Hello"}\NormalTok{), }\StringTok{"warning"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[info] "Hello"
\end{verbatim}

\hypertarget{exercises-6}{%
\section*{8.6.6.2 Exercises}\label{exercises-6}}
\addcontentsline{toc}{section}{8.6.6.2 Exercises}

\begin{quote}
Calling handlers are called in the context of the call that signaled the condition. Exiting handlers are called in the context of the call to tryCatch().
\end{quote}

What exactly does this mean? tryCatch evaluates what we were calling the protected code first and calling handlers execute the handling code first? Can we make a simple example?

\begin{itemize}
\tightlist
\item
  \texttt{tryCatch} is a project manager who oversees everything and then personally hands over the end product
\item
  \texttt{withCallingHandlers} writes some procedures/guidelines and assumes everyone has enough information to get their jobs done
\end{itemize}

Comparing:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{g}\NormalTok{()}
\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{h}\NormalTok{()}
\NormalTok{h <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{message}\NormalTok{(}\StringTok{"!"}\NormalTok{)}

\KeywordTok{withCallingHandlers}\NormalTok{(}\KeywordTok{f}\NormalTok{(), }\DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
\NormalTok{  lobstr}\OperatorTok{::}\KeywordTok{cst}\NormalTok{()}
  \KeywordTok{cnd_muffle}\NormalTok{(cnd)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      x
##   1. +-base::withCallingHandlers(...)
##   2. +-global::f()
##   3. | \-global::g()
##   4. |   \-global::h()
##   5. |     \-base::message("!")
##   6. |       +-base::withRestarts(...)
##   7. |       | \-base:::withOneRestart(expr, restarts[[1L]])
##   8. |       |   \-base:::doWithOneRestart(return(expr), restart)
##   9. |       \-base::signalCondition(cond)
##  10. \-(function (cnd) ...
##  11.   \-lobstr::cst()
\end{verbatim}

\texttt{withCallingHandlers} is run to completion before \texttt{f} is called/put onto the stack. While \texttt{f} is in progress, \texttt{g} needs to be called so \texttt{g} is put on top of the stack, then \texttt{h} etc. Eventually they're all completed and taken off the stack (in reverse order). Then the handler \texttt{(function\ (cnd)\ ...} is called

While

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tryCatch}\NormalTok{(}\KeywordTok{f}\NormalTok{(), }\DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) lobstr}\OperatorTok{::}\KeywordTok{cst}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     x
##  1. \-base::tryCatch(f(), message = function(cnd) lobstr::cst())
##  2.   \-base:::tryCatchList(expr, classes, parentenv, handlers)
##  3.     \-base:::tryCatchOne(expr, names, parentenv, handlers[[1L]])
##  4.       \-value[[3L]](cond)
##  5.         \-lobstr::cst()
\end{verbatim}

\texttt{tryCatch} is still on the stack when the handler is called i.e.~value, \texttt{tryCatchOne}, \texttt{tryCatchList} and \texttt{tryCatch} are all still in line to be completed

Calling handlers are called in the context of the call that signaled the condition, in this case,\texttt{f()}. So the message handler returns a value to the environment where \texttt{f()} is a meaningful call. Exiting handlers are called in the context of the call to \texttt{tryCatch()}. The exiting handler returns to an ongoing \texttt{tryCatch()} so it can do whatever it needs to do.

\hypertarget{exercises-7}{%
\section*{8.6.6.4 Exercises}\label{exercises-7}}
\addcontentsline{toc}{section}{8.6.6.4 Exercises}

\begin{quote}
There's no way to break out of the function because we're capturing the interrupt that you'd usually use!
\end{quote}

What does this mean? You can't stop the function if you set an \texttt{interrupt} argument inside a \texttt{tryCatch}?

That's exactly it - this was a warning not to use \texttt{inturrupt} in your functions!

\hypertarget{slides}{%
\section*{Slides}\label{slides}}
\addcontentsline{toc}{section}{Slides}

What environment(s) these restarts are called within, or if that even applies or matters

Note: for this example I set my Environment panel in Rstudio to ``Manual Refresh Only'' (the curly arrow menu) while running this to make sure it wasn't doing anything to confuse me.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{expensive_function <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x,}
                               \CommentTok{# warning print the warning and send us to browser}
                               \DataTypeTok{warning =} \ControlFlowTok{function}\NormalTok{(w) \{ }\KeywordTok{print}\NormalTok{(}\KeywordTok{paste}\NormalTok{(}\StringTok{'warning:'}\NormalTok{, w ));  }\KeywordTok{browser}\NormalTok{() \},}
                               \CommentTok{# error print the error and send us to browser}
                               \DataTypeTok{error=}\ControlFlowTok{function}\NormalTok{(e) \{ }\KeywordTok{print}\NormalTok{(}\KeywordTok{paste}\NormalTok{(}\StringTok{'e:'}\NormalTok{,e )); }\KeywordTok{browser}\NormalTok{()\} ) \{}
  \KeywordTok{print}\NormalTok{(}\KeywordTok{paste}\NormalTok{(}\StringTok{"big expensive step we don't want to repeat for x:"}\NormalTok{,x))}
\NormalTok{  z <-}\StringTok{ }\NormalTok{x  }\CommentTok{# the "expensive operation"}
  \KeywordTok{print}\NormalTok{(}\StringTok{"Main function caller_env:"}\NormalTok{)}
  \KeywordTok{print}\NormalTok{(rlang}\OperatorTok{::}\KeywordTok{caller_env}\NormalTok{())}
  \KeywordTok{print}\NormalTok{(}\StringTok{"Main function current_env:"}\NormalTok{)}
  \KeywordTok{print}\NormalTok{(rlang}\OperatorTok{::}\KeywordTok{current_env}\NormalTok{())}
  \KeywordTok{print}\NormalTok{(}\StringTok{"Main function parent:"}\NormalTok{)}
  \KeywordTok{print}\NormalTok{(rlang}\OperatorTok{::}\KeywordTok{env_parent}\NormalTok{(rlang}\OperatorTok{::}\KeywordTok{current_env}\NormalTok{(), }\DecValTok{1}\NormalTok{))}
  \ControlFlowTok{repeat}
  \CommentTok{# second function on z that isn't expensive but could potentially error}
  \KeywordTok{withRestarts}\NormalTok{(}
    \KeywordTok{withRestarts}\NormalTok{(}
      \KeywordTok{withCallingHandlers}\NormalTok{(}
\NormalTok{        \{}
          \KeywordTok{print}\NormalTok{(}\StringTok{"withCallingHandlers caller_env:"}\NormalTok{)}
          \KeywordTok{print}\NormalTok{(rlang}\OperatorTok{::}\KeywordTok{caller_env}\NormalTok{())}
          \KeywordTok{print}\NormalTok{(}\StringTok{"withCallingHandlers current_env:"}\NormalTok{)}
          \KeywordTok{print}\NormalTok{(rlang}\OperatorTok{::}\KeywordTok{current_env}\NormalTok{())}
          \KeywordTok{print}\NormalTok{(}\StringTok{"withCallingHandlers parent:"}\NormalTok{)}
          \KeywordTok{print}\NormalTok{(rlang}\OperatorTok{::}\KeywordTok{env_parent}\NormalTok{(rlang}\OperatorTok{::}\KeywordTok{current_env}\NormalTok{(), }\DecValTok{1}\NormalTok{))}
          \KeywordTok{print}\NormalTok{(}\KeywordTok{paste}\NormalTok{(}\StringTok{"attempt cheap operation for z:"}\NormalTok{,z))}
          \KeywordTok{return}\NormalTok{(}\KeywordTok{log}\NormalTok{(z))}
\NormalTok{        \},}
        \DataTypeTok{warning =}\NormalTok{ warning,}
        \DataTypeTok{error =}\NormalTok{ error}
\NormalTok{      ),}
      \DataTypeTok{force_positive =} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{        z <<-}\StringTok{ }\OperatorTok{-}\NormalTok{z}
        \KeywordTok{print}\NormalTok{(}\StringTok{"force_positive caller_env:"}\NormalTok{)}
        \KeywordTok{print}\NormalTok{(rlang}\OperatorTok{::}\KeywordTok{caller_env}\NormalTok{())}
        \KeywordTok{print}\NormalTok{(}\StringTok{"force_positive current_env:"}\NormalTok{)}
        \KeywordTok{print}\NormalTok{(rlang}\OperatorTok{::}\KeywordTok{current_env}\NormalTok{())}
        \KeywordTok{print}\NormalTok{(}\StringTok{"force_positive parent:"}\NormalTok{)}
        \KeywordTok{print}\NormalTok{(rlang}\OperatorTok{::}\KeywordTok{env_parent}\NormalTok{(rlang}\OperatorTok{::}\KeywordTok{current_env}\NormalTok{(), }\DecValTok{1}\NormalTok{))}
\NormalTok{      \}}
\NormalTok{    ),}
    \DataTypeTok{set_to_one =} \ControlFlowTok{function}\NormalTok{() \{z <<-}\StringTok{ }\DecValTok{1}\NormalTok{\}}
\NormalTok{  )}
\NormalTok{\}}
\KeywordTok{expensive_function}\NormalTok{(}\OperatorTok{-}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can run it yourself (and then \texttt{invokeRestart("force\_positive")}) to see the results, but to summarize:

\begin{itemize}
\tightlist
\item
  The \texttt{withCallingHandlers} part is executing in exactly the same environment as the function.
\item
  The \texttt{force\_positive} restart is executing in its own new environment.
\item
  The parent of that environment is the execution environment of the main function.
\end{itemize}

The \texttt{caller\_env} for \texttt{force\_positive}, though, is still a bit of a mystery. Some further poking found that its grandparent is the base package's namespace, but I don't grok why. Maybe because it's the \texttt{browser()} environment? Is that a thing?

Are there any default restarts include in base R so that you could \texttt{invokeRestart("XXX")} or is the restart always user defined?

From the warning documentation:

\begin{quote}
While a warning is being processed, a \texttt{muffleWarning} restart is available. If this restart is invoked with \texttt{invokeRestart}, then warning returns immediately.
\end{quote}

We can also use the \texttt{computeRestarts} function which lists all available ``default'' restart functions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{computeRestarts}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[1]]
<restart: abort >
\end{verbatim}

It seems \texttt{computeRestarts()} is able to find \texttt{abort} even without \texttt{\{rlang\}} attached! Which means it surely would be able to find some function from the base packages if one existed. But it does not, so that leads me to believe that they aren't any beyond \texttt{muffleWarning}. it seems, in general, you need to specify a function name for \texttt{invokeRestart()}

Let's revisit my example from the talk: can we build on this to use tidyeval so that the user can write \texttt{beer\_states\ \%\textgreater{}\%\ beer\_mean(state)} {[}I think we need to use \texttt{.data} and note how state is given as an object so we need to use tidyeval to suppress it's evaluation\ldots{}{]}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{beer_states <-}\StringTok{ }\NormalTok{readr}\OperatorTok{::}\KeywordTok{read_csv}\NormalTok{(}
  \StringTok{'https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-03-31/beer_states.csv'}\NormalTok{)}

\NormalTok{beer_mean <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(.data, x) \{}
  
\NormalTok{  column_name <-}\StringTok{ }\KeywordTok{deparse}\NormalTok{(}\KeywordTok{substitute}\NormalTok{(x))}

\NormalTok{  msg <-}\StringTok{ }\NormalTok{glue}\OperatorTok{::}\KeywordTok{glue}\NormalTok{(}\StringTok{"Can't calculate mean, \{column_name\} is not numeric"}\NormalTok{)}
  
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.numeric}\NormalTok{(.data[[column_name]])) \{}
    \KeywordTok{abort}\NormalTok{(}
      \DataTypeTok{message =}\NormalTok{ msg,}
      \DataTypeTok{arg =}\NormalTok{ column_name,}
      \DataTypeTok{data =}\NormalTok{ .data}
\NormalTok{    )}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \KeywordTok{mean}\NormalTok{(}\KeywordTok{which}\NormalTok{(}\OperatorTok{!}\KeywordTok{is.na}\NormalTok{(.data[[column_name]])[.data[[column_name]]]))}
\NormalTok{  \}}
\NormalTok{\}}

\NormalTok{beer_states }\OperatorTok{%>%}\StringTok{ }\KeywordTok{beer_mean}\NormalTok{(barrels)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 806.4551
\end{verbatim}

\hypertarget{functionals}{%
\chapter{Functionals}\label{functionals}}

\hypertarget{anonymous-functions-and-shortcuts}{%
\section*{9.2.2 Anonymous functions and shortcuts}\label{anonymous-functions-and-shortcuts}}
\addcontentsline{toc}{section}{9.2.2 Anonymous functions and shortcuts}

We saw you'll get an error if you try to map over elements that don't exist, and can use \texttt{.default} to override that. Is this related to \texttt{tryCatch} in some way? Can we look at the \texttt{map} source code for \texttt{.default?} And how would we overcome this error if we were to use base R's \texttt{lapply(x,\ \textquotesingle{}two\textquotesingle{})}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \KeywordTok{list}\NormalTok{(}\DataTypeTok{one =} \StringTok{"a"}\NormalTok{),}
  \KeywordTok{list}\NormalTok{(}\DataTypeTok{one =} \StringTok{"b"}\NormalTok{),}
  \KeywordTok{list}\NormalTok{(}\DataTypeTok{one =} \StringTok{"c"}\NormalTok{)}
\NormalTok{)}

\KeywordTok{map_chr}\NormalTok{(x, }\StringTok{'two'}\NormalTok{, }\DataTypeTok{.default =} \OtherTok{NA}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA NA NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(x, }\StringTok{'two'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in get(as.character(FUN), mode = "function", envir = envir) : object 'two' of mode 'function' was not found
\end{verbatim}

Within \texttt{purrr} \href{https://github.com/tidyverse/purrr/blob/7104367bb6599f13e56c554bd07488b508a8a02b/R/as_mapper.R\#L98}{there's the function}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{find_extract_default <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(.null, .default) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{missing}\NormalTok{(.null)) \{}
\NormalTok{    .null}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    .default}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

So it doesn't seem to be a conditional, but rather a way to deal with missing errors

XXX

\hypertarget{exercise-8}{%
\section*{9.2.6.4 Exercise}\label{exercise-8}}
\addcontentsline{toc}{section}{9.2.6.4 Exercise}

In order to extract p-values the solution manual suggests using \texttt{map\_dbl} but could we use \texttt{pluck} to get these values? If so how?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trials <-}\StringTok{ }\KeywordTok{map}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{, }\OperatorTok{~}\StringTok{ }\KeywordTok{t.test}\NormalTok{(}\KeywordTok{rpois}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{10}\NormalTok{), }\KeywordTok{rpois}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{7}\NormalTok{)))}
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{p_value =} \KeywordTok{map_dbl}\NormalTok{(trials, }\StringTok{"p.value"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 100 x 1
##      p_value
##        <dbl>
##  1 0.195    
##  2 0.0641   
##  3 0.317    
##  4 0.000220 
##  5 0.0000686
##  6 0.000908 
##  7 0.0214   
##  8 0.0799   
##  9 0.153    
## 10 0.0133   
## # ... with 90 more rows
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pluck}\NormalTok{(trials, }\StringTok{"p.value"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercise-9}{%
\section*{9.2.6.5 Exercise}\label{exercise-9}}
\addcontentsline{toc}{section}{9.2.6.5 Exercise}

Can we make this work?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{9}\NormalTok{)),}
  \KeywordTok{list}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{6}\NormalTok{), }\DecValTok{7}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{))}
\NormalTok{)}

\NormalTok{triple <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{*}\StringTok{ }\DecValTok{3}
\KeywordTok{map}\NormalTok{(x, map, }\DataTypeTok{.f =}\NormalTok{ triple)}
\end{Highlighting}
\end{Shaded}

XXX

\hypertarget{same-type-of-output-as-input-modify}{%
\section*{\texorpdfstring{9.4.1 Same type of output as input: \texttt{modify()}}{9.4.1 Same type of output as input: modify()}}\label{same-type-of-output-as-input-modify}}
\addcontentsline{toc}{section}{9.4.1 Same type of output as input: \texttt{modify()}}

When using modify we now get the warning:\texttt{Warning\ message:}modify()\texttt{is\ deprecated\ as\ of\ rlang\ 0.4.0.\ Vector\ tools\ are\ now\ out\ of\ scope\ for\ rlang\ to\ make\ it\ a\ more\ focused\ package.}

How should we rewrite this example?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{,}
  \DataTypeTok{y =} \DecValTok{6}\OperatorTok{:}\DecValTok{4}
\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{modify}\NormalTok{( }\OperatorTok{~}\StringTok{ }\NormalTok{.x }\OperatorTok{*}\StringTok{ }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

:::

XXX

\hypertarget{any-number-of-inputs-pmap-and-friends}{%
\section*{9.4.5 Any number of inputs: pmap() and friends}\label{any-number-of-inputs-pmap-and-friends}}
\addcontentsline{toc}{section}{9.4.5 Any number of inputs: pmap() and friends}

I want to use pmap to map over a vector, but the metadata for the functions other arguments is elsewhere - how would I combine these using \texttt{pmap}? The book says to name the metadata columns the same name as your function which I did but this still doesn't work?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_data <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{3}

\NormalTok{metadata <-}\StringTok{ }\KeywordTok{tribble}\NormalTok{(}
  \OperatorTok{~}\NormalTok{id, }\OperatorTok{~}\NormalTok{mult, }\OperatorTok{~}\NormalTok{adder,}
  \StringTok{"one"}\NormalTok{,   }\DecValTok{2}\NormalTok{,      }\DecValTok{5}\NormalTok{,}
  \StringTok{"two"}\NormalTok{,   }\DecValTok{3}\NormalTok{,      }\DecValTok{6}\NormalTok{,}
  \StringTok{"three"}\NormalTok{, }\DecValTok{4}\NormalTok{,      }\DecValTok{7}
\NormalTok{)}

\NormalTok{the_function <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(vec, id, mult, adder) \{}
\NormalTok{  glue}\OperatorTok{::}\KeywordTok{glue}\NormalTok{(}\StringTok{"\{id\} is now \{vec * mult + adder\}"}\NormalTok{)}
\NormalTok{\}}

\CommentTok{# my_data doesn't change but we want to map over the metadata}
\CommentTok{# x = string}
\CommentTok{# y = multiplier}
\CommentTok{# z = adder}
\KeywordTok{pmap}\NormalTok{(}\KeywordTok{list}\NormalTok{(metadata), }\OperatorTok{~}\KeywordTok{the_function}\NormalTok{(}\DataTypeTok{vec =}\NormalTok{ my_data))}
\end{Highlighting}
\end{Shaded}

XXX

\hypertarget{exercise-10}{%
\section*{9.4.6.2 Exercise}\label{exercise-10}}
\addcontentsline{toc}{section}{9.4.6.2 Exercise}

I see how we can use \texttt{iwalk} and \texttt{walk2} for writing to multiple files, but the question asks about disadvantages to this - what would they be?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cyls <-}\StringTok{ }\KeywordTok{split}\NormalTok{(mtcars, mtcars}\OperatorTok{$}\NormalTok{cyl)}
\NormalTok{paths <-}\StringTok{ }\KeywordTok{file.path}\NormalTok{(temp, }\KeywordTok{paste0}\NormalTok{(}\StringTok{"cyl-"}\NormalTok{, }\KeywordTok{names}\NormalTok{(cyls), }\StringTok{".csv"}\NormalTok{))}
\KeywordTok{walk2}\NormalTok{(cyls, paths, write.csv)}

\NormalTok{mtcars }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{split}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{cyl) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{set_names}\NormalTok{(}\OperatorTok{~}\StringTok{ }\KeywordTok{file.path}\NormalTok{(temp, }\KeywordTok{paste0}\NormalTok{(}\StringTok{"cyl-"}\NormalTok{, .x, }\StringTok{".csv"}\NormalTok{))) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{iwalk}\NormalTok{(}\OperatorTok{~}\StringTok{ }\KeywordTok{write.csv}\NormalTok{(.x, .y))}
\end{Highlighting}
\end{Shaded}

\hypertarget{multiple-inputs}{%
\section*{9.5.4 Multiple inputs}\label{multiple-inputs}}
\addcontentsline{toc}{section}{9.5.4 Multiple inputs}

Can we think of a simple example for \texttt{reduce2()}? I was playing with \texttt{accumulate(c(FALSE,\ FALSE,\ TRUE),}\textbar{}\texttt{)}, maybe we can combine this with something?

XXX

\hypertarget{map-reduce}{%
\section*{9.5.5 Map-reduce}\label{map-reduce}}
\addcontentsline{toc}{section}{9.5.5 Map-reduce}

I like the books Hadoop simple example - can we come up with one with code or is it solely for computing on multiple machines?

XXX

\hypertarget{exercise-11}{%
\section*{9.6.3.2 Exercise}\label{exercise-11}}
\addcontentsline{toc}{section}{9.6.3.2 Exercise}

I understand that \texttt{if\ (length(x)\ ==\ 1L)\ return(x{[}{[}1L{]}{]})} covers the case like \texttt{simple\_reduce(1,\ +)} but what's the deal with \texttt{if\ (length(x)\ ==\ 0L)\ return(default)} and what exactly is \texttt{default}?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simple_reduce <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, f, default) \{}
  \CommentTok{# when would you use reduce on something length 0?}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(x) }\OperatorTok{==}\StringTok{ }\NormalTok{0L) }\KeywordTok{return}\NormalTok{(default)}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(x) }\OperatorTok{==}\StringTok{ }\NormalTok{1L) }\KeywordTok{return}\NormalTok{(x[[1L]])}

\NormalTok{  out <-}\StringTok{ }\NormalTok{x[[}\DecValTok{1}\NormalTok{]]}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{, }\KeywordTok{length}\NormalTok{(x))) \{}
\NormalTok{    out <-}\StringTok{ }\KeywordTok{f}\NormalTok{(out, x[[i]])}
\NormalTok{  \}}
\NormalTok{  out}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Default is the user supplied second number to add by, and we can use \texttt{integer(0)} to work with a \texttt{length(0)} vector.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{simple_reduce}\NormalTok{(}\KeywordTok{integer}\NormalTok{(}\DecValTok{0}\NormalTok{), }\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{, }\DataTypeTok{default =}\NormalTok{ 0L)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0
\end{verbatim}

I guess I understand this but when would you want to perform a reduce on something of length zero?

XXX

\hypertarget{matrices-and-arrays}{%
\section*{9.7.1 Matrices and arrays}\label{matrices-and-arrays}}
\addcontentsline{toc}{section}{9.7.1 Matrices and arrays}

How would you tidyverse the \texttt{rowSums} function?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{tribble}\NormalTok{(}
  \OperatorTok{~}\NormalTok{x, }\OperatorTok{~}\NormalTok{y,}
  \DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{,}
  \DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{,}
  \DecValTok{3}\NormalTok{, }\DecValTok{3}
\NormalTok{)}

\KeywordTok{apply}\NormalTok{(x, }\DecValTok{1}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sum}\NormalTok{(x}\OperatorTok{>}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0 0 2
\end{verbatim}

XXX

I'm not quite sure what idempotent means but Hadley warns that \texttt{a2d} and \texttt{a1} aren't the same, but isn't that just because we're using \texttt{1} which is row wise, and not \texttt{2}? What is the warning he is heeding us against here?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a2d <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{)}
\NormalTok{a1 <-}\StringTok{ }\KeywordTok{apply}\NormalTok{(a2d, }\DecValTok{1}\NormalTok{, identity)}
\KeywordTok{identical}\NormalTok{(a2d, a1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\hypertarget{exercise-12}{%
\section*{9.7.3.2 Exercise}\label{exercise-12}}
\addcontentsline{toc}{section}{9.7.3.2 Exercise}

What's an example of using \texttt{eapply} (iterates over the (named) elements of an environment)?

Can we come up with an example for \texttt{rapply} allowing us to apply a function to only a specified class? Does something like this exist within \texttt{purrr}?

\hypertarget{exercise-13}{%
\section*{9.7.3.3 Exercise}\label{exercise-13}}
\addcontentsline{toc}{section}{9.7.3.3 Exercise}

What exactly is the \href{https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-12.html\#\%25_idx_1096}{Fixed Point Algrithm} and can we go over the books answer?

The fixed point theory is the specific scenario in which \texttt{x\ =\ g(x)}, meaning the functions input is equal to the function's output.

We are creating a function that can be used to find where \texttt{x\ =\ g(x)}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fixed_point <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f, x_init, }\DataTypeTok{n_max =} \DecValTok{10000}\NormalTok{, }\DataTypeTok{tol =} \FloatTok{0.0001}\NormalTok{) \{}
\NormalTok{  n <-}\StringTok{ }\DecValTok{0}
\NormalTok{  x <-}\StringTok{ }\NormalTok{x_init}
\NormalTok{  y <-}\StringTok{ }\KeywordTok{f}\NormalTok{(x)}

\NormalTok{  is_fixed_point <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) \{}
    \KeywordTok{abs}\NormalTok{(x }\OperatorTok{-}\StringTok{ }\NormalTok{y) }\OperatorTok{<}\StringTok{ }\NormalTok{tol}
\NormalTok{  \}}

  \ControlFlowTok{while}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is_fixed_point}\NormalTok{(x, y)) \{}
\NormalTok{    x <-}\StringTok{ }\NormalTok{y}
\NormalTok{    y <-}\StringTok{ }\KeywordTok{f}\NormalTok{(y)}

    \CommentTok{# Make sure we eventually stop}
\NormalTok{    n <-}\StringTok{ }\NormalTok{n }\OperatorTok{+}\StringTok{ }\DecValTok{1}
    \ControlFlowTok{if}\NormalTok{ (n }\OperatorTok{>}\StringTok{ }\NormalTok{n_max) \{}
      \KeywordTok{stop}\NormalTok{(}\StringTok{"Failed to converge"}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  \}}

\NormalTok{  x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Functions with fixed points:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fixed_point}\NormalTok{(sin, }\DataTypeTok{x_init =} \DecValTok{1}\NormalTok{)}
\KeywordTok{fixed_point}\NormalTok{(cos, }\DataTypeTok{x_init =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Functions without fixed points}
\NormalTok{add_one <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\KeywordTok{fixed_point}\NormalTok{(add_one, }\DataTypeTok{x_init =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> Error: Failed to converge
\end{verbatim}

\bibliography{book.bib,packages.bib}

\end{document}
