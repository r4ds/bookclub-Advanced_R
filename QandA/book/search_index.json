[
["functions.html", "Chapter 6 Functions 6.2.2 Primitives 6.2.5.1 Exercises 6.4 Lexical scoping 6.4.3 A fresh start 6.5 Dynamic lookup 6.5 Lazy evaluation 6.5.1 Promises 6.5.2 Default arguments Missing arguments 6.5.4.3 Exercise 6.5.4.4 Exercise 6.6 dot dot dot 6.6.1.2 Exercise 6.7.4 Exit handlers 6.7.5.4 Exercise 6.7.5.5 Exercise 6.8.4 Replacement functions 6.8.6.3 Exercise", " Chapter 6 Functions 6.2.2 Primitives So if you are familiar with C can you just write a function in C in R? What does that process look like? I think this is a bigger question of digging into the relationship between C and R. XXX 6.2.5.1 Exercises This question is flagged as “started” let’s try to complete it! Q: Given a name, like &quot;mean&quot;, match.fun() lets you find a function. Given a function, can you find its name? Why doesn’t that make sense in R? A: A name can only point to a single object, but an object can be pointed to by 0, 1, or many names. What are names of the functions in the following block? function(x) sd(x) / mean(x) ## function(x) sd(x) / mean(x) f1 &lt;- function(x) (x - min(x)) / (max(x) - min(x)) f2 &lt;- f1 f3 &lt;- f1 XXX 6.4 Lexical scoping “The scoping rules use a parse-time, rather than a run-time structure”? What is “parse-time” and “run-time”? How do they differ? XXX 6.4.3 A fresh start How would we change this code so that the second call of g11() is 2? g11 &lt;- function() { if (!exists(&quot;a&quot;)) { a &lt;- 1 } else { a &lt;- a + 1 } a } g11() ## [1] 1 g11() ## [1] 1 XXX 6.5 Dynamic lookup R looks for values when the function is run, not when the function is created - does anyone know if this is the case for Shiny modules? XXX 6.5 Lazy evaluation “This allows you to do things like include potentially expensive computations in function arguments that will only be evaluated if needed” Does anyone have an example of this? XXX 6.5.1 Promises Can we discuss the order that this happening in? Is it that Calculating... is printed, then x*2 then x*2 again? I am still reading this as: h03(double(20), double(20)) which is an incorrect mental model because the message is only printed once… double &lt;- function(x) { message(&quot;Calculating...&quot;) x * 2 } h03 &lt;- function(x) { c(x, x) } h03(double(20)) ## Calculating... ## [1] 40 40 XXX 6.5.2 Default arguments I don’t quite understand why x = ls() is different from ls() here; aren’t we still assigning x = ls() but without specifying x? h05 &lt;- function(x = ls()) { a &lt;- 1 x } # this makes sense to me h05() ## [1] &quot;a&quot; &quot;x&quot; # how is this different from above? h05(ls()) ## [1] &quot;double&quot; &quot;f1&quot; &quot;f2&quot; &quot;f3&quot; &quot;g11&quot; &quot;h03&quot; &quot;h05&quot; I think this ties exercise 6.5.4.4 show_time &lt;- function(x = stop(&quot;Error!&quot;)) { stop &lt;- function(...) Sys.time() print(x) } show_time() ## [1] &quot;2020-05-02 10:56:30 PDT&quot; show_time(x = stop(&quot;Error!&quot;)) Error in print(x) : Error! XXX Missing arguments Comparing the default sample function: sample &lt;- function (x, size, replace = FALSE, prob = NULL) { if (length(x) == 1L &amp;&amp; is.numeric(x) &amp;&amp; is.finite(x) &amp;&amp; x &gt;= 1) { if (missing(size)) # if you don&#39;t supply the sample size # you will just get random samples # the length of the supplied vector size &lt;- x sample.int(x, size, replace, prob) } else { if (missing(size)) size &lt;- length(x) x[sample.int(length(x), size, replace, prob)] } } sample(1:10) ## [1] 8 2 7 10 3 1 5 6 4 9 To using Hadley’s reccomended NULL version: my_sample_null &lt;- function(x, size = NULL, replace = FALSE, prob = NULL) { size &lt;- size %||% length(x) x[sample.int(length(x), size, replace = replace, prob = prob)] } my_sample_null(1:10) ## [1] 6 1 5 8 7 9 10 4 2 3 The second function is obviously more concise, but why is Hadley reccomending we we steer clear of missing()? Is this just for code read-ability or is there something inherent in the behvior of missing we need to consider that we don’t when using NULL? XXX 6.5.4.3 Exercise I understand this problem is showing us an example of name masking (the function doesn’t need to use the y = 0 argument because it gets y from within the definition of x, but I’m fuzzy on what exactly the ; does. What does the syntax {y &lt;- 1; 2} mean? Could it be read as &quot;Set y &lt;- 1 and x &lt;- 2? y &lt;- 10 f1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) { c(x, y) } f1() ## [1] 2 1 6.5.4.4 Exercise I know this isn’t exactly needed to answer the question but how do we access a function that has methods? For instance - here I want to dig into the hist function but hist ## function (x, ...) ## UseMethod(&quot;hist&quot;) ## &lt;bytecode: 0x7fbee68fce00&gt; ## &lt;environment: namespace:graphics&gt; does not give me the actual contents of the actual function…. XXX 6.6 dot dot dot “(See also rlang::list2() to support splicing and to silently ignore trailing commas, and rlang::enquos() to capture unevaluated arguments, the topic of quasiquotation.)” I know we have a chapter on tidyeval coming up, but can we come up with a simple use case for list2 here? XXX “lapply() uses … to pass na.rm on to mean()” Um how? x &lt;- list(c(1, 3, NA), c(4, NA, 6)) str(lapply(x, mean, na.rm = TRUE)) ## List of 2 ## $ : num 2 ## $ : num 5 XXX 6.6.1.2 Exercise I tried running browser(plot(1:10, col = &quot;red&quot;)) to peek under the hood but only got Called from: top level in the console. What am I missing? XXX 6.7.4 Exit handlers “Always set add = TRUE when using on.exit() If you don’t, each call to on.exit() will overwrite the previous exit handler.” Can we come up with an example for not using add = TRUE and how it results in unwanted behavior? j06 &lt;- function(x) { cat(&quot;Hello\\n&quot;) on.exit(cat(&quot;Goodbye!\\n&quot;)) if (x) { return(10) } else { stop(&quot;Error&quot;) } } j06(TRUE) ## Hello ## Goodbye! ## [1] 10 j06(TRUE) ## Hello ## Goodbye! ## [1] 10 j08 &lt;- function() { on.exit(message(&quot;a&quot;)) on.exit(message(&quot;b&quot;), add=TRUE) } j08() ## a ## b add = TRUE is important when you have more than one on.exit function! Can we go over this code? How does it not change your working directory after you run the function cleanup &lt;- function(dir, code) { old_dir &lt;- setwd(dir) on.exit(setwd(old_dir), add = TRUE) old_opt &lt;- options(stringsAsFactors = FALSE) # what&#39;s happening here? on.exit(options(old_opt), add = TRUE) } # what is this output cleanup(&quot;~&quot;) # how is it different from this? getwd() ## [1] &quot;/Users/mayagans/Documents/bookclub-Advanced_R/QandA&quot; XXX 6.7.5.4 Exercise This question is flagged as “started” let’s try to complete it! Hadley comments in the repo: “I think I’m more intersted in supplying a path vs. a logical value here”. Q: How does the chdir parameter of source() compare to in_dir()? Why might you prefer one approach to the other? The in_dir() approach was given in the book as ```r in_dir &lt;- function(dir, code) { old &lt;- setwd(dir) on.exit(setwd(old)) force(code) } ``` A: in_dir() takes a path to a working directory as an argument. First the working directory is changed accordingly. on.exit() ensures that the modification to the working directory are reset to the initial value when the function exits. In source() the chdir argument specifies if the working directory should be changed during the evaluation of the file argument (which in this case has to be a pathname). XXX 6.7.5.5 Exercise Can we go over the source code of capture.output and capture.output2? body(capture.output) ## { ## args &lt;- substitute(list(...))[-1L] ## type &lt;- match.arg(type) ## rval &lt;- NULL ## closeit &lt;- TRUE ## if (is.null(file)) ## file &lt;- textConnection(&quot;rval&quot;, &quot;w&quot;, local = TRUE) ## else if (is.character(file)) ## file &lt;- file(file, if (append) ## &quot;a&quot; ## else &quot;w&quot;) ## else if (inherits(file, &quot;connection&quot;)) { ## if (!isOpen(file)) ## open(file, if (append) ## &quot;a&quot; ## else &quot;w&quot;) ## else closeit &lt;- FALSE ## } ## else stop(&quot;&#39;file&#39; must be NULL, a character string or a connection&quot;) ## sink(file, type = type, split = split) ## on.exit({ ## sink(type = type, split = split) ## if (closeit) close(file) ## }) ## pf &lt;- parent.frame() ## evalVis &lt;- function(expr) withVisible(eval(expr, pf)) ## for (i in seq_along(args)) { ## expr &lt;- args[[i]] ## tmp &lt;- switch(mode(expr), expression = lapply(expr, evalVis), ## call = , name = list(evalVis(expr)), stop(&quot;bad argument&quot;)) ## for (item in tmp) if (item$visible) ## print(item$value) ## } ## on.exit() ## sink(type = type, split = split) ## if (closeit) ## close(file) ## if (is.null(rval)) ## invisible(NULL) ## else rval ## } capture.output2 &lt;- function(code) { temp &lt;- tempfile() on.exit(file.remove(temp), add = TRUE) sink(temp) on.exit(sink(), add = TRUE) force(code) readLines(temp) } identical( capture.output(cat(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;\\n&quot;)), capture.output2(cat(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;\\n&quot;)) ) ## [1] TRUE XXX 6.8.4 Replacement functions Can we go over the translation for x &lt;- c(a = 1, b = 2, c = 3) names(x) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; names(x)[2] &lt;- &quot;two&quot; names(x) ## [1] &quot;a&quot; &quot;two&quot; &quot;c&quot; Being equal to `*tmp*` &lt;- x x &lt;- `names&lt;-`(`*tmp*`, `[&lt;-`(names(`*tmp*`), 2, &quot;two&quot;)) rm(`*tmp*`) XXX 6.8.6.3 Exercise This question is flagged as “started” let’s try to complete it! Q: Explain why the following code fails: ```r modify(get(&quot;x&quot;), 1) &lt;- 10 #&gt; Error: target of assignment expands to non-language object ``` A: First, let’s define x and recall the definition of modify() from the textbook: ```r x &lt;- 1:3 `modify&lt;-` &lt;- function(x, position, value) { x[position] &lt;- value x } ``` XXX "]
]
