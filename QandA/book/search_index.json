[
["functions.html", "Chapter 6 Functions 6.2.2 Primitives 6.2.5.1 Exercises 6.4 Lexical scoping 6.4.3 A fresh start 6.5 Lazy evaluation 6.5.1 Promises 6.5.2 Default arguments 6.5.4.3 Exercise 6.5.4.4 Exercise 6.6 dot dot dot 6.6.1.2 Exercise 6.7.4 Exit handlers 6.7.5.4 Exercise 6.7.5.5 Exercise 6.8.4 Replacement functions 6.8.6.3 Exercise", " Chapter 6 Functions 6.2.2 Primitives So if you are familiar with C can you just write a function in C in R? What does that process look like? I think this is a bigger question of digging into the relationship between C and R. I think we cover this in Chapter 25! 6.2.5.1 Exercises This question is flagged as “started” let’s try to complete it! Q: Given a name, like &quot;mean&quot;, match.fun() lets you find a function. Given a function, can you find its name? Why doesn’t that make sense in R? A: A name can only point to a single object, but an object can be pointed to by 0, 1, or many names. What are names of the functions in the following block? function(x) sd(x) / mean(x) ## function(x) sd(x) / mean(x) f1 &lt;- function(x) (x - min(x)) / (max(x) - min(x)) f2 &lt;- f1 f3 &lt;- f1 XXX 6.4 Lexical scoping “The scoping rules use a parse-time, rather than a run-time structure”? What is “parse-time” and “run-time”? How do they differ? The function is run at parse-time, meaning it is only run when it is called. 6.4.3 A fresh start How would we change this code so that the second call of g11() is 2? g11 &lt;- function() { if (!exists(&quot;a&quot;)) { a &lt;- 1 } else { a &lt;- a + 1 } a } g11() ## [1] 1 g11 &lt;- function() { if (!exists(&quot;a&quot;)) { a &lt;- 1 } else { a &lt;- a + 1 } a &lt;&lt;- a a } g11() ## [1] 1 6.5 Lazy evaluation “This allows you to do things like include potentially expensive computations in function arguments that will only be evaluated if needed” Does anyone have an example of this? We discussed a function that will only perform expensive tasks given the context of the function perhaps? Maybe a situation where we can give a function default arguments where sampleis a stand in for longer expensive functions like different fancy modeling techniques? We can workshop this… mega_model &lt;- function(values, x = sample(1:100, 10), y = sample(200:300, 10), z = sample(300:400, 10) ) { dplyr::case_when( is.numeric(values) ~ x, is.character(values) ~ y, TRUE ~ z ) } mega_model(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## [1] 284 237 235 216 203 290 232 251 204 250 6.5.1 Promises Can we discuss the order that this happening in? Is it that Calculating... is printed, then x*2 then x*2 again? I am still reading this as: h03(double(20), double(20)) which is an incorrect mental model because the message is only printed once… double &lt;- function(x) { message(&quot;Calculating...&quot;) x * 2 } h03 &lt;- function(x) { c(x, x) } double &lt;- function(y) { message(&quot;Calculating...&quot;) cat(&quot;double before\\n&quot;) print(pryr::promise_info(y)) force(y) cat(&quot;double after\\n&quot;) print(pryr::promise_info(y)) y * 2 } h03 &lt;- function(x) { cat(paste0(&quot;h03 before\\n&quot;)) print(pryr::promise_info(x)) force(x) cat(&quot;h03 after\\n&quot;) print(pryr::promise_info(x)) c(x, x) } double(h03(20)) ## Calculating... ## double before ## Registered S3 method overwritten by &#39;pryr&#39;: ## method from ## print.bytes Rcpp ## $code ## h03(20) ## ## $env ## &lt;environment: R_GlobalEnv&gt; ## ## $evaled ## [1] FALSE ## ## $value ## NULL ## ## h03 before ## $code ## [1] 20 ## ## $env ## &lt;environment: R_GlobalEnv&gt; ## ## $evaled ## [1] FALSE ## ## $value ## NULL ## ## h03 after ## $code ## [1] 20 ## ## $env ## NULL ## ## $evaled ## [1] TRUE ## ## $value ## [1] 20 ## ## double after ## $code ## h03(20) ## ## $env ## NULL ## ## $evaled ## [1] TRUE ## ## $value ## [1] 20 20 ## [1] 40 40 f &lt;- function(x, y) x + 2 f(2, var_doesnt_exist) ## [1] 4 var_doesnt_exist is a promise within g, we use the promises within g when we call f but f never uses its second argument so this runs without a problem. When would we want to leverage this behavior? 6.5.2 Default arguments I don’t quite understand why x = ls() is different from ls() here; aren’t we still assigning x = ls() but without specifying x? h05 &lt;- function(x = ls()) { a &lt;- 1 x } # this makes sense to me h05() ## [1] &quot;a&quot; &quot;x&quot; # how is this different from above? h05(ls()) ## [1] &quot;a&quot; &quot;double&quot; &quot;f&quot; &quot;f1&quot; &quot;f2&quot; ## [6] &quot;f3&quot; &quot;g11&quot; &quot;h03&quot; &quot;h05&quot; &quot;mega_model&quot; XXX 6.5.4.3 Exercise I understand this problem is showing us an example of name masking (the function doesn’t need to use the y = 0 argument because it gets y from within the definition of x, but I’m fuzzy on what exactly the ; does. What does the syntax {y &lt;- 1; 2} mean? Could it be read as &quot;Set y &lt;- 1 and x &lt;- 2? y &lt;- 10 f1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) { c(x, y) } f1() ## [1] 2 1 The curly brackets are an expression, which can be read as { y &lt;- 1 2 } ## [1] 2 This is returning 2 and setting 1 to y. The colon can be read as a new line in the expression. x is called inside the function and overwrites the argument value of y 6.5.4.4 Exercise I know this isn’t exactly needed to answer the question, but how do we access a function that has methods? For instance - here I want to dig into the hist function using hist hist ## function (x, ...) ## UseMethod(&quot;hist&quot;) ## &lt;bytecode: 0x7fd80c212800&gt; ## &lt;environment: namespace:graphics&gt; does not give me the actual contents of the actual function…. We need to access is using hist.&lt;method&gt; hist.default 6.6 dot dot dot “(See also rlang::list2() to support splicing and to silently ignore trailing commas…” Can we come up with a simple use case for list2 here? The docs use list2(a = 1, a = 2, b = 3, b = 4, 5, 6) but how is this different from list? identical( rlang::list2(a = 1, a = 2, b = 3, b = 4, 5, 6) , list(a = 1, a = 2, b = 3, b = 4, 5, 6) ) ## [1] TRUE XXX “lapply() uses ... to pass na.rm on to mean()” Um, how? x &lt;- list(c(1, 3, NA), c(4, NA, 6)) str(lapply(x, mean, na.rm = TRUE)) ## List of 2 ## $ : num 2 ## $ : num 5 An lapply takes on two main arguments: what you want to loop over and the function to apply to each element. By including ... lapply allows you to supply additional arguments which will be passed to the function inside the lapply. In this case, na.rm = TRUE is being applied to mean every time it’s being called in the loop. 6.6.1.2 Exercise I tried running browser(plot(1:10, col = &quot;red&quot;)) to peek under the hood but only got Called from: top level in the console. What am I missing? We can use debugonce! debugonce(plot()) 6.7.4 Exit handlers “Always set add = TRUE when using on.exit() If you don’t, each call to on.exit() will overwrite the previous exit handler.” What does this mean? add = TRUE is important when you have more than one on.exit function! j08 &lt;- function() { on.exit(message(&quot;a&quot;)) on.exit(message(&quot;b&quot;), add=TRUE) } j08() ## a ## b Can we go over this code? How does it not change your working directory after you run the function cleanup &lt;- function(dir, code) { old_dir &lt;- setwd(dir) on.exit(setwd(old_dir), add = TRUE) old_opt &lt;- options(stringsAsFactors = FALSE) on.exit(options(old_opt), add = TRUE) } cleanup(&quot;~&quot;) getwd() ## [1] &quot;/Users/mayagans/Documents/bookclub-Advanced_R/QandA&quot; The behavior of setwd “changing the working directory” is actually a side effect of the function - it invisibly returns the previous working directory as the value of the function (potentially for the exact purpose demonstrated). If on.exit fails will it continue onto the next on.exit so long as add == TRUE ?``on.exit fails it’ll caontinue onto the next one f &lt;- function() { on.exit(stop(&quot;Error&quot;)) on.exit(message(&quot;yay, still called.&quot;), add = TRUE) } f() Error in f() : Error yay, still called. 6.7.5.4 Exercise This question is flagged as “started” let’s try to complete it! Hadley comments in the repo: “I think I’m more interested in supplying a path vs. a logical value here”. Q: How does the chdir parameter of source() compare to in_dir()? Why might you prefer one approach to the other? The in_dir() approach was given in the book as in_dir &lt;- function(dir, code) { old &lt;- setwd(dir) on.exit(setwd(old)) force(code) } A: in_dir() takes a path to a working directory as an argument. First the working directory is changed accordingly. on.exit() ensures that the modification to the working directory are reset to the initial value when the function exits. In source() the chdir argument specifies if the working directory should be changed during the evaluation of the file argument (which in this case has to be a path name). XXX 6.7.5.5 Exercise Can we go over the source code of capture.output and capture.output2? body(capture.output) ## { ## args &lt;- substitute(list(...))[-1L] ## type &lt;- match.arg(type) ## rval &lt;- NULL ## closeit &lt;- TRUE ## if (is.null(file)) ## file &lt;- textConnection(&quot;rval&quot;, &quot;w&quot;, local = TRUE) ## else if (is.character(file)) ## file &lt;- file(file, if (append) ## &quot;a&quot; ## else &quot;w&quot;) ## else if (inherits(file, &quot;connection&quot;)) { ## if (!isOpen(file)) ## open(file, if (append) ## &quot;a&quot; ## else &quot;w&quot;) ## else closeit &lt;- FALSE ## } ## else stop(&quot;&#39;file&#39; must be NULL, a character string or a connection&quot;) ## sink(file, type = type, split = split) ## on.exit({ ## sink(type = type, split = split) ## if (closeit) close(file) ## }) ## pf &lt;- parent.frame() ## evalVis &lt;- function(expr) withVisible(eval(expr, pf)) ## for (i in seq_along(args)) { ## expr &lt;- args[[i]] ## tmp &lt;- switch(mode(expr), expression = lapply(expr, evalVis), ## call = , name = list(evalVis(expr)), stop(&quot;bad argument&quot;)) ## for (item in tmp) if (item$visible) ## print(item$value) ## } ## on.exit() ## sink(type = type, split = split) ## if (closeit) ## close(file) ## if (is.null(rval)) ## invisible(NULL) ## else rval ## } capture.output2 &lt;- function(code) { temp &lt;- tempfile() on.exit(file.remove(temp), add = TRUE) sink(temp) on.exit(sink(), add = TRUE) force(code) readLines(temp) } identical( capture.output(cat(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;\\n&quot;)), capture.output2(cat(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;\\n&quot;)) ) ## [1] TRUE The second function is more concise but what is it missing from the first? I’d like to go over the first one line by line. XXX 6.8.4 Replacement functions Can we put into words the translation for x &lt;- c(a = 1, b = 2, c = 3) names(x) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; names(x)[2] &lt;- &quot;two&quot; names(x) ## [1] &quot;a&quot; &quot;two&quot; &quot;c&quot; Being equal to `*tmp*` &lt;- x x &lt;- `names&lt;-`(`*tmp*`, `[&lt;-`(names(`*tmp*`), 2, &quot;two&quot;)) rm(`*tmp*`) XXX 6.8.6.3 Exercise This question is flagged as “started” let’s try to complete it! Q: Explain why the following code fails: ```r modify(get(&quot;x&quot;), 1) &lt;- 10 #&gt; Error: target of assignment expands to non-language object ``` A: First, let’s define x and recall the definition of modify() from the textbook: ```r x &lt;- 1:3 `modify&lt;-` &lt;- function(x, position, value) { x[position] &lt;- value x } ``` XXX "]
]
